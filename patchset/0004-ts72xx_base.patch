From 7ca59a8c34d13624eedab79ddb5022c1600039ff Mon Sep 17 00:00:00 2001
From: Matthieu Crapet <mcrapet@gmail.com>
Date: Wed, 14 Jan 2009 13:25:12 +0100
Subject: [PATCH 04/22] ts72xx_base

---
 arch/arm/Kconfig                                |    2 +
 arch/arm/include/asm/memory.h                   |    3 +-
 arch/arm/mach-ep93xx/Kconfig                    |    9 +
 arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h |   11 ++
 arch/arm/mach-ep93xx/include/mach/memory.h      |  220 ++++++++++++++++++++++-
 arch/arm/mach-ep93xx/include/mach/ts72xx.h      |   86 +++++++++-
 arch/arm/mach-ep93xx/include/mach/uncompress.h  |   65 +++++++
 arch/arm/mach-ep93xx/ts72xx.c                   |   38 ++++-
 arch/arm/mm/discontig.c                         |  100 ++++++++++-
 arch/arm/mm/init.c                              |   32 ++--
 arch/arm/mm/proc-arm920.S                       |    5 +-
 11 files changed, 544 insertions(+), 27 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 70dba16..d196fe8 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -267,6 +267,7 @@ config ARCH_EP93XX
 	bool "EP93xx-based"
 	select ARM_AMBA
 	select ARM_VIC
+	select ARCH_DISCONTIGMEM_ENABLE
 	select GENERIC_GPIO
 	select HAVE_CLK
 	select ARCH_REQUIRE_GPIOLIB
@@ -832,6 +833,7 @@ config ARCH_SELECT_MEMORY_MODEL
 
 config NODES_SHIFT
 	int
+	default "5" if ARCH_EP93XX
 	default "4" if ARCH_LH7A40X
 	default "2"
 	depends on NEED_MULTIPLE_NODES
diff --git a/arch/arm/include/asm/memory.h b/arch/arm/include/asm/memory.h
index bf7c737..acf566c 100644
--- a/arch/arm/include/asm/memory.h
+++ b/arch/arm/include/asm/memory.h
@@ -273,7 +273,8 @@ static inline __deprecated void *bus_to_virt(unsigned long x)
  * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
  * and returns the mem_map of that node.
  */
-#define ADDR_TO_MAPBASE(kaddr)	NODE_MEM_MAP(KVADDR_TO_NID(kaddr))
+// Crude hack: see arch/arm/mach-ep93xx/include/mach/memory.h
+//#define ADDR_TO_MAPBASE(kaddr)	NODE_MEM_MAP(KVADDR_TO_NID(kaddr))
 
 /*
  * Given a page frame number, find the owning node of the memory
diff --git a/arch/arm/mach-ep93xx/Kconfig b/arch/arm/mach-ep93xx/Kconfig
index ea8549b..c29b2ec 100644
--- a/arch/arm/mach-ep93xx/Kconfig
+++ b/arch/arm/mach-ep93xx/Kconfig
@@ -7,6 +7,15 @@ config CRUNCH
 	help
 	  Enable kernel support for MaverickCrunch.
 
+config CR1_NFBIT
+	bool "Turn on nF bit in ControlRegister 1"
+	help
+	  Say 'Y' here to force the nF bit on.  Usually this is set
+	  by the bootrom.  If it is not set, then the CPU core will
+	  run from HCLK instead of FCLK, and performance will suffer.
+	  If you see BogoMIPS of about 1/4 of your CPU clock, try
+	  turning this on; your performance should double.
+
 comment "EP93xx Platforms"
 
 config MACH_ADSSPHERE
diff --git a/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h b/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h
index 9f4458c..ccc5e6a 100644
--- a/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h
+++ b/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h
@@ -70,6 +70,8 @@
 #define EP93XX_I2S_BASE			(EP93XX_APB_VIRT_BASE + 0x00020000)
 
 #define EP93XX_SECURITY_BASE		(EP93XX_APB_VIRT_BASE + 0x00030000)
+#define EP93XX_SECURITY_REG(x)		(EP93XX_SECURITY_BASE + (x))
+#define EP93XX_SECURITY_UNIQID		EP93XX_SECURITY_REG(0x2440)
 
 #define EP93XX_GPIO_BASE		(EP93XX_APB_VIRT_BASE + 0x00040000)
 #define EP93XX_GPIO_REG(x)		(EP93XX_GPIO_BASE + (x))
@@ -78,20 +80,28 @@
 #define EP93XX_GPIO_F_INT_ACK		EP93XX_GPIO_REG(0x54)
 #define EP93XX_GPIO_F_INT_ENABLE	EP93XX_GPIO_REG(0x58)
 #define EP93XX_GPIO_F_INT_STATUS	EP93XX_GPIO_REG(0x5c)
+#define EP93XX_GPIO_F_INT_DEBOUNCE	EP93XX_GPIO_REG(0x64)
 #define EP93XX_GPIO_A_INT_TYPE1		EP93XX_GPIO_REG(0x90)
 #define EP93XX_GPIO_A_INT_TYPE2		EP93XX_GPIO_REG(0x94)
 #define EP93XX_GPIO_A_INT_ACK		EP93XX_GPIO_REG(0x98)
 #define EP93XX_GPIO_A_INT_ENABLE	EP93XX_GPIO_REG(0x9c)
+#define EP93XX_GPIO_A_INT_DEBOUNCE	EP93XX_GPIO_REG(0xa8)
 #define EP93XX_GPIO_A_INT_STATUS	EP93XX_GPIO_REG(0xa0)
 #define EP93XX_GPIO_B_INT_TYPE1		EP93XX_GPIO_REG(0xac)
 #define EP93XX_GPIO_B_INT_TYPE2		EP93XX_GPIO_REG(0xb0)
 #define EP93XX_GPIO_B_INT_ACK		EP93XX_GPIO_REG(0xb4)
 #define EP93XX_GPIO_B_INT_ENABLE	EP93XX_GPIO_REG(0xb8)
 #define EP93XX_GPIO_B_INT_STATUS	EP93XX_GPIO_REG(0xbc)
+#define EP93XX_GPIO_B_INT_DEBOUNCE	EP93XX_GPIO_REG(0xc4)
+
+#define EP93XX_GPIO_A_DATA		EP93XX_GPIO_REG(0x00)
+#define EP93XX_GPIO_A_DIRECTION		EP93XX_GPIO_REG(0x10)
+#define EP93XX_GPIO_B_DATA		EP93XX_GPIO_REG(0x04)
 
 #define EP93XX_AAC_BASE			(EP93XX_APB_VIRT_BASE + 0x00080000)
 
 #define EP93XX_SPI_BASE			(EP93XX_APB_VIRT_BASE + 0x000a0000)
+#define EP93XX_SPI_PHYS_BASE	(EP93XX_APB_PHYS_BASE + 0x000a0000)
 
 #define EP93XX_IRDA_BASE		(EP93XX_APB_VIRT_BASE + 0x000b0000)
 
@@ -125,6 +135,7 @@
 #define EP93XX_SYSCON_CLOCK_SET2	EP93XX_SYSCON_REG(0x24)
 #define EP93XX_SYSCON_DEVICE_CONFIG	EP93XX_SYSCON_REG(0x80)
 #define EP93XX_SYSCON_DEVICE_CONFIG_CRUNCH_ENABLE	0x00800000
+#define EP93XX_SYSCON_CHIPID		EP93XX_SYSCON_REG(0x94)
 #define EP93XX_SYSCON_SWLOCK		EP93XX_SYSCON_REG(0xc0)
 
 #define EP93XX_WATCHDOG_BASE		(EP93XX_APB_VIRT_BASE + 0x00140000)
diff --git a/arch/arm/mach-ep93xx/include/mach/memory.h b/arch/arm/mach-ep93xx/include/mach/memory.h
index f1b6335..b202d93 100644
--- a/arch/arm/mach-ep93xx/include/mach/memory.h
+++ b/arch/arm/mach-ep93xx/include/mach/memory.h
@@ -1,14 +1,224 @@
 /*
- * arch/arm/mach-ep93xx/include/mach/memory.h
+ *  arch/arm/mach-ep93xx/include/mach/memory.h
+ *
+ *  ******************************************************
+ *	*    CONFUSED?  Read Documentation/IO-mapping.txt	 *
+ *  ******************************************************
+ *
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2002-2003 Cirrus Logic Corp.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
-
 #ifndef __ASM_ARCH_MEMORY_H
 #define __ASM_ARCH_MEMORY_H
 
-#define PHYS_OFFSET		UL(0x00000000)
+/*
+ * For EP93xx, SDRAM can be discontiguous, in a set number of blocks
+ * of equal size and (usually) equal spacing.  The 9301 spacing isn't equal.
+ *
+ * SDRAM_START is the physical address of the start of SDRAM.
+ * SDRAM_NUMBER_OF_BLOCKS = # of blocks of SDRAM.
+ * Each block is of size SDRAM_BLOCK_SIZE and starts at a boundary
+ * of SDRAM_BLOCK_START_BOUNDARY.
+ *
+ * So memory blocks are at:
+ *  SDRAM_START
+ *  SDRAM_START + SDRAM_BLOCK_START_BOUNDARY
+ *  SDRAM_START + (SDRAM_BLOCK_START_BOUNDARY * 2)
+ *  SDRAM_START + (SDRAM_BLOCK_START_BOUNDARY * 3)
+ *  so on
+ */
+
+#ifndef CONFIG_DISCONTIGMEM
+
+/*
+ * Single 32Meg block of physical memory physically located at 0 .
+ */
+#define SDRAM_START                         0x00000000
+#define SDRAM_NUMBER_OF_BLOCKS              1
+#define SDRAM_BLOCK_SIZE                    0x02000000
+#define SDRAM_BLOCK_START_BOUNDARY          0x00000000
+
+#else /* CONFIG_DISCONTIGMEM */
+
+#ifdef CONFIG_ARCH_EP9301
+
+/*
+ * The 9301 memory map doesn't have regular gaps because two
+ * address pins aren't connected - see asm-arm/mach-ep93xx/arch.c to
+ * see how it is.
+ */
+#define SDRAM_START                         0x00000000
+#define SDRAM_NUMBER_OF_BLOCKS              4
+#define SDRAM_BLOCK_SIZE                    0x00800000
+#define SDRAM_BLOCK_START_BOUNDARY          0x01000000
+
+#else /* CONFIG_ARCH_EP9312 or CONFIG_ARCH_EP9315 */
+
+/*
+ * 2 32Meg blocks that are located physically at 0 and 64Meg.
+ */
+#define SDRAM_START                         0x00000000
+#define SDRAM_NUMBER_OF_BLOCKS              2
+#define SDRAM_BLOCK_SIZE                    0x02000000
+#define SDRAM_BLOCK_START_BOUNDARY          0x04000000
+
+#endif
+
+/*
+ * Here we are assuming EP93xx is configured to have two 32MB SDRAM
+ * areas with 32MB of empty space between them.  So use 24 for the node
+ * max shift to get 64MB node sizes.
+ */
+#define NODE_MAX_MEM_SHIFT	26
+#define NODE_MAX_MEM_SIZE	(1<<NODE_MAX_MEM_SHIFT)
+
+#endif /* CONFIG_DISCONTIGMEM */
+
+
+/*
+ * MEM_SIZE and PHYS_OFFSET are used to set size of SDRAM for
+ * initial page table in arch/arm/kernel/setup.c
+ * For ep93xx, PHYS_OFFSET is set to be SDRAM_START.
+ */
+#define MEM_SIZE                            (SDRAM_BLOCK_SIZE)
+
+/*
+ * Task size: 2GB (from 0 to base of IO in virtual space)
+ */
+#define TASK_SIZE		UL(0x80000000)
+/*  HASH define TASK_SIZE_26	(0x04000000UL) */
+
+/*
+ * This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE (TASK_SIZE / 3)
+
+/*
+ * Page offset: 3GB (start of kernel memory in virtual space)
+ * Phys offset: 0   (start of kernel memory in physical space)
+ */
+#define PAGE_OFFSET		UL(0xC0000000)
+#define PHYS_OFFSET		(SDRAM_START)
+
+#ifndef __ASSEMBLY__
+/*
+ * Given a page frame number, convert it to a node id.
+ */
+static inline unsigned long PFN_TO_NID(unsigned long pfn) {
+	unsigned long block = (pfn >> 12);
+
+	switch(block) {
+	case 0x0:
+		return 0;
+	case 0x1:
+		return 1;
+	case 0x2:
+		return 2;
+	case 0x3:
+		return 3;
+	case 0x4:
+		return 4;
+	case 0x5:
+		return 5;
+	case 0x6:
+		return 6;
+	case 0x7:
+		return 7;
+	case 0xc0:
+		return 8;
+	case 0xc1:
+		return 9;
+	case 0xc4:
+		return 10;
+	case 0xc5:
+		return 11;
+	case 0xd0:
+		return 12;
+	case 0xd1:
+		return 13;
+	case 0xd4:
+		return 14;
+	case 0xd5:
+		return 15;
+	case 0xe0:
+		return 16;
+	case 0xe1:
+		return 17;
+	case 0xe4:
+		return 18;
+	case 0xe5:
+		return 19;
+	default:
+		return 0xff;
+	}
+}
+#endif
+
+/*
+ * Virtual view <-> DMA view memory address translations
+ * virt_to_bus: Used to translate the virtual address to an
+ *              address suitable to be passed to set_dma_addr
+ * bus_to_virt: Used to convert an address for DMA operations
+ *              to an address that the kernel can use.
+ */
+#define __virt_to_bus__is_a_macro
+#define __virt_to_bus(x)	 __virt_to_phys(x)
+
+#define __bus_to_virt__is_a_macro
+#define __bus_to_virt(x)	 __phys_to_virt(x)
+
+
+/*
+ * Note that this file is included by include/asm-arm/memory.h so
+ * the macros in this file have to play nice with those.
+ */
+#ifdef CONFIG_DISCONTIGMEM
+
+/*
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr) \
+		((unsigned long)(PFN_TO_NID(__virt_to_phys((unsigned long)addr) >> PAGE_SHIFT)))
+
+/*
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr) NODE_MEM_MAP(KVADDR_TO_NID((unsigned long)(kaddr)))
+
+#define PFN_TO_MAPBASE(pfn)	NODE_MEM_MAP(PFN_TO_NID(pfn))
+
+/*
+ * Given a kaddr, LOCAL_MAR_NR finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+
+
+#define LOCAL_MAP_NR(kaddr)					\
+	(((unsigned long)(kaddr) & (0xffffffUL)) >> PAGE_SHIFT)
+
+
+
+
 
-#define __bus_to_virt(x)	__phys_to_virt(x)
-#define __virt_to_bus(x)	__virt_to_phys(x)
 
+#endif /* CONFIG_DISCONTIGMEM */
 
 #endif
diff --git a/arch/arm/mach-ep93xx/include/mach/ts72xx.h b/arch/arm/mach-ep93xx/include/mach/ts72xx.h
index 30b318a..6efb17e 100644
--- a/arch/arm/mach-ep93xx/include/mach/ts72xx.h
+++ b/arch/arm/mach-ep93xx/include/mach/ts72xx.h
@@ -8,12 +8,23 @@
  * virt		phys		size
  * febff000	22000000	4K	model number register
  * febfe000	22400000	4K	options register
- * febfd000	22800000	4K	options register #2
+ * febfd000	22800000	4K	options register #2 (JP6 and TS-9420 flags)
  * febfc000	[67]0000000	4K	NAND data register
  * febfb000	[67]0400000	4K	NAND control register
  * febfa000	[67]0800000	4K	NAND busy register
  * febf9000	10800000	4K	TS-5620 RTC index register
  * febf8000	11700000	4K	TS-5620 RTC data register
+ * febf7000	23800000	4K	CPLD watchdog (control register)
+ * febf6000	23c00000	4K	CPLD watchdog (feed register)
+ * febf5000	23400000	4K	PLD version (3 bits)
+ * febf4000	22c00000	4K	RS-485 control register
+ * febf3000	23000000	4K	RS-485 mode register
+ * febf2000	10800000	4K	jumpers/max197 busy bit/COM1 dcd register (8-bit, read only)
+ * febf1000	10f00000	4K	max197 sample/control register (16-bit read/8-bit write)
+ * febf0000	11e00000	4K	PC/104 8-bit I/O
+ * febef000	21e00000	4K	PC/104 16-bit I/O
+ * fea00000	11a00000	1MB	PC/104 8-bit memory
+ * fe900000	21a00000	1MB	PC/104 16-bit memory
  */
 
 #define TS72XX_MODEL_PHYS_BASE		0x22000000
@@ -59,7 +70,6 @@
 #define TS72XX_NAND_BUSY_VIRT_BASE	0xfebfa000
 #define TS72XX_NAND_BUSY_SIZE		0x00001000
 
-
 #define TS72XX_RTC_INDEX_VIRT_BASE	0xfebf9000
 #define TS72XX_RTC_INDEX_PHYS_BASE	0x10800000
 #define TS72XX_RTC_INDEX_SIZE		0x00001000
@@ -68,6 +78,61 @@
 #define TS72XX_RTC_DATA_PHYS_BASE	0x11700000
 #define TS72XX_RTC_DATA_SIZE		0x00001000
 
+#define TS72XX_WATCHDOG_CONTROL_VIRT_BASE	0xfebf7000
+#define TS72XX_WATCHDOG_CONTROL_PHYS_BASE	0x23800000
+#define TS72XX_WATCHDOG_CONTROL_SIZE	0x00001000
+
+#define TS72XX_WATCHDOG_FEED_VIRT_BASE	0xfebf6000
+#define TS72XX_WATCHDOG_FEED_PHYS_BASE	0x23c00000
+#define TS72XX_WATCHDOG_FEED_SIZE	0x00001000
+
+#define TS72XX_PLD_VERSION_VIRT_BASE	0xfebf5000
+#define TS72XX_PLD_VERSION_PHYS_BASE	0x23400000
+#define TS72XX_PLD_VERSION_SIZE	0x00001000
+
+#define TS72XX_RS485_CONTROL_VIRT_BASE	0xfebf4000
+#define TS72XX_RS485_CONTROL_PHYS_BASE	0x22c00000
+#define TS72XX_RS485_CONTROL_SIZE	0x00001000
+
+#define TS72XX_RS485_MODE_VIRT_BASE	0xfebf3000
+#define TS72XX_RS485_MODE_PHYS_BASE	0x23000000
+#define TS72XX_RS485_MODE_SIZE	0x00001000
+
+#define TS72XX_JUMPERS_MAX197_VIRT_BASE	0xfebf2000
+#define TS72XX_JUMPERS_MAX197_PHYS_BASE	0x10800000
+#define TS72XX_JUMPERS_MAX197_SIZE	0x00001000
+
+#define TS72XX_MAX197_SAMPLE_VIRT_BASE	0xfebf1000
+#define TS72XX_MAX197_SAMPLE_PHYS_BASE	0x10f00000
+#define TS72XX_MAX197_SAMPLE_SIZE	0x00001000
+
+
+#define TS72XX_PC104_8BIT_IO_VIRT_BASE  0xfebf0000
+#define TS72XX_PC104_8BIT_IO_PHYS_BASE  0x11e00000
+#define TS72XX_PC104_8BIT_IO_SIZE       0x00001000
+#define TS72XX_PC104_8BIT_MEM_VIRT_BASE 0xfea00000
+#define TS72XX_PC104_8BIT_MEM_PHYS_BASE 0x11a00000
+#define TS72XX_PC104_8BIT_MEM_SIZE      0x00100000
+
+#define TS72XX_PC104_16BIT_IO_VIRT_BASE  0xfebef000
+#define TS72XX_PC104_16BIT_IO_PHYS_BASE  0x21e00000
+#define TS72XX_PC104_16BIT_IO_SIZE       0x00001000
+#define TS72XX_PC104_16BIT_MEM_VIRT_BASE 0xfe900000
+#define TS72XX_PC104_16BIT_MEM_PHYS_BASE 0x21a00000
+#define TS72XX_PC104_16BIT_MEM_SIZE      0x00100000
+
+/*
+ * TS7200 CF memory map:
+ *
+ * phys		size	description
+ * 11000000	7	CF registers (8-bit each), starting at 11000001
+ * 10400006	2	CF aux registers (8-bit)
+ * 21000000	2	CF data register (16-bit)
+ */
+
+#define TS7200_CF_CMD_PHYS_BASE  0x11000000
+#define TS7200_CF_AUX_PHYS_BASE  0x10400006
+#define TS7200_CF_DATA_PHYS_BASE 0x21000000
 
 #ifndef __ASSEMBLY__
 #include <asm/io.h>
@@ -98,4 +163,21 @@ static inline int is_ts9420_installed(void)
 	return !!(__raw_readb(TS72XX_OPTIONS2_VIRT_BASE) &
 					TS72XX_OPTIONS2_TS9420);
 }
+
+static inline int is_rs485_installed(void)
+{
+	return !!(__raw_readb(TS72XX_OPTIONS_VIRT_BASE) &
+					TS72XX_OPTIONS_COM2_RS485);
+}
+
+static inline int get_ts72xx_pld_version(void)
+{
+	return (__raw_readb(TS72XX_PLD_VERSION_VIRT_BASE) & 0x7);
+}
+
+static inline int is_jp6_set(void)
+{
+	return (__raw_readb(TS72XX_OPTIONS2_VIRT_BASE) & 0x1);
+}
+
 #endif
diff --git a/arch/arm/mach-ep93xx/include/mach/uncompress.h b/arch/arm/mach-ep93xx/include/mach/uncompress.h
index 1fd2f17..ecdfd64 100644
--- a/arch/arm/mach-ep93xx/include/mach/uncompress.h
+++ b/arch/arm/mach-ep93xx/include/mach/uncompress.h
@@ -77,9 +77,74 @@ static void ethernet_reset(void)
 }
 
 
+/*
+ * We don't have clock management for the UARTs (amba-pl010)
+ * yet, so hackily enable all UART clocks here for now.
+ */
+#define PHYS_SYSCON_DEVICE_CONFIG	0x80930080
+#define PHYS_SYSCON_SWLOCK		0x809300c0
+
+static void enable_all_uart_clocks(void)
+{
+	unsigned int v;
+
+	v = __raw_readl(PHYS_SYSCON_DEVICE_CONFIG);
+	__raw_writel(0xaa, PHYS_SYSCON_SWLOCK);
+	__raw_writel(v | 0x01140000, PHYS_SYSCON_DEVICE_CONFIG);
+}
+
+
+/*
+ * Some bootloaders don't turn on the UARTBAUD bit, which means that
+ * the UARTs will be running off a divided 7.3728 MHz clock instead of
+ * the 14.7456 MHz peripheral clock when linux boots.
+ *
+ * We detect that condition here and fix it by turning on UARTBAUD, and
+ * then reprogramming the divisors on all enabled UARTs to twice what
+ * they were before we turned UARTBAUD on, to preserve the programmed
+ * baud rate.
+ */
+#define PHYS_SYSCON_CLOCK_CONTROL	0x80930004
+#define SYSCON_CLOCK_UARTBAUD		0x20000000
+#define PHYS_UART1_BASE			0x808c0000
+#define PHYS_UART2_BASE			0x808d0000
+#define PHYS_UART3_BASE			0x808e0000
+
+static void uart_divisor_times_two(unsigned int base)
+{
+	u16 divisor;
+
+	divisor = __raw_readb(base + 0x0c) << 8;
+	divisor |= __raw_readb(base + 0x10);
+	if (divisor) {
+		divisor = (2 * (divisor + 1)) - 1;
+		__raw_writeb(divisor >> 8, base + 0x0c);
+		__raw_writeb(divisor & 0xff, base + 0x10);
+		__raw_writeb(__raw_readb(base + 0x08), base + 0x08);
+	}
+}
+
+static void fix_uart_base(void)
+{
+	unsigned int v;
+
+	v = __raw_readl(PHYS_SYSCON_CLOCK_CONTROL);
+	if ((v & SYSCON_CLOCK_UARTBAUD) == 0) {
+		v |= SYSCON_CLOCK_UARTBAUD;
+		__raw_writel(v, PHYS_SYSCON_CLOCK_CONTROL);
+
+		uart_divisor_times_two(PHYS_UART1_BASE);
+		uart_divisor_times_two(PHYS_UART2_BASE);
+		uart_divisor_times_two(PHYS_UART3_BASE);
+	}
+}
+
+
 static void arch_decomp_setup(void)
 {
 	ethernet_reset();
+	enable_all_uart_clocks();
+	fix_uart_base();
 }
 
 #define arch_decomp_wdog()
diff --git a/arch/arm/mach-ep93xx/ts72xx.c b/arch/arm/mach-ep93xx/ts72xx.c
index c3cbff1..5e5a910 100644
--- a/arch/arm/mach-ep93xx/ts72xx.c
+++ b/arch/arm/mach-ep93xx/ts72xx.c
@@ -51,7 +51,36 @@ static struct map_desc ts72xx_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(TS72XX_RTC_DATA_PHYS_BASE),
 		.length		= TS72XX_RTC_DATA_SIZE,
 		.type		= MT_DEVICE,
-	}
+	},
+	/* Use this for debug only. Each device will map its own PC/104 address space */
+	///* PC/104 (8-bit) I/O bus */
+	//{
+	//  .virtual  = TS72XX_PC104_8BIT_IO_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_8BIT_IO_PHYS_BASE),
+	//  .length   = TS72XX_PC104_8BIT_IO_SIZE,
+	//  .type   = MT_DEVICE,
+	//},
+	///* PC/104 (16-bit) I/O bus */
+	//{
+	//  .virtual  = TS72XX_PC104_16BIT_IO_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_16BIT_IO_PHYS_BASE),
+	//  .length   = TS72XX_PC104_16BIT_IO_SIZE,
+	//  .type   = MT_DEVICE,
+	//},
+	///* PC/104 (8-bit) MEM bus */
+	//{
+	//  .virtual  = TS72XX_PC104_8BIT_MEM_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_8BIT_MEM_PHYS_BASE),
+	//  .length   = TS72XX_PC104_8BIT_MEM_SIZE,
+	//  .type   = MT_DEVICE,
+	//},
+	///* PC/104 (16-bit) MEM bus */
+	//{
+	//  .virtual  = TS72XX_PC104_16BIT_MEM_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_16BIT_MEM_PHYS_BASE),
+	//  .length   = TS72XX_PC104_16BIT_MEM_SIZE,
+	//  .type   = MT_DEVICE,
+	//}
 };
 
 static struct map_desc ts72xx_nand_io_desc[] __initdata = {
@@ -111,6 +140,8 @@ static void __init ts72xx_map_io(void)
 	}
 }
 
+/* NOR flash (TS-7200 only) */
+
 static struct physmap_flash_data ts72xx_flash_data = {
 	.width		= 1,
 };
@@ -131,6 +162,8 @@ static struct platform_device ts72xx_flash = {
 	.resource	= &ts72xx_flash_resource,
 };
 
+/* Real time clock  */
+
 static unsigned char ts72xx_rtc_readbyte(unsigned long addr)
 {
 	__raw_writeb(addr, TS72XX_RTC_INDEX_VIRT_BASE);
@@ -157,6 +190,8 @@ static struct platform_device ts72xx_rtc_device = {
 	.num_resources		= 0,
 };
 
+/* Ethernet */
+
 static struct ep93xx_eth_data ts72xx_eth_data = {
 	.phy_id			= 1,
 };
@@ -183,6 +218,7 @@ static struct platform_device ts72xx_eth_device = {
 	.resource	= ts72xx_eth_resource,
 };
 
+
 static void __init ts72xx_init_machine(void)
 {
 	ep93xx_init_devices();
diff --git a/arch/arm/mm/discontig.c b/arch/arm/mm/discontig.c
index c8c0c4b..f336eb1 100644
--- a/arch/arm/mm/discontig.c
+++ b/arch/arm/mm/discontig.c
@@ -13,7 +13,7 @@
 #include <linux/mmzone.h>
 #include <linux/bootmem.h>
 
-#if MAX_NUMNODES != 4 && MAX_NUMNODES != 16
+#if MAX_NUMNODES != 4 && MAX_NUMNODES != 16 && MAX_NUMNODES != 64 && MAX_NUMNODES != 32
 # error Fix Me Please
 #endif
 
@@ -40,6 +40,104 @@ pg_data_t discontig_node_data[MAX_NUMNODES] = {
   { .bdata = &bootmem_node_data[14] },
   { .bdata = &bootmem_node_data[15] },
 #endif
+
+#if MAX_NUMNODES == 32
+  { .bdata = &bootmem_node_data[4] },
+  { .bdata = &bootmem_node_data[5] },
+  { .bdata = &bootmem_node_data[6] },
+  { .bdata = &bootmem_node_data[7] },
+  { .bdata = &bootmem_node_data[8] },
+  { .bdata = &bootmem_node_data[9] },
+  { .bdata = &bootmem_node_data[10] },
+  { .bdata = &bootmem_node_data[11] },
+  { .bdata = &bootmem_node_data[12] },
+  { .bdata = &bootmem_node_data[13] },
+  { .bdata = &bootmem_node_data[14] },
+  { .bdata = &bootmem_node_data[15] },
+
+  { .bdata = &bootmem_node_data[16] },
+  { .bdata = &bootmem_node_data[17] },
+  { .bdata = &bootmem_node_data[18] },
+  { .bdata = &bootmem_node_data[19] },
+  { .bdata = &bootmem_node_data[20] },
+  { .bdata = &bootmem_node_data[21] },
+  { .bdata = &bootmem_node_data[22] },
+  { .bdata = &bootmem_node_data[23] },
+  { .bdata = &bootmem_node_data[24] },
+  { .bdata = &bootmem_node_data[25] },
+  { .bdata = &bootmem_node_data[26] },
+  { .bdata = &bootmem_node_data[27] },
+  { .bdata = &bootmem_node_data[28] },
+  { .bdata = &bootmem_node_data[29] },
+  { .bdata = &bootmem_node_data[30] },
+  { .bdata = &bootmem_node_data[31] },
+#endif
+
+#if MAX_NUMNODES == 64
+  { .bdata = &bootmem_node_data[4] },
+  { .bdata = &bootmem_node_data[5] },
+  { .bdata = &bootmem_node_data[6] },
+  { .bdata = &bootmem_node_data[7] },
+  { .bdata = &bootmem_node_data[8] },
+  { .bdata = &bootmem_node_data[9] },
+  { .bdata = &bootmem_node_data[10] },
+  { .bdata = &bootmem_node_data[11] },
+  { .bdata = &bootmem_node_data[12] },
+  { .bdata = &bootmem_node_data[13] },
+  { .bdata = &bootmem_node_data[14] },
+  { .bdata = &bootmem_node_data[15] },
+
+  { .bdata = &bootmem_node_data[16] },
+  { .bdata = &bootmem_node_data[17] },
+  { .bdata = &bootmem_node_data[18] },
+  { .bdata = &bootmem_node_data[19] },
+  { .bdata = &bootmem_node_data[20] },
+  { .bdata = &bootmem_node_data[21] },
+  { .bdata = &bootmem_node_data[22] },
+  { .bdata = &bootmem_node_data[23] },
+  { .bdata = &bootmem_node_data[24] },
+  { .bdata = &bootmem_node_data[25] },
+  { .bdata = &bootmem_node_data[26] },
+  { .bdata = &bootmem_node_data[27] },
+  { .bdata = &bootmem_node_data[28] },
+  { .bdata = &bootmem_node_data[29] },
+  { .bdata = &bootmem_node_data[30] },
+  { .bdata = &bootmem_node_data[31] },
+
+  { .bdata = &bootmem_node_data[32] },
+  { .bdata = &bootmem_node_data[33] },
+  { .bdata = &bootmem_node_data[34] },
+  { .bdata = &bootmem_node_data[35] },
+  { .bdata = &bootmem_node_data[36] },
+  { .bdata = &bootmem_node_data[37] },
+  { .bdata = &bootmem_node_data[38] },
+  { .bdata = &bootmem_node_data[39] },
+  { .bdata = &bootmem_node_data[40] },
+  { .bdata = &bootmem_node_data[41] },
+  { .bdata = &bootmem_node_data[42] },
+  { .bdata = &bootmem_node_data[43] },
+  { .bdata = &bootmem_node_data[44] },
+  { .bdata = &bootmem_node_data[45] },
+  { .bdata = &bootmem_node_data[46] },
+  { .bdata = &bootmem_node_data[47] },
+
+  { .bdata = &bootmem_node_data[48] },
+  { .bdata = &bootmem_node_data[49] },
+  { .bdata = &bootmem_node_data[50] },
+  { .bdata = &bootmem_node_data[51] },
+  { .bdata = &bootmem_node_data[52] },
+  { .bdata = &bootmem_node_data[53] },
+  { .bdata = &bootmem_node_data[54] },
+  { .bdata = &bootmem_node_data[55] },
+  { .bdata = &bootmem_node_data[56] },
+  { .bdata = &bootmem_node_data[57] },
+  { .bdata = &bootmem_node_data[58] },
+  { .bdata = &bootmem_node_data[59] },
+  { .bdata = &bootmem_node_data[60] },
+  { .bdata = &bootmem_node_data[61] },
+  { .bdata = &bootmem_node_data[62] },
+  { .bdata = &bootmem_node_data[63] },
+#endif
 };
 
 EXPORT_SYMBOL(discontig_node_data);
diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c
index 30a69d6..a38c66f 100644
--- a/arch/arm/mm/init.c
+++ b/arch/arm/mm/init.c
@@ -43,26 +43,18 @@ static struct meminfo meminfo = { 0, };
 void show_mem(void)
 {
 	int free = 0, total = 0, reserved = 0;
-	int shared = 0, cached = 0, slab = 0, node, i;
+	int shared = 0, cached = 0, slab = 0, node, i, k;
 	struct meminfo * mi = &meminfo;
 
 	printk("Mem-info:\n");
 	show_free_areas();
 	for_each_online_node(node) {
-		pg_data_t *n = NODE_DATA(node);
-		struct page *map = n->node_mem_map - n->node_start_pfn;
-
 		for_each_nodebank (i,mi,node) {
-			unsigned int pfn1, pfn2;
-			struct page *page, *end;
-
-			pfn1 = __phys_to_pfn(mi->bank[i].start);
-			pfn2 = __phys_to_pfn(mi->bank[i].size + mi->bank[i].start);
+			struct page *page;
 
-			page = map + pfn1;
-			end  = map + pfn2;
+      page = NODE_MEM_MAP(node);
 
-			do {
+      for (k=0; k<NODE_DATA(node)->node_present_pages; k++) {
 				total++;
 				if (PageReserved(page))
 					reserved++;
@@ -75,7 +67,7 @@ void show_mem(void)
 				else
 					shared += page_count(page) - 1;
 				page++;
-			} while (page < end);
+			};
 		}
 	}
 
@@ -94,11 +86,19 @@ void show_mem(void)
  * the end, we won't clash.
  */
 static unsigned int __init
-find_bootmap_pfn(int node, struct meminfo *mi, unsigned int bootmap_pages)
+find_bootmap_pfn(int node, struct meminfo *mi, unsigned int bootmap_pages, int initrd_node)
 {
 	unsigned int start_pfn, bank, bootmap_pfn;
 
-	start_pfn   = PAGE_ALIGN(__pa(&_end)) >> PAGE_SHIFT;
+	if (node == initrd_node) {
+	  /* push start_pfn past the ramdisk */
+	  start_pfn = (phys_initrd_start + phys_initrd_size) >> PAGE_SHIFT;
+	  /* if (unlikely) not an even page length, round up by a page */
+	  start_pfn = ((phys_initrd_start + phys_initrd_size) & PAGE_MASK ? start_pfn+1 : start_pfn);
+	} else {
+	  start_pfn   = PAGE_ALIGN(__pa(&_end)) >> PAGE_SHIFT;
+	}
+
 	bootmap_pfn = 0;
 
 	for_each_nodebank(bank, mi, node) {
@@ -220,7 +220,7 @@ bootmem_init_node(int node, int initrd_node, struct meminfo *mi)
 	 * Allocate the bootmem bitmap page.
 	 */
 	boot_pages = bootmem_bootmap_pages(end_pfn - start_pfn);
-	boot_pfn = find_bootmap_pfn(node, mi, boot_pages);
+	boot_pfn = find_bootmap_pfn(node, mi, boot_pages, initrd_node);
 
 	/*
 	 * Initialise the bootmem allocator for this node, handing the
diff --git a/arch/arm/mm/proc-arm920.S b/arch/arm/mm/proc-arm920.S
index 28cdb06..be31476 100644
--- a/arch/arm/mm/proc-arm920.S
+++ b/arch/arm/mm/proc-arm920.S
@@ -198,7 +198,7 @@ ENTRY(arm920_coherent_kern_range)
  */
 ENTRY(arm920_coherent_user_range)
 	bic	r0, r0, #CACHE_DLINESIZE - 1
-1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
 	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
 	add	r0, r0, #CACHE_DLINESIZE
 	cmp	r0, r1
@@ -395,6 +395,9 @@ __arm920_setup:
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	bic	r0, r0, r5
 	orr	r0, r0, r6
+#ifdef CONFIG_CR1_NFBIT
+        orr     r0, r0, #0x40000000             @ set nF
+#endif
 	mov	pc, lr
 	.size	__arm920_setup, . - __arm920_setup
 
-- 
1.5.6.5

