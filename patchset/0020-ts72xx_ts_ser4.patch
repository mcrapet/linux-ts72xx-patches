From 87a0f7375ec4e8c1a13c93382fa229fe0af2d10c Mon Sep 17 00:00:00 2001
From: Matthieu Crapet <mcrapet@gmail.com>
Date: Sun, 14 Nov 2010 21:52:53 +0100
Subject: [PATCH] ts72xx_ts_ser4

TS-SER4 - Quad Serial Port PC/104 peripheral
---
 drivers/serial/8250_ts_ser4.c |  196 +++++++++++++++++++++++++++++++++++++++++
 drivers/serial/Kconfig        |   32 +++++++
 drivers/serial/Makefile       |    1 +
 3 files changed, 229 insertions(+), 0 deletions(-)
 create mode 100644 drivers/serial/8250_ts_ser4.c

diff --git a/drivers/serial/8250_ts_ser4.c b/drivers/serial/8250_ts_ser4.c
new file mode 100644
index 0000000..e9c34ba
--- /dev/null
+++ b/drivers/serial/8250_ts_ser4.c
@@ -0,0 +1,196 @@
+/*
+ *  linux/drivers/serial/8250_ts_ser4.c
+ *  Technologic Systems TS-SER4 support.
+ *
+ * (c) Copyright 2010  Nebojsa Cosic <nebojsa@asnn.org>
+ * based on 8250_ts_ser1.c by Matthieu Crapet <mcrapet@gmail.com>
+ * Data taken from include/asm-i386/serial.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Pin Number:
+ * 1 DCD
+ * 2 Receive data
+ * 3 Trasmit data
+ * 4 DTR
+ * 5 Signal Ground
+ * 6 DSR
+ * 7 RTS
+ * 8 CTS
+ * 9 RI
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/ts72xx.h>
+#include <mach/gpio.h>
+
+#define TS72XX_SER4_IO_PHYS_BASE	(TS72XX_PC104_8BIT_IO_PHYS_BASE)
+#define TS72XX_SER4_IO_SIZE		(TS72XX_PC104_8BIT_IO_SIZE)
+
+#define PORT()	\
+{					\
+	.iobase   = 0,			\
+	.membase  = (void __iomem *)0,	\
+	.irq      = 0,			\
+	.uartclk  = 1843200,		\
+	.iotype   = UPIO_PORT,		\
+	.flags    = UPF_BOOT_AUTOCONF,	\
+}
+
+/* Note: IRQ can be shared (see CONFIG_SERIAL_8250_SHARE_IRQ) */
+
+
+#define port_count 4
+static int ts_addresses[]={
+	0x3F8, 0x2F8, 0x3E8, 0x2E8, 0x3A8, 0x2A8, 0x3A0, 0x2A0,
+	0x398, 0x298, 0x390, 0x290, 0x378, 0x278, 0x368, 0x268,
+	0x328, 0x228, 0x320, 0x220, 0x318, 0x218, 0x310, 0x210
+};
+
+static int ts_irq = CONFIG_SERIAL_8250_TS_SER4_IRQ; // 5, 6 or 7
+static int ts_com[port_count];
+static int ts_com_count = 0;
+static int ts_base = CONFIG_SERIAL_8250_TS_SER4_BASE; // base address control
+
+
+static struct plat_serial8250_port ts72xx_ser4_data[] = {
+	PORT(),
+	PORT(),
+	PORT(),
+	PORT(),
+	{ },
+};
+
+static struct platform_device *serial8250_ts_ser4_dev;
+
+static int __init ts_ser4_init(void)
+{
+	void __iomem *iomem;
+
+	int ret = -ENODEV;
+	int i;
+	unsigned int irq=0;
+
+	iomem = ioremap(TS72XX_SER4_IO_PHYS_BASE, TS72XX_SER4_IO_SIZE);
+	if (ts_com_count==0) {
+		for (i = 0; i < port_count; i++) {
+			ts_com[i] = ts_addresses[CONFIG_SERIAL_8250_TS_SER4_COM+i-1]; // CONFIG_SERIAL_8250_TS_SER4_COM starts at 1
+		}
+	}
+
+	printk(KERN_INFO "ts_base: 0x%x\n", ts_base);
+
+	for (i = 0; i < port_count; i++) {
+		printk(KERN_INFO "ts_com[%d] = 0x%x\n", i, ts_com[i]);
+	}
+	printk(KERN_INFO "got %d arguments for ts_com.\n", ts_com_count);
+	if (iomem == NULL) {
+		pr_err("ioremap failed\n");
+		return -ENOMEM;
+	}
+	for (i = 0; i < 4; i++) {
+		printk(KERN_INFO "ts_base-%d = 0x%x.\n", i,(int)__raw_readb(iomem + ts_base + i));
+	}
+	if (__raw_readb(iomem + ts_base)!=0x7a) {
+		pr_err("No TS-SER4 detected on a given base address\n");
+		goto init_error;
+	}
+	switch (ts_irq) {
+		case 5:
+			ret = gpio_request(EP93XX_GPIO_LINE_F(3), "TS-SER4");
+			if (ret < 0) {
+				pr_err("gpio_request failed, try another irq\n");
+				goto init_error;
+			}
+			gpio_direction_input(EP93XX_GPIO_LINE_F(3));
+			irq = gpio_to_irq(EP93XX_GPIO_LINE_F(3));
+			set_irq_type(irq, IRQ_TYPE_EDGE_RISING);
+			break;
+		case 6:
+			irq = IRQ_EP93XX_EXT1;
+			break;
+		case 7:
+			irq = IRQ_EP93XX_EXT3;
+			break;
+		default:
+			pr_err("wrong specified irq\n");
+			goto init_error;
+	}
+
+	for (i = 0; i < port_count; i++) {
+		ts72xx_ser4_data[i].iobase = (unsigned long)iomem+ts_com[i]; // virtual address
+		ts72xx_ser4_data[i].irq = irq;
+	}
+
+	/* create platform_device structure */
+	serial8250_ts_ser4_dev = platform_device_alloc("serial8250", 0);
+	if (!serial8250_ts_ser4_dev) {
+		ret = -ENOMEM;
+		goto init_error;
+	}
+	ret = platform_device_add_data(serial8250_ts_ser4_dev, ts72xx_ser4_data, sizeof(ts72xx_ser4_data));
+	if (ret) {
+		platform_device_put(serial8250_ts_ser4_dev);
+		goto init_error;
+	}
+
+	ret = platform_device_add(serial8250_ts_ser4_dev);
+	if (ret) {
+		platform_device_put(serial8250_ts_ser4_dev);
+		goto init_error;
+	}
+
+	platform_set_drvdata(serial8250_ts_ser4_dev, iomem);
+	return 0;
+
+init_error:
+	if (iomem) {
+		iounmap(iomem);
+		iomem = NULL;
+	}
+	return ret;
+}
+
+static void __exit ts_ser4_exit(void)
+{
+	struct platform_device *pdev = serial8250_ts_ser4_dev;
+	void __iomem *iomem = platform_get_drvdata(pdev);
+
+	serial8250_ts_ser4_dev = NULL;
+
+	platform_device_unregister(pdev);
+
+	iounmap(iomem);
+	if (ts_irq == 5)
+		gpio_free(EP93XX_GPIO_LINE_F(3));
+}
+
+module_init(ts_ser4_init);
+module_exit(ts_ser4_exit);
+
+module_param(ts_irq, int, 0);
+MODULE_PARM_DESC(ts_irq, "TS-SER4 IRQ, default=" __MODULE_STRING(CONFIG_SERIAL_8250_TS_SER4_IRQ) ")");
+module_param_array(ts_com, int, &ts_com_count, 0000);
+MODULE_PARM_DESC(ts_com, "Array of up to four COM base addresses, default=" __MODULE_STRING(CONFIG_SERIAL_8250_TS_SER4_COM) ")");
+module_param(ts_base, int, 0);
+MODULE_PARM_DESC(ts_base, "Control register base address, default=" __MODULE_STRING(CONFIG_SERIAL_8250_TS_SER4_BASE) ")");
+
+MODULE_AUTHOR("Nebojsa Cosic <nebojsa@asnn.org>");
+MODULE_DESCRIPTION("8250 serial probe module for TS-SER4 (TS-72xx)");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index 9f38fc5..0bd6f8f 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -292,6 +292,38 @@ config SERIAL_8250_TS_SER1_IRQ
 	help
 	  Enter jumper IRQ configuration
 
+config SERIAL_8250_TS_SER4
+	tristate "Support TS-SER4 (for TS-72XX SBC)"
+	depends on SERIAL_8250 != n && MACH_TS72XX
+	help
+	  Say Y here if you have a TS-SER4 PC/104 peripheral.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called 8250_ts_ser4.
+
+config SERIAL_8250_TS_SER4_IRQ
+	int "Selected IRQ (5, 6 or 7)"
+	depends on SERIAL_8250_TS_SER4
+	default "5"
+	help
+	  Enter jumper IRQ configuration
+
+config SERIAL_8250_TS_SER4_BASE
+	hex "Board base address"
+	depends on SERIAL_8250_TS_SER4
+	default "0x230"
+	help
+	  Enter board base address as selected by COM1,COM2 and COM4 jumpers
+
+config SERIAL_8250_TS_SER4_COM
+	int "First COM active port"
+	depends on SERIAL_8250_TS_SER4
+	default "1"
+  range 1 21
+	help
+	  Enter COM port I/O locations, as selected by COM1,COM2 and COM4 jumpers.
+	  Value must be between 1 and 21.
+
 comment "Non-8250 serial port support"
 
 config SERIAL_AMBA_PL010
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index a3b1cf2..d9d22e1 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_SERIAL_8250_EXAR_ST16C554) += 8250_exar_st16c554.o
 obj-$(CONFIG_SERIAL_8250_HUB6) += 8250_hub6.o
 obj-$(CONFIG_SERIAL_8250_MCA) += 8250_mca.o
 obj-$(CONFIG_SERIAL_8250_TS_SER1) += 8250_ts_ser1.o
+obj-$(CONFIG_SERIAL_8250_TS_SER4) += 8250_ts_ser4.o
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
-- 
1.7.2.3

