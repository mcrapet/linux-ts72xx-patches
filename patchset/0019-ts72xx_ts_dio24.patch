From 0122c23fbf54ae4d03f89e08077e754c0a4d7218 Mon Sep 17 00:00:00 2001
From: Matthieu Crapet <mcrapet@gmail.com>
Date: Sun, 14 Nov 2010 16:18:13 +0100
Subject: [PATCH] ts72xx_ts_dio24

TS-DIO24 - 24 Digital Input/Output PC/104 peripheral
---
 arch/arm/mach-ep93xx/gpio.c              |   32 ++-
 arch/arm/mach-ep93xx/include/mach/gpio.h |    5 +-
 arch/arm/mach-ep93xx/ts72xx.c            |   21 ++
 drivers/gpio/Kconfig                     |    8 +
 drivers/gpio/Makefile                    |    3 +-
 drivers/gpio/ts-dio24.c                  |  440 ++++++++++++++++++++++++++++++
 6 files changed, 493 insertions(+), 16 deletions(-)
 create mode 100644 drivers/gpio/ts-dio24.c

diff --git a/arch/arm/mach-ep93xx/gpio.c b/arch/arm/mach-ep93xx/gpio.c
index cf547ad..fed8605 100644
--- a/arch/arm/mach-ep93xx/gpio.c
+++ b/arch/arm/mach-ep93xx/gpio.c
@@ -63,7 +63,7 @@ static inline void ep93xx_gpio_int_mask(unsigned line)
 
 void ep93xx_gpio_int_debounce(unsigned int irq, int enable)
 {
-	int line = irq_to_gpio(irq);
+	int line = irq_to_gpio_onboard(irq);
 	int port = line >> 3;
 	int port_mask = 1 << (line & 7);
 
@@ -85,7 +85,7 @@ static void ep93xx_gpio_ab_irq_handler(unsigned int irq, struct irq_desc *desc)
 	status = __raw_readb(EP93XX_GPIO_A_INT_STATUS);
 	for (i = 0; i < 8; i++) {
 		if (status & (1 << i)) {
-			int gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_A(0)) + i;
+			int gpio_irq = gpio_to_irq_onboard(EP93XX_GPIO_LINE_A(0)) + i;
 			generic_handle_irq(gpio_irq);
 		}
 	}
@@ -93,7 +93,7 @@ static void ep93xx_gpio_ab_irq_handler(unsigned int irq, struct irq_desc *desc)
 	status = __raw_readb(EP93XX_GPIO_B_INT_STATUS);
 	for (i = 0; i < 8; i++) {
 		if (status & (1 << i)) {
-			int gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_B(0)) + i;
+			int gpio_irq = gpio_to_irq_onboard(EP93XX_GPIO_LINE_B(0)) + i;
 			generic_handle_irq(gpio_irq);
 		}
 	}
@@ -104,17 +104,17 @@ static void ep93xx_gpio_f_irq_handler(unsigned int irq, struct irq_desc *desc)
 	/*
 	 * map discontiguous hw irq range to continous sw irq range:
 	 *
-	 *  IRQ_EP93XX_GPIO{0..7}MUX -> gpio_to_irq(EP93XX_GPIO_LINE_F({0..7})
+	 *  IRQ_EP93XX_GPIO{0..7}MUX -> gpio_to_irq_onboard(EP93XX_GPIO_LINE_F({0..7})
 	 */
 	int port_f_idx = ((irq + 1) & 7) ^ 4; /* {19..22,47..50} -> {0..7} */
-	int gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_F(0)) + port_f_idx;
+	int gpio_irq = gpio_to_irq_onboard(EP93XX_GPIO_LINE_F(0)) + port_f_idx;
 
 	generic_handle_irq(gpio_irq);
 }
 
 static void ep93xx_gpio_irq_ack(unsigned int irq)
 {
-	int line = irq_to_gpio(irq);
+	int line = irq_to_gpio_onboard(irq);
 	int port = line >> 3;
 	int port_mask = 1 << (line & 7);
 
@@ -128,7 +128,7 @@ static void ep93xx_gpio_irq_ack(unsigned int irq)
 
 static void ep93xx_gpio_irq_mask_ack(unsigned int irq)
 {
-	int line = irq_to_gpio(irq);
+	int line = irq_to_gpio_onboard(irq);
 	int port = line >> 3;
 	int port_mask = 1 << (line & 7);
 
@@ -143,7 +143,7 @@ static void ep93xx_gpio_irq_mask_ack(unsigned int irq)
 
 static void ep93xx_gpio_irq_mask(unsigned int irq)
 {
-	int line = irq_to_gpio(irq);
+	int line = irq_to_gpio_onboard(irq);
 	int port = line >> 3;
 
 	gpio_int_unmasked[port] &= ~(1 << (line & 7));
@@ -152,7 +152,7 @@ static void ep93xx_gpio_irq_mask(unsigned int irq)
 
 static void ep93xx_gpio_irq_unmask(unsigned int irq)
 {
-	int line = irq_to_gpio(irq);
+	int line = irq_to_gpio_onboard(irq);
 	int port = line >> 3;
 
 	gpio_int_unmasked[port] |= 1 << (line & 7);
@@ -167,7 +167,7 @@ static void ep93xx_gpio_irq_unmask(unsigned int irq)
 static int ep93xx_gpio_irq_type(unsigned int irq, unsigned int type)
 {
 	struct irq_desc *desc = irq_desc + irq;
-	const int gpio = irq_to_gpio(irq);
+	const int gpio = irq_to_gpio_onboard(irq);
 	const int port = gpio >> 3;
 	const int port_mask = 1 << (gpio & 7);
 
@@ -231,8 +231,8 @@ void __init ep93xx_gpio_init_irq(void)
 {
 	int gpio_irq;
 
-	for (gpio_irq = gpio_to_irq(0);
-	     gpio_irq <= gpio_to_irq(EP93XX_GPIO_LINE_MAX_IRQ); ++gpio_irq) {
+	for (gpio_irq = gpio_to_irq_onboard(0);
+	     gpio_irq <= gpio_to_irq_onboard(EP93XX_GPIO_LINE_MAX_IRQ); ++gpio_irq) {
 		set_irq_chip(gpio_irq, &ep93xx_gpio_irq_chip);
 		set_irq_handler(gpio_irq, handle_level_irq);
 		set_irq_flags(gpio_irq, IRQF_VALID);
@@ -335,6 +335,11 @@ static void ep93xx_gpio_set(struct gpio_chip *chip, unsigned offset, int val)
 	local_irq_restore(flags);
 }
 
+static int ep93xx_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	return gpio_to_irq_onboard(offset);
+}
+
 static void ep93xx_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 {
 	struct ep93xx_gpio_chip *ep93xx_chip = to_ep93xx_gpio_chip(chip);
@@ -355,7 +360,7 @@ static void ep93xx_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 				(data_reg & (1 << i)) ? "hi" : "lo");
 
 		if (!is_out) {
-			int irq = gpio_to_irq(gpio);
+			int irq = gpio_to_irq_onboard(gpio);
 			struct irq_desc *desc = irq_desc + irq;
 
 			if (irq >= 0 && desc->action) {
@@ -405,6 +410,7 @@ static void ep93xx_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
 			.get		  = ep93xx_gpio_get,		\
 			.set		  = ep93xx_gpio_set,		\
 			.dbg_show	  = ep93xx_gpio_dbg_show,	\
+			.to_irq		  = ep93xx_gpio_to_irq,		\
 			.base		  = base_gpio,			\
 			.ngpio		  = 8,				\
 		},							\
diff --git a/arch/arm/mach-ep93xx/include/mach/gpio.h b/arch/arm/mach-ep93xx/include/mach/gpio.h
index c991b14..c208527 100644
--- a/arch/arm/mach-ep93xx/include/mach/gpio.h
+++ b/arch/arm/mach-ep93xx/include/mach/gpio.h
@@ -108,15 +108,16 @@ extern void ep93xx_gpio_int_debounce(unsigned int irq, int enable);
 #define gpio_get_value	__gpio_get_value
 #define gpio_set_value	__gpio_set_value
 #define gpio_cansleep	__gpio_cansleep
+#define gpio_to_irq	__gpio_to_irq
 
 /*
  * Map GPIO A0..A7  (0..7)  to irq 64..71,
  *          B0..B7  (7..15) to irq 72..79, and
  *          F0..F7 (16..24) to irq 80..87.
  */
-#define gpio_to_irq(gpio)	\
+#define gpio_to_irq_onboard(gpio)	\
 	(((gpio) <= EP93XX_GPIO_LINE_MAX_IRQ) ? (64 + (gpio)) : -EINVAL)
 
-#define irq_to_gpio(irq)	((irq) - gpio_to_irq(0))
+#define irq_to_gpio_onboard(irq)	((irq) - gpio_to_irq(0))
 
 #endif
diff --git a/arch/arm/mach-ep93xx/ts72xx.c b/arch/arm/mach-ep93xx/ts72xx.c
index bf3a666..fd0efe7 100644
--- a/arch/arm/mach-ep93xx/ts72xx.c
+++ b/arch/arm/mach-ep93xx/ts72xx.c
@@ -273,6 +273,26 @@ static void __init ts72xx_register_sdcard(void)
 }
 
 /*************************************************************************
+ * TS-DIO24 (PC/104 extension board)
+ *************************************************************************/
+
+/* I/O address is selected with JP1 & JP2. Can be 0x100, 0x108, 0x110 or 0x118. */
+#define TS_DIO24_ADDRESS	0x100
+
+static struct resource ts72xx_dio24_resource = {
+	.start		= TS72XX_PC104_8BIT_IO_PHYS_BASE + TS_DIO24_ADDRESS,
+	.end		= TS72XX_PC104_8BIT_IO_PHYS_BASE + TS_DIO24_ADDRESS + 0x20,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device ts72xx_dio24 = {
+	.name		= "ts72xx-dio24",
+	.id		= 100,
+	.num_resources	= 1,
+	.resource	= &ts72xx_dio24_resource,
+};
+
+/*************************************************************************
  * RTC
  *************************************************************************/
 static unsigned char ts72xx_rtc_readbyte(unsigned long addr)
@@ -430,6 +450,7 @@ static void __init ts72xx_init_machine(void)
 	ts72xx_register_sdcard();
 	platform_device_register(&ts72xx_rtc_device);
 	platform_device_register(&ts72xx_wdt_device);
+	platform_device_register(&ts72xx_dio24);
 
 	ep93xx_register_eth(&ts72xx_eth_data, 1);
 	ep93xx_register_i2c(&ts72xx_i2c_gpio_data,
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index fee678f..19ad2d7 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -111,6 +111,14 @@ config GPIO_SCH
 	  This driver can also be built as a module. If so, the module
 	  will be called sch-gpio.
 
+config GPIO_TS_DIO24
+	bool "TS-DIO24 GPIO support"
+	depends on GPIOLIB && MACH_TS72XX
+	help
+	  Say Y here if you have a TS-DIO24 PC/104 peripheral.
+	  
+	  Board setup code must specify peripheral I/O address (JP1 and JP2).
+
 comment "I2C GPIO expanders:"
 
 config GPIO_MAX7300
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 10f3f8d..ccb766b 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -27,4 +27,5 @@ obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_WM831X)	+= wm831x-gpio.o
 obj-$(CONFIG_GPIO_WM8350)	+= wm8350-gpiolib.o
 obj-$(CONFIG_GPIO_WM8994)	+= wm8994-gpio.o
-obj-$(CONFIG_GPIO_SCH)		+= sch_gpio.o
\ No newline at end of file
+obj-$(CONFIG_GPIO_SCH)		+= sch_gpio.o
+obj-$(CONFIG_GPIO_TS_DIO24)	+= ts-dio24.o
diff --git a/drivers/gpio/ts-dio24.c b/drivers/gpio/ts-dio24.c
new file mode 100644
index 0000000..ca5cd4f
--- /dev/null
+++ b/drivers/gpio/ts-dio24.c
@@ -0,0 +1,440 @@
+/*
+ * Technologic Systems TS-DIO24 supprt.
+ *
+ * Copyright (C) 2010 Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Watch out: all gpio of a same port have the same direction.
+ * gpiolib index (add "chip.base" number):
+ *	00: A0 (pin 47)		08: B0 (pin 31)		16: C0 (pin 15)
+ *	01: A1 (pin 45)		09: B1 (pin 29)		17: C1 (pin 13)
+ *	02: A2 (pin 43)		10: B2 (pin 27)		18: C2 (pin 11)
+ *	03: A3 (pin 41)		11: B3 (pin 25)		19: C3 (pin 9)
+ *	04: A4 (pin 39)		12: B4 (pin 23)		20: C4 (pin 7)
+ *	05: A5 (pin 37)		13: B5 (pin 21)		21: C5 (pin 5)
+ *	06: A6 (pin 35)		14: B6 (pin 19)		22: C6 (pin 3)
+ *	07: A7 (pin 33)		15: B7 (pin 17)		23: C7 (pin 1)
+ *      ---------------         ---------------         ---------------
+ *        output only          TTL in / 24ma out       TTL in / 24ma out
+ *       A0-A3: 48ma out                                irq for C0-C3
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include <mach/hardware.h>
+
+struct ts_dio24 {
+	struct gpio_chip	chip;
+	struct irq_chip		irq_chip;
+	void __iomem		*reg_base;
+	spinlock_t		lock;
+	spinlock_t		irq_lock;
+};
+
+/* Board identifier: first byte must be 'T' */
+#define is_tsdio24_present(__iomem, __offset) \
+	(__raw_readb(__iomem + __offset) == 0x54)
+
+#define TS_DIO24_GPIO_NR	24
+
+/* Registers offset */
+#define GPIO_INT	3
+#define GPIO_DIR	4
+#define GPIO_DATA	5
+
+/* Interrupt translation */
+#define GPIO_INDEX_C1	17
+#define GPIO_INDEX_C2	18
+#define GPIO_IRQ_C1	88 /* see mach/irqs.h */
+#define GPIO_IRQ_C2	89
+
+
+static inline struct ts_dio24 *to_ts_dio24(struct gpio_chip *chip)
+{
+	return container_of(chip, struct ts_dio24, chip);
+}
+
+static int ts_dio24_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct ts_dio24 *dio = to_ts_dio24(chip);
+	unsigned long flags;
+	u8 reg;
+
+	/* Port A is output only */
+	if (offset < 8)
+		return -EINVAL;
+
+	spin_lock_irqsave(&dio->lock, flags);
+	reg = __raw_readb(dio->reg_base + GPIO_DIR);
+	if (offset >= 16) /* Port C */
+		reg &= ~BIT(0);
+	else /* Port B */
+		reg &= ~BIT(1);
+	__raw_writeb(reg, dio->reg_base + GPIO_DIR);
+	spin_unlock_irqrestore(&dio->lock, flags);
+	return 0;
+}
+
+static int ts_dio24_gpio_direction_output(struct gpio_chip *chip,
+		unsigned offset, int val)
+{
+	struct ts_dio24 *dio = to_ts_dio24(chip);
+	unsigned port; /* 0, 1 or 2 */
+	unsigned long flags;
+	u8 reg;
+
+	spin_lock_irqsave(&dio->lock, flags);
+
+	if (offset >= 8) {
+		reg = __raw_readb(dio->reg_base + GPIO_DIR);
+		if (offset >= 16) /* Port C */
+			reg |= BIT(0);
+		else /* Port B */
+			reg |= BIT(1);
+		__raw_writeb(reg, dio->reg_base + GPIO_DIR);
+	}
+
+	port = offset / 8;
+	reg = __raw_readb(dio->reg_base + GPIO_DATA + port);
+	if (val)
+		reg |= BIT(offset % 8);
+	else
+		reg &= ~BIT(offset % 8);
+	__raw_writeb(reg, dio->reg_base + GPIO_DATA + port);
+
+	spin_unlock_irqrestore(&dio->lock, flags);
+
+	return 0;
+}
+
+static int ts_dio24_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct ts_dio24 *dio = to_ts_dio24(chip);
+	unsigned port; /* 0, 1 or 2 */
+	u8 reg;
+
+	port = offset / 8;
+	reg = __raw_readb(dio->reg_base + GPIO_DATA + port);
+
+	return !!(reg & (1 << (offset % 8)));
+}
+
+static void ts_dio24_gpio_set(struct gpio_chip *chip, unsigned offset, int val)
+{
+	struct ts_dio24 *dio = to_ts_dio24(chip);
+	unsigned port; /* 0, 1 or 2 */
+	unsigned long flags;
+	u8 reg;
+
+	port = offset / 8;
+	spin_lock_irqsave(&dio->lock, flags);
+	reg = __raw_readb(dio->reg_base + GPIO_DATA + port);
+	if (val)
+		reg |= BIT(offset % 8);
+	else
+		reg &= ~BIT(offset % 8);
+	__raw_writeb(reg, dio->reg_base + GPIO_DATA + port);
+
+	spin_unlock_irqrestore(&dio->lock, flags);
+}
+
+#ifdef CONFIG_DEBUG_FS
+static void ts_dio24_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+{
+	struct ts_dio24 *dio = to_ts_dio24(chip);
+	u8  data_reg, data_dir_reg;
+	int gpio, is_out, i;
+
+	data_dir_reg = __raw_readb(dio->reg_base + GPIO_DIR);
+	gpio = dio->chip.base;
+
+	data_reg = __raw_readb(dio->reg_base + GPIO_DATA + 0);
+	is_out = 1;
+	for (i = 0; i < 8; i++, gpio++) {
+		seq_printf(s, " %s%d gpio-%-3d (%-12s) %s %s\n",
+				"A", i, gpio,
+				gpiochip_is_requested(chip, i) ? : "",
+				is_out ? "out" : "in ",
+				(data_reg & (1 << i)) ? "hi" : "lo");
+	}
+
+	data_reg = __raw_readb(dio->reg_base + GPIO_DATA + 1);
+	is_out = data_dir_reg & 2;
+	for (i = 0; i < 8; i++, gpio++) {
+		seq_printf(s, " %s%d gpio-%-3d (%-12s) %s %s\n",
+				"B", i, gpio,
+				gpiochip_is_requested(chip, i) ? : "",
+				is_out ? "out" : "in ",
+				(data_reg & (1 << i)) ? "hi" : "lo");
+	}
+
+	data_reg = __raw_readb(dio->reg_base + GPIO_DATA + 2);
+	is_out = data_dir_reg & 1;
+	for (i = 0; i < 8; i++, gpio++) {
+		seq_printf(s, " %s%d gpio-%-3d (%-12s) %s %s",
+				"C", i, gpio,
+				gpiochip_is_requested(chip, i) ? : "",
+				is_out ? "out" : "in ",
+				(data_reg & (1 << i)) ? "hi" : "lo");
+		seq_printf(s, "\n");
+	}
+}
+#else
+#define ts_dio24_gpio_dbg_show NULL
+#endif
+
+/*
+ * GPIO IRQ
+ */
+static inline unsigned ts_dio24_irq_to_gpio(unsigned irq)
+{
+	if (irq == GPIO_IRQ_C1)
+		return GPIO_INDEX_C1;
+	else if (irq == GPIO_IRQ_C2)
+		return GPIO_INDEX_C2;
+	return -EINVAL;
+}
+
+static int ts_dio24_gpio_to_irq(struct gpio_chip *chip, unsigned offset)
+{
+	if (offset == GPIO_INDEX_C1)
+		return GPIO_IRQ_C1;
+	else if (offset == GPIO_INDEX_C2)
+		return GPIO_IRQ_C2;
+	return -EINVAL;
+}
+
+static void ts_dio24_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	// hw irq => sw irq
+	if (irq  == IRQ_EP93XX_EXT1)
+		generic_handle_irq(GPIO_IRQ_C1);
+	else if (irq  == IRQ_EP93XX_EXT3)
+		generic_handle_irq(GPIO_IRQ_C2);
+}
+
+static int ts_dio24_irq_type(unsigned irq, unsigned type)
+{
+	struct ts_dio24 *dio = get_irq_chip_data(irq);
+	unsigned long flags;
+	unsigned offset = ts_dio24_irq_to_gpio(irq);
+	u8 reg;
+
+	pr_debug("ts_dio24_irq_type: irq=%d type=%d offset=%d\n", irq, type, offset);
+
+	if (offset < 0 || offset >= TS_DIO24_GPIO_NR)
+		return -EINVAL;
+
+	gpio_direction_input(offset + dio->chip.base);
+
+	switch (type) {
+		case IRQ_TYPE_EDGE_RISING:
+		case IRQ_TYPE_LEVEL_HIGH:
+			spin_lock_irqsave(&dio->irq_lock, flags);
+			reg = __raw_readb(dio->reg_base + GPIO_INT);
+			if (irq == GPIO_IRQ_C1)
+				reg &= ~BIT(5);
+			else if (irq == GPIO_IRQ_C2)
+				reg &= ~BIT(6);
+			__raw_writeb(reg, dio->reg_base + GPIO_INT);
+			spin_unlock_irqrestore(&dio->irq_lock, flags);
+			break;
+
+		case IRQ_TYPE_EDGE_FALLING:
+		case IRQ_TYPE_LEVEL_LOW:
+			spin_lock_irqsave(&dio->irq_lock, flags);
+			reg = __raw_readb(dio->reg_base + GPIO_INT);
+			if (irq == GPIO_IRQ_C1)
+				reg |= BIT(5);
+			else if (irq == GPIO_IRQ_C2)
+				reg |= BIT(6);
+			__raw_writeb(reg, dio->reg_base + GPIO_INT);
+			spin_unlock_irqrestore(&dio->irq_lock, flags);
+			break;
+
+		default:
+			pr_err("failed to set irq type %d for gpio %d\n", type,
+					offset + dio->chip.base);
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void ts_dio24_irq_disable(unsigned irq)
+{
+	struct ts_dio24 *dio = get_irq_chip_data(irq);
+	unsigned long flags;
+	u8 reg;
+
+	spin_lock_irqsave(&dio->irq_lock, flags);
+	reg = __raw_readb(dio->reg_base + GPIO_INT);
+	if (irq == GPIO_IRQ_C1)
+		reg &= ~BIT(1);
+	else if (irq == GPIO_IRQ_C2)
+		reg &= ~BIT(2);
+	__raw_writeb(reg, dio->reg_base + GPIO_INT);
+	spin_unlock_irqrestore(&dio->irq_lock, flags);
+};
+
+static void ts_dio24_irq_enable(unsigned irq)
+{
+	struct ts_dio24 *dio = get_irq_chip_data(irq);
+	unsigned long flags;
+	u8 reg;
+
+	spin_lock_irqsave(&dio->irq_lock, flags);
+	reg = __raw_readb(dio->reg_base + GPIO_INT);
+	if (irq == GPIO_IRQ_C1)
+		reg |= BIT(1);
+	else if (irq == GPIO_IRQ_C2)
+		reg |= BIT(2);
+	__raw_writeb(reg, dio->reg_base + GPIO_INT);
+	spin_unlock_irqrestore(&dio->irq_lock, flags);
+};
+
+static int __init ts_dio24_probe(struct platform_device *pdev)
+{
+	struct resource *per = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	struct ts_dio24 *dio;
+	int err;
+
+	if (!per) {
+		dev_err(&pdev->dev, "missing resource(s)\n");
+		err = -EINVAL;
+		goto fail_probe;
+	}
+
+	dio = kzalloc(sizeof(struct ts_dio24), GFP_KERNEL);
+	if (!dio) {
+		err = -ENOMEM;
+		goto fail_probe;
+	}
+
+	dio->reg_base = ioremap(per->start, per->end - per->start + 1);
+	if (!dio->reg_base) {
+		err = -ENXIO;
+		goto fail_no_ioremap;
+	}
+
+	if (!is_tsdio24_present(dio->reg_base, 0)) {
+		dev_err(&pdev->dev, "not detected\n");
+		err = -ENXIO;
+		goto fail_not_present;
+	}
+
+	dio->chip.owner = THIS_MODULE;
+	dio->chip.label = dev_name(&pdev->dev);
+	dio->chip.direction_input = ts_dio24_gpio_direction_input;
+	dio->chip.direction_output = ts_dio24_gpio_direction_output;
+	dio->chip.get = ts_dio24_gpio_get;
+	dio->chip.set = ts_dio24_gpio_set;
+	dio->chip.to_irq = ts_dio24_gpio_to_irq;
+	dio->chip.dbg_show = ts_dio24_gpio_dbg_show;
+	dio->chip.base = pdev->id; /* take platform device id as starting index */
+	dio->chip.ngpio = TS_DIO24_GPIO_NR;
+
+	err = gpiochip_add(&dio->chip);
+	if (err) {
+		dev_err(&pdev->dev, "gpiochip_add error\n");
+		goto fail_not_present;
+	}
+
+	dio->irq_chip.name = dev_name(&pdev->dev);
+	dio->irq_chip.enable = ts_dio24_irq_enable;
+	dio->irq_chip.disable = ts_dio24_irq_disable;
+	dio->irq_chip.set_type = ts_dio24_irq_type;
+
+	/* C0 irq */
+	// C0 is linked to IRQ 5 which is a gpio EP93XX_GPIO_LINE_F(3), drop
+	/* C1 irq */
+	set_irq_chip(GPIO_IRQ_C1, &dio->irq_chip);
+	set_irq_handler(GPIO_IRQ_C1, handle_simple_irq);
+	set_irq_flags(GPIO_IRQ_C1, IRQF_VALID | IRQF_PROBE);
+	set_irq_chip_data(GPIO_IRQ_C1, dio);
+	/* C2 irq */
+	set_irq_chip(GPIO_IRQ_C2, &dio->irq_chip);
+	set_irq_handler(GPIO_IRQ_C2, handle_simple_irq);
+	set_irq_flags(GPIO_IRQ_C2, IRQF_VALID | IRQF_PROBE);
+	set_irq_chip_data(GPIO_IRQ_C2, dio);
+	/* C3 irq */
+	// C3 is linked to IRQ 9 and is not available on TS-72XX arm sbc
+
+	set_irq_chained_handler(IRQ_EP93XX_EXT1, ts_dio24_irq_handler); /* IRQ6 pin */
+	set_irq_chained_handler(IRQ_EP93XX_EXT3, ts_dio24_irq_handler); /* IRQ7 pin */
+
+	spin_lock_init(&dio->lock);
+	spin_lock_init(&dio->irq_lock);
+	platform_set_drvdata(pdev, dio);
+	return 0;
+
+fail_not_present:
+	iounmap(dio->reg_base);
+fail_no_ioremap:
+	kfree(dio);
+fail_probe:
+	return err;
+}
+
+static int __devexit ts_dio24_remove(struct platform_device *pdev)
+{
+	struct ts_dio24 *dio = platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	set_irq_chip(GPIO_IRQ_C1, NULL);
+	set_irq_chip_data(GPIO_IRQ_C1, NULL);
+	set_irq_chip(GPIO_IRQ_C2, NULL);
+	set_irq_chip_data(GPIO_IRQ_C2, NULL);
+	set_irq_chained_handler(IRQ_EP93XX_EXT1, NULL);
+	set_irq_chained_handler(IRQ_EP93XX_EXT3, NULL);
+
+	gpiochip_remove(&dio->chip);
+	iounmap(dio->reg_base);
+	kfree(dio);
+	return 0;
+}
+
+static struct platform_driver ts_dio24_driver = {
+	.driver		= {
+		.name	= "ts72xx-dio24",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ts_dio24_probe,
+	.remove		= __devexit_p(ts_dio24_remove),
+};
+
+static int __init ts_dio24_init(void)
+{
+	return platform_driver_register(&ts_dio24_driver);
+}
+
+static void __exit ts_dio24_exit(void)
+{
+	platform_driver_unregister(&ts_dio24_driver);
+}
+
+module_init(ts_dio24_init);
+module_exit(ts_dio24_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("TS-DIO24 driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ts72xx-dio24");
-- 
1.7.2.3

