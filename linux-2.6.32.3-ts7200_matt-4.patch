 arch/arm/Kconfig                                  |   13 +
 arch/arm/include/asm/ioctls.h                     |    3 +
 arch/arm/include/asm/memory.h                     |    2 +
 arch/arm/kernel/head.S                            |    3 +
 arch/arm/kernel/setup.c                           |    9 +
 arch/arm/mach-ep93xx/Kconfig                      |   23 +
 arch/arm/mach-ep93xx/Makefile                     |    8 +-
 arch/arm/mach-ep93xx/clock.c                      |    4 +
 arch/arm/mach-ep93xx/core.c                       |   30 +
 arch/arm/mach-ep93xx/cpufreq.c                    |  291 +++
 arch/arm/mach-ep93xx/dma-m2m.c                    |  774 +++++++
 arch/arm/mach-ep93xx/include/mach/dma.h           |   65 +
 arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h   |   12 +
 arch/arm/mach-ep93xx/include/mach/memory.h        |   28 +
 arch/arm/mach-ep93xx/include/mach/spi.h           |   18 +
 arch/arm/mach-ep93xx/include/mach/ts72xx-keypad.h |   30 +
 arch/arm/mach-ep93xx/include/mach/ts72xx.h        |  137 ++-
 arch/arm/mach-ep93xx/pm.c                         |   78 +
 arch/arm/mach-ep93xx/ts72xx.c                     |  131 ++-
 arch/arm/mach-ep93xx/ts72xx_sbcinfo.c             |  200 ++
 arch/arm/mm/proc-arm920.S                         |    5 +-
 drivers/ata/Kconfig                               |   20 +
 drivers/ata/Makefile                              |    3 +
 drivers/ata/pata_ts7200_cf.c                      |   85 +
 drivers/ata/pata_ts72xx.c                         |  155 ++
 drivers/ata/pata_ts9600.c                         |   88 +
 drivers/block/Kconfig                             |    7 +
 drivers/block/Makefile                            |    2 +
 drivers/block/sdcore2.c                           | 2391 +++++++++++++++++++++
 drivers/block/tssdcard.c                          |  414 ++++
 drivers/block/tssdcore.h                          |  372 ++++
 drivers/ide/Kconfig                               |    7 +
 drivers/ide/Makefile                              |    1 +
 drivers/ide/ide_ts7200_cf.c                       |   64 +
 drivers/input/keyboard/Kconfig                    |   42 +
 drivers/input/keyboard/Makefile                   |    4 +
 drivers/input/keyboard/ep93xx_keypad.c            |    1 +
 drivers/input/keyboard/ts72xx_dio_3x4.c           |   65 +
 drivers/input/keyboard/ts72xx_dio_4x4.c           |   65 +
 drivers/input/keyboard/ts72xx_keypad.c            |  342 +++
 drivers/mtd/maps/Kconfig                          |    8 +
 drivers/mtd/maps/Makefile                         |    1 +
 drivers/mtd/maps/ts7200_flash.c                   |  106 +
 drivers/net/Kconfig                               |   10 +
 drivers/net/Makefile                              |    1 +
 drivers/net/arm/Kconfig                           |    1 +
 drivers/net/arm/ep93xx_eth.c                      |  339 +++-
 drivers/net/ax88796.c                             |    4 +
 drivers/net/ax88796_ts_eth100.c                   |  185 ++
 drivers/serial/8250_ts_ser1.c                     |  150 ++
 drivers/serial/Kconfig                            |   25 +
 drivers/serial/Makefile                           |    1 +
 drivers/serial/amba-pl010.c                       |  137 ++-
 drivers/spi/Kconfig                               |   13 +
 drivers/spi/Makefile                              |    2 +
 drivers/spi/spi_ep93xx.c                          |  500 +++++
 drivers/spi/spi_ep93xx.h                          |   61 +
 drivers/spi/tmp124.c                              |  158 ++
 58 files changed, 7613 insertions(+), 81 deletions(-)

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 1c4119c..05eab87 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -288,11 +288,13 @@ config ARCH_EP93XX
 	select CPU_ARM920T
 	select ARM_AMBA
 	select ARM_VIC
+	select ARCH_SPARSEMEM_ENABLE
 	select GENERIC_GPIO
 	select HAVE_CLK
 	select COMMON_CLKDEV
 	select ARCH_REQUIRE_GPIOLIB
 	select ARCH_HAS_HOLES_MEMORYMODEL
+	select ARCH_HAS_CPUFREQ
 	help
 	  This enables support for the Cirrus EP93xx series of CPUs.
 
@@ -1349,6 +1351,17 @@ config CPU_FREQ_INTEGRATOR
 
 	  If in doubt, say Y.
 
+config CPU_FREQ_EP93XX
+	tristate "CPUfreq driver for EP93XX CPUs"
+	depends on ARCH_EP93XX && CPU_FREQ
+	default n
+	help
+	  This enables the CPUfreq driver for EP9301 CPUs. Not tested with EP9302.
+
+	  For details, take a look at <file:Documentation/cpu-freq>.
+
+	  If in doubt, say N.
+
 config CPU_FREQ_PXA
 	bool
 	depends on CPU_FREQ && ARCH_PXA && PXA25x
diff --git a/arch/arm/include/asm/ioctls.h b/arch/arm/include/asm/ioctls.h
index a91d8a1..a4b60ae 100644
--- a/arch/arm/include/asm/ioctls.h
+++ b/arch/arm/include/asm/ioctls.h
@@ -70,6 +70,9 @@
 #define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
 #define FIOQSIZE	0x545E
 
+#define TIOC_SBCC485	0x545F /* TS72xx RTS/485 mode clear */
+#define TIOC_SBCS485	0x5460 /* TS72xx RTS/485 mode set */
+
 /* Used for packet mode */
 #define TIOCPKT_DATA		 0
 #define TIOCPKT_FLUSHREAD	 1
diff --git a/arch/arm/include/asm/memory.h b/arch/arm/include/asm/memory.h
index cefedf0..bc2ff8b 100644
--- a/arch/arm/include/asm/memory.h
+++ b/arch/arm/include/asm/memory.h
@@ -125,8 +125,10 @@
  * private definitions which should NOT be used outside memory.h
  * files.  Use virt_to_phys/phys_to_virt/__pa/__va instead.
  */
+#ifndef __virt_to_phys
 #define __virt_to_phys(x)	((x) - PAGE_OFFSET + PHYS_OFFSET)
 #define __phys_to_virt(x)	((x) - PHYS_OFFSET + PAGE_OFFSET)
+#endif
 
 /*
  * Convert a physical address to a Page Frame Number and back
diff --git a/arch/arm/kernel/head.S b/arch/arm/kernel/head.S
index 38ccbe1..c2e4514 100644
--- a/arch/arm/kernel/head.S
+++ b/arch/arm/kernel/head.S
@@ -82,6 +82,9 @@ ENTRY(stext)
 	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid
 	movs	r10, r5				@ invalid processor (r5=0)?
 	beq	__error_p			@ yes, error 'p'
+#ifdef CONFIG_MACH_TS72XX_FORCE_MACHINEID
+	ldr r1, =0x2a1
+#endif
 	bl	__lookup_machine_type		@ r5=machinfo
 	movs	r8, r5				@ invalid machine (r5=0)?
 	beq	__error_a			@ yes, error 'a'
diff --git a/arch/arm/kernel/setup.c b/arch/arm/kernel/setup.c
index c6c57b6..29d5f4f 100644
--- a/arch/arm/kernel/setup.c
+++ b/arch/arm/kernel/setup.c
@@ -860,6 +860,15 @@ static int c_show(struct seq_file *m, void *v)
 	seq_puts(m, "\n");
 
 	seq_printf(m, "Hardware\t: %s\n", machine_name);
+
+	#if defined(CONFIG_ARCH_EP93XX)
+	#include <mach/io.h>
+	#include <mach/ep93xx-regs.h>
+	system_rev = *((unsigned int *)EP93XX_SYSCON_CHIPID) >> 28;
+	system_serial_low = *((unsigned int *)EP93XX_SECURITY_UNIQID);
+	system_serial_high = 0;
+	#endif
+
 	seq_printf(m, "Revision\t: %04x\n", system_rev);
 	seq_printf(m, "Serial\t\t: %08x%08x\n",
 		   system_serial_high, system_serial_low);
diff --git a/arch/arm/mach-ep93xx/Kconfig b/arch/arm/mach-ep93xx/Kconfig
index 9167c3d..34d2c3b 100644
--- a/arch/arm/mach-ep93xx/Kconfig
+++ b/arch/arm/mach-ep93xx/Kconfig
@@ -7,6 +7,15 @@ config CRUNCH
 	help
 	  Enable kernel support for MaverickCrunch.
 
+config CR1_NFBIT
+	bool "Turn on nF bit in ControlRegister 1"
+	help
+	  Say 'Y' here to force the nF bit on.  Usually this is set
+	  by the bootrom.  If it is not set, then the CPU core will
+	  run from HCLK instead of FCLK, and performance will suffer.
+	  If you see BogoMIPS of about 1/4 of your CPU clock, try
+	  turning this on; your performance should double.
+
 comment "EP93xx Platforms"
 
 choice
@@ -182,6 +191,20 @@ config EP93XX_EARLY_UART3
 
 endchoice
 
+config MACH_TS72XX_FORCE_MACHINEID
+	bool "Force Machine ID"
+	depends on MACH_TS72XX
+	help
+	  Say 'Y' here to force Machine ID to 0x2A1 (MACH_TYPE_TS72XX legacy value)
+	  In early days Technologic Systems fixed the 0x163 value in redboot.
+
+config MACH_TS72XX_SBCINFO
+	tristate "Add procfs /proc/driver/sbcinfo"
+	depends on MACH_TS72XX
+	help
+	  Say 'Y' to add a procfs entry containing some information
+	  related to Technologic Systems TS-72xx SBC.
+
 endmenu
 
 endif
diff --git a/arch/arm/mach-ep93xx/Makefile b/arch/arm/mach-ep93xx/Makefile
index eae6199..b142672 100644
--- a/arch/arm/mach-ep93xx/Makefile
+++ b/arch/arm/mach-ep93xx/Makefile
@@ -1,13 +1,19 @@
 #
 # Makefile for the linux kernel.
 #
-obj-y			:= core.o clock.o dma-m2p.o gpio.o
+obj-y			:= core.o clock.o dma-m2p.o dma-m2m.o gpio.o
 obj-m			:=
 obj-n			:=
 obj-			:=
 
+obj-$(CONFIG_CPU_FREQ_EP93XX)	+= cpufreq.o
+
 obj-$(CONFIG_MACH_ADSSPHERE)	+= adssphere.o
 obj-$(CONFIG_MACH_EDB93XX)	+= edb93xx.o
 obj-$(CONFIG_MACH_GESBC9312)	+= gesbc9312.o
 obj-$(CONFIG_MACH_MICRO9)	+= micro9.o
 obj-$(CONFIG_MACH_TS72XX)	+= ts72xx.o
+obj-$(CONFIG_MACH_TS72XX_SBCINFO)	+= ts72xx_sbcinfo.o
+
+# Power Management
+obj-$(CONFIG_PM) += pm.o
diff --git a/arch/arm/mach-ep93xx/clock.c b/arch/arm/mach-ep93xx/clock.c
index 1d0f9d8..d952910 100644
--- a/arch/arm/mach-ep93xx/clock.c
+++ b/arch/arm/mach-ep93xx/clock.c
@@ -98,6 +98,9 @@ static struct clk clk_pwm = {
 	.parent		= &clk_xtali,
 	.rate		= EP93XX_EXT_CLK_RATE,
 };
+static struct clk clk_ssp = {
+	.rate		= EP93XX_EXT_CLK_RATE / 2,
+};
 
 static struct clk clk_video = {
 	.sw_locked	= 1,
@@ -185,6 +188,7 @@ static struct clk_lookup clocks[] = {
 	INIT_CK("ep93xx-keypad",	NULL,		&clk_keypad),
 	INIT_CK("ep93xx-fb",		NULL,		&clk_video),
 	INIT_CK(NULL,			"pwm_clk",	&clk_pwm),
+	INIT_CK(NULL,			"sspclk",	&clk_ssp),
 	INIT_CK(NULL,			"m2p0",		&clk_m2p0),
 	INIT_CK(NULL,			"m2p1",		&clk_m2p1),
 	INIT_CK(NULL,			"m2p2",		&clk_m2p2),
diff --git a/arch/arm/mach-ep93xx/core.c b/arch/arm/mach-ep93xx/core.c
index b4357c3..e9abf81 100644
--- a/arch/arm/mach-ep93xx/core.c
+++ b/arch/arm/mach-ep93xx/core.c
@@ -31,6 +31,7 @@
 
 #include <mach/hardware.h>
 #include <mach/fb.h>
+#include <mach/spi.h>
 
 #include <asm/mach/map.h>
 #include <asm/mach/time.h>
@@ -611,6 +612,34 @@ static struct platform_device ep93xx_leds = {
 	},
 };
 
+/*************************************************************************
+ * EP93xx ssp peripheral handling
+ *************************************************************************/
+static struct resource ep93xx_ssp_resources[] = {
+       {
+               .start = EP93XX_SPI_PHYS_BASE,
+               .end   = EP93XX_SPI_PHYS_BASE + 0x14,
+               .flags = IORESOURCE_MEM,
+       }, {
+               .start = IRQ_EP93XX_SSP, // overrun in receive fifo
+               .end   = IRQ_EP93XX_SSP,
+               .flags = IORESOURCE_IRQ,
+       }
+};
+
+static struct ep93xx_spi_data ep93xx_ssp_data = {
+       .chip_select_num = 4,
+};
+
+static struct platform_device ep93xx_ssp_device = {
+       .name           = "ep93xx-spi",
+       .id             = 1,
+       .resource       = ep93xx_ssp_resources,
+       .num_resources  = ARRAY_SIZE(ep93xx_ssp_resources),
+       .dev = {
+               .platform_data = &ep93xx_ssp_data,
+       }
+};
 
 /*************************************************************************
  * EP93xx pwm peripheral handling
@@ -743,5 +772,6 @@ void __init ep93xx_init_devices(void)
 
 	platform_device_register(&ep93xx_rtc_device);
 	platform_device_register(&ep93xx_ohci_device);
+	platform_device_register(&ep93xx_ssp_device);
 	platform_device_register(&ep93xx_leds);
 }
diff --git a/arch/arm/mach-ep93xx/cpufreq.c b/arch/arm/mach-ep93xx/cpufreq.c
new file mode 100644
index 0000000..9188e5c
--- /dev/null
+++ b/arch/arm/mach-ep93xx/cpufreq.c
@@ -0,0 +1,291 @@
+/*
+ * cpufreq.c: clock scaling for Cirrus EP93XX embedded chip
+ *
+ * Copyright (C) 2008 Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * Based on "cpu-ep93xx.c" driver (for 2.4 kernel) by
+ * Bob Lees bob@diamond.demon.co.uk (Diamond Consulting Services Ltd)
+ * Ideas taken from "clock.c" by Lennert Buytenhek <buytenh@wantstofly.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Theory of operations
+ * ====================
+ *
+ * Clock scaling can be used to lower the power consumption of the CPU
+ * core. For this processor the major power saving is reducing the mem clk.
+ *
+ * The ep93xx has 2 registers to control the 2 PLLs of the ep93xx:
+ *   PLL1 controls the cpu, bus and peripheral clocks;
+ *   PLL2 controls the USB, MIR and ADC clocks.
+ *
+ *   ClkSet1 (EP93XX_SYSCON_CLOCK_SET1)  0x80930020  Clock speed control 1 (i.e. PLL1 config)
+ *   ClkSet2 (EP93XX_SYSCON_CLOCK_SET2)  0x80930024  Clock speed control 2 (i.e. PLL2 config)
+ *
+ * This driver only focus on PLL1. The pll has two multipliers/dividers:
+ * Fout = 14.7456 * (PLL1_X1FBD + 1) * (PLL1_X2FBD + 1) / ((PLL1_X2IPD + 1) * 2 ^ PLL1_PS)
+ *      = 14.7456 * (PLL1_X1FBD + 1) * (PLL1_X2FBD + 1) / (PLL1_X2IPD + 1) / 2 ^ PLL1_PS
+ *
+ * PLL1_X2 output (before the PS divide), must be > 290Mhz and <= 528Mhz
+ *
+ * fclk [processor    ] = pll1 / fclk_divisor
+ * hclk [AHB bus clock] = pll1 / hclk_divisor
+ * pclk [APB bus clock] = hclk / pclk_divisor
+ * fclk >= hclk > pclk
+ *
+ *                        EP9301   EP9302/07/12/15
+ * PLL1 fout max (MHz)     528           528
+ * fclk min (MHz)         12.9          12.9
+ * fclk max (MHz)          166           200
+ * hclk max (MHz)           66           100
+ * pclk max (MHz)           50            50
+ *
+ * Notes:
+ * - This driver does not use the clk_{get,put,roundrate} (clock.c) functions.
+ *   That's quite dirty, but clock.c is not complete yet.
+ * - Significant power saving is made by lowering hclk not fclk.
+ * - Ethernet (100 MBit) doesn't work with hclk < 25MHz.
+ * - Is it safe to have fclk = hclk ?
+ * - calc_pll_rate is taken from clock.c (Lennert Buytenhek)
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/cpufreq.h>
+#include <mach/hardware.h>
+
+
+/* ClkSet1 register */
+#define SYSCON_CLKSET1_PLL1_PS_SHIFT  16
+#define SYSCON_CLKSET1_PCLK_DIV_SHIFT 18
+#define SYSCON_CLKSET1_HCLK_DIV_SHIFT 20
+#define SYSCON_CLKSET1_FCLK_DIV_SHIFT 25
+
+#define CLKSET1(p, pl, pd, h, f)  ( p | \
+    ( pl << SYSCON_CLKSET1_PLL1_PS_SHIFT) | \
+    ( pd << SYSCON_CLKSET1_PCLK_DIV_SHIFT)| \
+    ( h << SYSCON_CLKSET1_HCLK_DIV_SHIFT) | \
+    ( f << SYSCON_CLKSET1_FCLK_DIV_SHIFT))
+
+/* SMC_ROM = 0, nBYP1 = 1 */
+#define PLL1_MASK(x1fbd1,x1fbd2,x2ipd) (0x800000 | (x1fbd1 << 11) | (x1fbd2 << 5) | (x2ipd))
+
+typedef struct {
+  int speed;    /* in kHz */
+  u32 preset;   /* x1fbd, x2fbd and x2ipd are left unchanged */
+  u32 pll1_ps;  /* sets final divide from pll */
+  u32 pdiv;     /* sets pclk, peripheral clk (division of hclk) */
+  u32 hdiv;     /* sets hclk, bus (memory) clk */
+  u32 fdiv;     /* sets fclk, processor clk */
+} ep93xx_speed_settings_t;
+
+static const char fclk_divisors[] = { 1, 2, 4, 8, 16, 1, 1, 1 };
+
+
+/* Suitable for EP9301. PLL1 rate (without final PS divider):
+   - PLL1_RATE(19,17,15) = 331.776 MHz
+   - PLL1_MASK(19, 7, 7) = 294.912 MHz
+ */
+static const ep93xx_speed_settings_t ep93xx_clkset1_settings[] =
+{
+  /* { speed, preset, pll1_ps, pdiv, hdiv, fdiv } */
+  { 165888, PLL1_MASK(19,17,15), 0, 1, 3, 1 }, /* [0x02B49A2F] fclk=165.9 (fdiv=2), hclk=66.4 (hdiv=5), pclk=33.2 (pdiv=2), ps=1 */
+  { 165887, PLL1_MASK(19,17,15), 1, 1, 3, 0 }, /* [0x00B59A2F] fclk=165.9 (fdiv=1), hclk=33.2 (hdiv=5), pclk=16.6 (pdiv=2), ps=2 */
+  { 147456, PLL1_MASK(19, 7, 7), 0, 1, 3, 1 }, /* [0x02B498E7] fclk=147.5 (fdiv=2), hclk=59.0 (hdiv=5), pclk=29.5 (pdiv=2), ps=1 */
+  { 147455, PLL1_MASK(19, 7, 7), 0, 2, 3, 1 }, /* [0x02B898E7] fclk=147.5 (fdiv=2), hclk=59.0 (hdiv=5), pclk=14.7 (pdiv=4), ps=1 */
+  {  73728, PLL1_MASK(19, 7, 7), 0, 1, 3, 2 }, /* [0x04B498E7] fclk=73.7 (fdiv=4), hclk=59.0 (hdiv=5), pclk=29.5 (pdiv=2), ps=1 */
+  {  82944, PLL1_MASK(19,17,15), 0, 1, 3, 2 }, /* [0x04B49A2F] fclk=82.9 (fdiv=4), hclk=66.4 (hdiv=5), pclk=33.2 (pdiv=2), ps=1 */
+  {  82943, PLL1_MASK(19,17,15), 0, 1, 4, 2 }, /* [0x04C49A2F] fclk=82.9 (fdiv=4), hclk=55.3 (hdiv=6), pclk=27.6 (pdiv=2), ps=1 */
+  {  82942, PLL1_MASK(19,17,15), 1, 1, 2, 1 }, /* [0x02A59A2F] fclk=82.9 (fdiv=2), hclk=41.5 (hdiv=4), pclk=20.7 (pdiv=2), ps=2 */
+  {  41472, PLL1_MASK(19,17,15), 0, 1, 5, 3 }, /* [0x06D49A2F] fclk=41.5 (fdiv=8), hclk=41.5 (hdiv=8), pclk=20.7 (pdiv=2), ps=1 */
+};
+
+#if 0
+/* Suitable for EP9302/07/12/15. Assumed: PLL1 = 400.1 MHz (X1FBD1=23, X1FBD2=25, X2IPD=22) */
+static ep93xx_speed_settings_t ep93xx_clkset1_settings[] =
+{
+  /* { speed, preset, pll1_ps, pdiv, hdiv, fdiv } */
+  { 200027, 0x0080bb36, 0, 1, 2, 1 }, /* [0x02A4BB36] fclk=200.0 (fdiv=2), hclk=100.0 (hdiv=4), pclk=50.0 (pdiv=2), ps=1 */
+  { 200026, 0x0080bb36, 0, 1, 3, 1 }, /* [0x02B4BB36] fclk=200.0 (fdiv=2), hclk=80.0 (hdiv=5), pclk=40.0 (pdiv=2), ps=1 */
+  { 200025, 0x0080bb36, 0, 1, 4, 1 }, /* [0x02C4BB36] fclk=200.0 (fdiv=2), hclk=66.7 (hdiv=6), pclk=33.3 (pdiv=2), ps=1 */
+  { 100013, 0x0080bb36, 0, 1, 3, 2 }, /* [0x04B4BB36] fclk=100.0 (fdiv=4), hclk=80.0 (hdiv=5), pclk=40.0 (pdiv=2), ps=1 */
+  { 100012, 0x0080bb36, 1, 1, 2, 1 }, /* [0x02A5BB36] fclk=100.0 (fdiv=2), hclk=50.0 (hdiv=4), pclk=25.0 (pdiv=2), ps=2 */
+  { 100011, 0x0080bb36, 1, 1, 1, 1 }, /* [0x0295BB36] fclk=100.0 (fdiv=2), hclk=100.0 (hdiv=2), pclk=50.0 (pdiv=2), ps=2 */
+  {  50006, 0x0080bb36, 2, 1, 2, 1 }, /* [0x02A6BB36] fclk=50.0 (fdiv=2), hclk=25.0 (hdiv=4), pclk=12.5 (pdiv=2), ps=4 */
+  {  50005, 0x0080bb36, 2, 1, 1, 1 }, /* [0x0296BB36] fclk=50.0 (fdiv=2), hclk=50.0 (hdiv=2), pclk=25.0 (pdiv=2), ps=4 */
+  {  25003, 0x0080bb36, 3, 1, 1, 1 }, /* [0x0297BB36] fclk=25.0 (fdiv=2), hclk=25.0 (hdiv=2), pclk=12.5 (pdiv=2), ps=8 */
+};
+#endif
+
+
+static unsigned long calc_pll_rate(u32 config_word)
+{
+  unsigned long long rate;
+
+  rate = 14745600;
+  rate *= ((config_word >> 11) & 0x1f) + 1;  /* X1FBD (5 bits) */
+  rate *= ((config_word >> 5) & 0x3f) + 1;   /* X2FBD (6 bits) */
+  do_div(rate, (config_word & 0x1f) + 1);    /* X2IPD (5 bits) */
+  rate = rate >> ((config_word >> 16) & 3);  /* PS    (2 bits) */
+
+  return (unsigned long)rate;
+}
+
+
+static const ep93xx_speed_settings_t *ep93xx_find_clkset1(unsigned int khz, unsigned int relation)
+{
+  int i;
+  const ep93xx_speed_settings_t *p = &ep93xx_clkset1_settings[0];
+
+  switch (relation) {
+    case CPUFREQ_RELATION_L: /* lowest frequency at or above target */
+      for (i = 0; i < ARRAY_SIZE(ep93xx_clkset1_settings); i++) {
+        if (ep93xx_clkset1_settings[i].speed < khz)
+          continue;
+        if (p->speed > ep93xx_clkset1_settings[i].speed) // take lowest value
+          p = &ep93xx_clkset1_settings[i];
+      }
+      break;
+
+    case CPUFREQ_RELATION_H: /* highest frequency below or at target */
+      for (i = 0; i < ARRAY_SIZE(ep93xx_clkset1_settings); i++) {
+        if (ep93xx_clkset1_settings[i].speed > khz)
+          continue;
+        if (p->speed < ep93xx_clkset1_settings[i].speed) // take highest value
+          p = &ep93xx_clkset1_settings[i];
+      }
+      break;
+  }
+
+  return p;
+}
+
+
+static int ep93xx_verify_speed(struct cpufreq_policy *policy)
+{
+  if (policy->cpu != 0)
+    return -EINVAL;
+
+  cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq, policy->cpuinfo.max_freq);
+
+  return 0;
+}
+
+
+static unsigned int ep93xx_get_speed(unsigned int cpu)
+{
+  unsigned int freq;
+  u32 value;
+
+  if (cpu)
+    return 0;
+
+  value = __raw_readl(EP93XX_SYSCON_CLOCK_SET1);
+  if (!(value & 0x00800000)) { /* PLL1 bypassed? */
+    freq = 14745600;
+  } else {
+    freq = calc_pll_rate(value);
+  }
+  freq /= fclk_divisors[(value >> 25) & 0x7];
+
+  freq = (freq + 500) / 1000; /* rounded result in kHz */
+  return freq;
+}
+
+
+static int ep93xx_set_target(struct cpufreq_policy *policy,
+    unsigned int target_freq,
+    unsigned int relation)
+{
+  struct cpufreq_freqs freqs;
+  const ep93xx_speed_settings_t *config;
+  u32 value;
+
+  config =  ep93xx_find_clkset1(target_freq, relation);
+
+  freqs.old = ep93xx_get_speed(0);
+  freqs.new = config->speed;
+  freqs.cpu = 0;
+  freqs.flags = 0;
+
+  pr_debug("ep93xx: target_freq=%d, old=%d new=%d (kHz) rel=%d\n", target_freq, freqs.old, freqs.new, relation);
+
+  cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+  value = CLKSET1(config->preset, config->pll1_ps,
+      config->pdiv, config->hdiv, config->fdiv);
+  __raw_writel(value, EP93XX_SYSCON_CLOCK_SET1);
+
+  /* 5 nops required to flush instruction pipeline */
+  __asm__ __volatile__("nop; nop; nop; nop; nop");
+
+  cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+  return 0;
+}
+
+
+static int __init ep93xx_cpufreq_driver_init(struct cpufreq_policy *policy)
+{
+  printk(KERN_INFO "ep93xx-cpufreq: driver v1.01\n");
+
+  if (policy->cpu != 0)
+    return -EINVAL;
+
+  policy->cur = ep93xx_get_speed(0);
+  policy->min = 25000;
+
+  policy->cpuinfo.min_freq = 13000;
+
+  /* All EP93xx are running up to 200Mhz, except EP9301 */
+  if (policy->cur <= 166000)
+    policy->cpuinfo.max_freq = 166000;
+  else
+    policy->cpuinfo.max_freq = 200000;
+
+  policy->cpuinfo.transition_latency = 1600000; /* 8..16ms (according to datasheet) */
+  policy->max = policy->cpuinfo.max_freq;
+
+  return 0;
+}
+
+static struct cpufreq_driver ep93xx_driver = {
+  .flags  = CPUFREQ_STICKY,
+  .verify = ep93xx_verify_speed,
+  .target = ep93xx_set_target,
+  .get    = ep93xx_get_speed,
+  .init   = ep93xx_cpufreq_driver_init,
+  .name   = "ep93xx",
+};
+
+
+static int __init ep93xx_cpufreq_init(void)
+{
+  return cpufreq_register_driver(&ep93xx_driver);
+}
+module_init(ep93xx_cpufreq_init);
+
+static void __exit ep93xx_cpufreq_exit(void)
+{
+ cpufreq_unregister_driver(&ep93xx_driver);
+}
+module_exit(ep93xx_cpufreq_exit);
+
+MODULE_DESCRIPTION("CPU frequency scaling driver for EP93xx");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.01");
diff --git a/arch/arm/mach-ep93xx/dma-m2m.c b/arch/arm/mach-ep93xx/dma-m2m.c
new file mode 100644
index 0000000..33445c3
--- /dev/null
+++ b/arch/arm/mach-ep93xx/dma-m2m.c
@@ -0,0 +1,774 @@
+/*
+ * arch/arm/mach-ep93xx/dma-m2m.c
+ * M2M DMA handling for Cirrus EP93xx chips.
+ * Copyright (C) 2007 Metasoft <prylowski@xxxxxxxxxxx>
+ *
+ * Based on dma-m2p.c by:
+ * Copyright (C) 2006 Lennert Buytenhek <buytenh@xxxxxxxxxxxxxx>
+ * Copyright (C) 2006 Applied Data Systems
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/io.h>
+
+#include <mach/dma.h>
+#include <mach/hardware.h>
+
+/* TEMP */
+#define DPRINTK(fmt, args...)
+
+#define M2M_CONTROL	0x00
+#define M2M_INTERRUPT	0x04
+#define M2M_STATUS	0x0c
+#define M2M_BCR0	0x10
+#define M2M_BCR1	0x14
+#define M2M_SAR_BASE0	0x18
+#define M2M_SAR_BASE1	0x1c
+#define M2M_SAR_CURR0	0x24
+#define M2M_SAR_CURR1	0x28
+#define M2M_DAR_BASE0	0x2c
+#define M2M_DAR_BASE1	0x30
+#define M2M_DAR_CURR0	0x34
+#define M2M_DAR_CURR1	0x3c
+
+
+/* control register bits */
+#define CTRL_STALL_INT_EN	0x00000001	/* stall interrupt enable */
+#define CTRL_SCT		0x00000002	/* source copy transfer
+						   (1 elem. from source fills
+						   destination block */
+#define CTRL_DONE_INT_EN	0x00000004	/* done interrupt enable */
+#define CTRL_ENABLE		0x00000008	/* channel enable / disable,
+						   should be set after
+						   write to SAR/DAR/BCR
+						   registers */
+#define CTRL_NFB_INT_EN		0x00200000	/* nfb (next frame buffer)
+						   interrupt enable */
+
+
+#define CTRL_START		0x00000010	/* software triggered
+						   dma start, not used
+						   for M2P/P2M/IDE/SSP */
+#define CTRL_BWC_MASK		0x000001e0	/* bandwidth control (number
+						   of bytes in a block
+						   transfer, only M2M */
+#define CTRL_BWC_SHIFT		5
+
+#define BWC_FULL		0x0	/* full bandwidth utilized */
+#define BWC_16			0x1	/* 16 bytes per block */
+#define BWC_32			0x5
+#define BWC_64			0x6
+#define BWC_128			0x7
+#define BWC_256			0x8
+#define BWC_512			0x9
+#define BWC_1024		0xa
+#define BWC_2048		0xb
+#define BWC_4096		0xc
+#define BWC_8192		0xd
+#define BWC_16384		0xe
+#define BWC_32768		0xf
+
+#define CTRL_PW_MASK		0x00000600	/* peripheral width,
+						   only M2P/P2M */
+#define CTRL_PW_SHIFT		9
+
+#define PW_BYTE			0x0	/* one byte width */
+#define PW_HALFWORD		0x1	/* 16 bits */
+#define PW_WORD			0x2	/* 32 bits */
+#define PW_NOT_USED		0x3
+
+#define CTRL_DAH		0x00000800	/* destination address
+						   hold, for M2P */
+#define CTRL_SAH		0x00001000	/* source address
+						   hold, for P2M */
+#define CTRL_TM_MASK		0x00006000	/* transfer mode */
+#define CTRL_TM_SHIFT		13
+
+#define TM_M2M			0x0	/* software initiated M2M transfer */
+#define TM_M2P			0x1	/* memory to ext. peripheral
+					   or IDE/SSP */
+#define TM_P2M			0x2	/* ext. peripheral or IDE/SSP
+					   to memory */
+#define TM_NOT_USED		0x3
+
+#define CTRL_ETDP_MASK		0x00018000	/* end of transfer/terminal
+						   count pin direction
+						   & polarity */
+#define CTRL_ETDP_SHIFT		15
+
+#define ETDP_ACT_LOW_EOT	0x0	/* pin programmed as active
+					 * low end-of-transfer input */
+#define ETDP_ACT_HIGH_EOT	0x1	/* active high eot input */
+#define ETDP_ACT_LOW_TC		0x2	/* active low terminal count output */
+#define ETDP_ACT_HIGH_TC	0x3	/* active high tc output */
+
+#define CTRL_DACKP		0x00020000	/* dma acknowledge pin
+						   polarity */
+#define CTRL_DREQP_MASK		0x00180000	/* dma request pin polarity */
+#define CTRL_DREQP_SHIFT	19
+
+#define DREQP_ACT_LOW_LEVEL	0x0	/* DREQ is active low, level
+					   sensitive */
+#define DREQP_ACT_HIGH_LEVEL	0x1	/* active high, level sensitive */
+#define DREQP_ACT_LOW_EDGE	0x2	/* active low, edge sensitive */
+#define DREQP_ACT_HIGH_EDGE	0x3	/* active high, edge sensitive */
+
+
+#define CTRL_RSS_MASK		0x00c00000	/* request source selection */
+#define CTRL_RSS_SHIFT		22
+
+#define RSS_EXT			0x0	/* external dma request */
+#define RSS_SSP_RX		0x1	/* internal SSPRx */
+#define RSS_SSP_TX		0x2	/* internal SSPTx */
+#define RSS_IDE			0x3	/* internal IDE */
+
+#define CTRL_NO_HDSK		0x01000000	/* no handshake, required for
+						   SSP/IDE, optional for
+						   ext. M2P/P2M */
+
+
+/* interrupt register bits */
+#define INTR_STALL		0x1
+#define INTR_DONE		0x2
+#define INTR_NFB		0x4
+#define INTR_ALL		0x7
+
+
+/* status register bits */
+#define STAT_STALL		0x0001	/* waiting for software start
+					   or device request */
+#define STAT_CTL_STATE_MASK	0x000e	/* control fsm state */
+#define STAT_CTL_STATE_SHIFT	1
+
+#define CTL_STATE_IDLE		0x0
+#define CTL_STATE_STALL		0x1
+#define CTL_STATE_MEM_RD	0x2
+#define CTL_STATE_MEM_WR	0x3
+#define CTL_STATE_BWC_WAIT	0x4
+
+#define STAT_BUF_STATE_MASK	0x0030	/* buffer fsm state */
+#define STAT_BUF_STATE_SHIFT	4
+
+#define BUF_STATE_NO_BUF	0x0
+#define BUF_STATE_BUF_ON	0x1
+#define BUF_STATE_BUF_NEXT	0x2
+
+#define STAT_DONE		0x0040	/* transfer completed successfully
+					   (by device or BCR is 0) */
+
+#define STAT_TCS_MASK		0x0018	/* terminal count status */
+#define STAT_TCS_SHIFT		7
+
+#define TCS_NONE		0x0	/* terminal count not reached
+					   for buffer0 and buffer1 */
+#define TCS_BUF0		0x1	/* terminal count reached
+					   for buffer0 */
+#define TCS_BUF1		0x2
+#define TCS_BOTH		0x3	/* terminal count reached
+					   for both buffers */
+
+#define STAT_EOTS_MASK		0x0060	/* end of transfer status */
+#define STAT_EOTS_SHIFT		9
+
+#define EOTS_NONE		0x0	/* end of transfer has not been
+					   requested by ext. periph. for
++					   any buffer */
+#define EOTS_BUF0		0x1	/* eot requested for buffer0 */
+#define EOTS_BUF1		0x2
+#define EOTS_BOTH		0x3	/* eot requested for both buffers */
+
+#define STAT_NFB		0x0800	/* next frame buffer interrupt */
+#define STAT_NB			0x1000	/* next buffer status, inform which
+					   buffer is free for update */
+#define STAT_DREQS		0x2000	/* status of dma request signal from
+					   ext. periph or IDE/SSP request */
+
+
+/* IDE/SSP support */
+#define IDE_UDMA_DATAOUT	0x20
+#define IDE_UDMA_DATAIN		0x24
+
+#ifndef SSPDR
+#define SSPDR			0x08
+#endif
+
+struct m2m_channel {
+	char *name;
+	void *base;
+	int irq;
+
+	struct clk *clk;
+	spinlock_t lock;
+
+	void *client;
+	unsigned next_slot:1;
+	struct ep93xx_dma_buffer *buffer_xfer;
+	struct ep93xx_dma_buffer *buffer_next;
+	struct list_head buffers_pending;
+};
+
+static struct m2m_channel m2m_rxtx[] = {
+	{"m2m0", EP93XX_DMA_BASE + 0x0100, IRQ_EP93XX_DMAM2M0},
+	{"m2m1", EP93XX_DMA_BASE + 0x0140, IRQ_EP93XX_DMAM2M1},
+	{NULL},
+};
+
+
+static void feed_buf(struct m2m_channel *ch, struct ep93xx_dma_buffer *buf)
+{
+	struct ep93xx_dma_m2m_client *cl = ch->client;
+	u32 src_addr, dst_addr;
+
+	if ((cl->flags & EP93XX_DMA_M2M_DIR_MASK) == EP93XX_DMA_M2M_TX) {
+		src_addr = buf->bus_addr;
+		switch (cl->flags & EP93XX_DMA_M2M_DEV_MASK) {
+		case EP93XX_DMA_M2M_DEV_IDE:
+			dst_addr = EP93XX_IDE_PHYS_BASE + IDE_UDMA_DATAOUT;
+			break;
+		case EP93XX_DMA_M2M_DEV_SSP:
+			dst_addr = EP93XX_SPI_PHYS_BASE + SSPDR;
+			break;
+		default:
+			dst_addr = buf->bus_addr2;
+			break;
+		}
+	} else {
+		switch (cl->flags & EP93XX_DMA_M2M_DEV_MASK) {
+		case EP93XX_DMA_M2M_DEV_IDE:
+			src_addr = EP93XX_IDE_PHYS_BASE + IDE_UDMA_DATAIN;
+			break;
+		case EP93XX_DMA_M2M_DEV_SSP:
+			src_addr = EP93XX_SPI_PHYS_BASE + SSPDR;
+			break;
+		default:
+			src_addr = buf->bus_addr2;
+			break;
+		}
+		dst_addr = buf->bus_addr;
+	}
+
+	if (ch->next_slot == 0) {
+	  DPRINTK("Writing src_addr: %08x\n", src_addr);
+	  DPRINTK("Writing dest_addr: %08x\n", dst_addr);
+	  DPRINTK("Writing size: %08x\n", buf->size);
+		writel(src_addr, ch->base + M2M_SAR_BASE0);
+		writel(dst_addr, ch->base + M2M_DAR_BASE0);
+		writel(buf->size, ch->base + M2M_BCR0);
+	} else {
+		writel(src_addr, ch->base + M2M_SAR_BASE1);
+		writel(dst_addr, ch->base + M2M_DAR_BASE1);
+		writel(buf->size, ch->base + M2M_BCR1);
+	}
+	ch->next_slot ^= 1;
+	DPRINTK("data size = %d, slot %d\n", buf->size, ch->next_slot ^ 1);
+}
+
+static void choose_buffer_xfer(struct m2m_channel *ch)
+{
+	struct ep93xx_dma_buffer *buf;
+
+	ch->buffer_xfer = NULL;
+	if (!list_empty(&ch->buffers_pending)) {
+		buf = list_entry(ch->buffers_pending.next,
+				 struct ep93xx_dma_buffer, list);
+		list_del(&buf->list);
+		feed_buf(ch, buf);
+		ch->buffer_xfer = buf;
+	}
+}
+
+static void choose_buffer_next(struct m2m_channel *ch)
+{
+	struct ep93xx_dma_buffer *buf;
+
+	ch->buffer_next = NULL;
+	if (!list_empty(&ch->buffers_pending)) {
+		buf = list_entry(ch->buffers_pending.next,
+				 struct ep93xx_dma_buffer, list);
+		list_del(&buf->list);
+		feed_buf(ch, buf);
+		ch->buffer_next = buf;
+	}
+}
+
+static irqreturn_t m2m_irq(int irq, void *dev_id)
+{
+	struct m2m_channel *ch = dev_id;
+	struct ep93xx_dma_m2m_client *cl;
+	u32 irq_status, dma_state, buf_state, ctl_state;
+
+	spin_lock(&ch->lock);
+	irq_status = readl(ch->base + M2M_INTERRUPT);
+	/*if ((irq_status & INTR_ALL) == 0) {
+		spin_unlock(&ch->lock);
+		return IRQ_NONE;
+		}*/
+	dma_state = readl(ch->base + M2M_STATUS);
+	cl = ch->client;
+
+	//printk("intr status: %08x, dma state: %08x\n", irq_status, dma_state);
+
+	DPRINTK("intr status %d, dma state %x\n",
+		irq_status, dma_state);
+
+	buf_state = (dma_state & STAT_BUF_STATE_MASK) >> STAT_BUF_STATE_SHIFT;
+	ctl_state = (dma_state & STAT_CTL_STATE_MASK) >> STAT_CTL_STATE_SHIFT;
+	/*printk("STAT_CTL_STATE: %d, STAT_BUF_STATE: %d\n",
+	 * ctl_state, buf_state);*/
+	if (ctl_state == CTL_STATE_STALL &&
+	    buf_state == BUF_STATE_NO_BUF &&
+	    dma_state & STAT_DONE) {
+	  /* transfer completed successfully (done) */
+
+
+	  /* send client the done command */
+	  if (cl->buffer_finished) {
+	    cl->buffer_finished(cl->cookie, ch->buffer_xfer, ch->buffer_xfer->size, 0);
+	  }
+
+
+
+	  writel(0, ch->base + M2M_INTERRUPT);
+	  choose_buffer_xfer(ch);
+	  choose_buffer_next(ch);
+	  if (ch->buffer_xfer != NULL) {
+	    /* retrigger if more buffers exist */
+	    if ((cl->flags & EP93XX_DMA_M2M_DEV_MASK) ==
+		EP93XX_DMA_M2M_DEV_MEM) {
+	      DPRINTK("Writing start1 to M2M control\n");
+	      writel(readl(ch->base + M2M_CONTROL) |
+		     CTRL_START, ch->base + M2M_CONTROL);
+	      readl(ch->base + M2M_CONTROL);
+	    }
+	  } else {
+	    DPRINTK("DISABLING DMA: dreqs state: %d\n", dma_state & STAT_DREQS);
+
+	    writel(readl(ch->base + M2M_CONTROL)
+		   & ~CTRL_ENABLE, ch->base + M2M_CONTROL);
+	    readl(ch->base + M2M_CONTROL);
+	  }
+	} else if (ctl_state == CTL_STATE_MEM_RD &&
+		   buf_state == BUF_STATE_BUF_ON &&
+		   dma_state & STAT_NFB) {
+	  /* next frame buffer */
+	  if (cl->buffer_finished) {
+	    cl->buffer_finished(cl->cookie, ch->buffer_xfer, 0, 0);
+	  }
+	  ch->buffer_xfer = ch->buffer_next;
+	  choose_buffer_next(ch);
+	}
+
+	if (cl->buffer_started && ch->buffer_xfer != NULL) {
+	  cl->buffer_started(cl->cookie, ch->buffer_xfer);
+	}
+
+	spin_unlock(&ch->lock);
+	return IRQ_HANDLED;
+}
+
+static struct m2m_channel *find_free_channel(struct ep93xx_dma_m2m_client *cl, int channel_spec)
+{
+  struct m2m_channel *ch = m2m_rxtx;
+  int i;
+
+#if 0
+  /* BMS: This code isn't particularly clear; look like it asserts
+   * that a requested channel must not share the same data direction
+   * as a previously requested channel - which makes sense for the SSP,
+   * but not at all for direct hardware transferrs
+   */
+  for (i = 0; ch[i].base; i++) {
+    struct ep93xx_dma_m2m_client *cl2;
+
+    cl2 = ch[i].client;
+    if (cl2 != NULL) {
+      int port;
+
+      /* two the same devices in the same direction
+	 are not allowed
+	 (two "memory devices" should be allowed) */
+      port = cl2->flags & (EP93XX_DMA_M2M_DEV_MASK |
+			   EP93XX_DMA_M2M_DIR_MASK);
+      if (port == (cl->flags & (EP93XX_DMA_M2M_DEV_MASK |
+				EP93XX_DMA_M2M_DIR_MASK)))
+	return NULL;
+    }
+  }
+#endif
+
+
+  if (channel_spec == EP93XX_DMA_M2M_REQUIRES_CH_ANY) {
+    for (i = 0; ch[i].base; i++) {
+      if (ch[i].client == NULL)
+	return ch + i;
+    }
+  } else if (channel_spec == EP93XX_DMA_M2M_REQUIRES_CH_0) {
+    if (ch[0].client == NULL) {
+      return &(ch[0]);
+    }
+  } else if (channel_spec == EP93XX_DMA_M2M_REQUIRES_CH_1) {
+    if (ch[1].client == NULL) {
+      return &(ch[1]);
+    }
+  } else {
+    printk(KERN_ERR "ep93xx-m2m dma channel request: unknown channel spec\n");
+  }
+  return NULL;
+}
+
+u32 set_direction_reg(u32 outv, u32 flags)
+{
+	switch (flags & EP93XX_DMA_M2M_DEV_MASK) {
+	case EP93XX_DMA_M2M_DEV_EXT:
+
+		outv &= ~(CTRL_SAH | CTRL_DAH | CTRL_TM_MASK);
+
+		if (flags & EP93XX_DMA_M2M_EXT_FIFO)
+			outv |= (flags & EP93XX_DMA_M2M_DIR_MASK) ==
+				EP93XX_DMA_M2M_TX ? CTRL_DAH : CTRL_SAH;
+
+		outv |= (((flags & EP93XX_DMA_M2M_DIR_MASK) ==
+			  EP93XX_DMA_M2M_TX) ? TM_M2P : TM_P2M) <<
+			CTRL_TM_SHIFT;
+
+		break;
+	case EP93XX_DMA_M2M_DEV_IDE:
+
+		outv &= ~(CTRL_SAH | CTRL_DAH | CTRL_TM_MASK | CTRL_PWSC_MASK);
+		if ((flags & EP93XX_DMA_M2M_DIR_MASK) == EP93XX_DMA_M2M_TX) {
+			outv |= (2 << CTRL_PWSC_SHIFT) & CTRL_PWSC_MASK;
+			outv |= CTRL_DAH;
+			outv |= TM_M2P << CTRL_TM_SHIFT;
+		} else {
+			outv |= (1 << CTRL_PWSC_SHIFT) & CTRL_PWSC_MASK;
+			outv |= CTRL_SAH;
+			outv |= TM_P2M << CTRL_TM_SHIFT;
+		}
+		break;
+	case EP93XX_DMA_M2M_DEV_SSP:
+
+		outv &= ~(CTRL_SAH | CTRL_DAH | CTRL_TM_MASK | CTRL_RSS_MASK);
+		if ((flags & EP93XX_DMA_M2M_DIR_MASK) == EP93XX_DMA_M2M_TX) {
+			outv |= TM_M2P << CTRL_TM_SHIFT;
+			outv |= CTRL_DAH;
+			outv |= RSS_SSP_TX << CTRL_RSS_SHIFT;
+		} else {
+			outv |= TM_P2M << CTRL_TM_SHIFT;
+			outv |= CTRL_SAH;
+			outv |= RSS_SSP_RX << CTRL_RSS_SHIFT;
+		}
+		break;
+	case EP93XX_DMA_M2M_DEV_MEM:
+		break;
+	}
+	return outv;
+}
+
+static void channel_enable(struct m2m_channel *ch)
+{
+	struct ep93xx_dma_m2m_client *cl = ch->client;
+	u32 outv = 0;
+
+	clk_enable(ch->clk);
+
+
+	/* set peripheral wait state mask - IFF specified in control word */
+	outv |= (cl->flags & CTRL_PWSC_MASK);
+	outv |= (cl->flags & EP93XX_DREQ_MASK);
+
+
+	DPRINTK("Set outv to: %08x\n",outv);
+
+
+
+	switch (cl->flags & EP93XX_DMA_M2M_DEV_MASK) {
+	case EP93XX_DMA_M2M_DEV_EXT:
+		switch (cl->flags & EP93XX_DMA_M2M_EXT_WIDTH_MASK) {
+		case EP93XX_DMA_M2M_EXT_WIDTH_BYTE:
+			outv |= PW_BYTE << CTRL_PW_SHIFT;
+			break;
+		case EP93XX_DMA_M2M_EXT_WIDTH_2BYTES:
+			outv |= PW_HALFWORD << CTRL_PW_SHIFT;
+			break;
+		case EP93XX_DMA_M2M_EXT_WIDTH_4BYTES:
+			outv |= PW_WORD << CTRL_PW_SHIFT;
+			break;
+		}
+		/* if NO_HDSK then PWSC, if not, then DREQ, DACK, TC/DEOT */
+		if (cl->flags & EP93XX_DMA_M2M_EXT_NO_HDSK) {
+			outv |= CTRL_NO_HDSK;
+			/* TODO: wait states */
+		} else {
+			/* TODO: regular handshaking */
+		}
+		outv |= RSS_EXT << CTRL_RSS_SHIFT;
+		break;
+	case EP93XX_DMA_M2M_DEV_IDE:
+		/* NO_HDSK, PWSC, PW, SAH, DAH */
+		outv |= CTRL_NO_HDSK;
+		outv |= PW_WORD << CTRL_PW_SHIFT;
+		/* PWSC = 1 for read, PWSC = 2 for write in UDMA */
+		outv |= RSS_IDE << CTRL_RSS_SHIFT;
+		break;
+	case EP93XX_DMA_M2M_DEV_SSP:
+		outv |= CTRL_NO_HDSK;
+		outv |= PW_HALFWORD << CTRL_PW_SHIFT;
+		outv |= (8 << CTRL_PWSC_SHIFT) & CTRL_PWSC_MASK;
+		break;
+	case EP93XX_DMA_M2M_DEV_MEM:
+		switch (cl->flags & EP93XX_DMA_M2M_MEM_SPEED_MASK) {
+		case EP93XX_DMA_M2M_MEM_SPEED_FULL:
+			outv |= BWC_FULL << CTRL_BWC_SHIFT;
+			break;
+		case EP93XX_DMA_M2M_MEM_SPEED_HALF:
+			outv |= BWC_32768 << CTRL_BWC_SHIFT;
+			break;
+		case EP93XX_DMA_M2M_MEM_SPEED_QUART:
+			outv |= BWC_16384 << CTRL_BWC_SHIFT;
+			break;
+		case EP93XX_DMA_M2M_MEM_SPEED_SLOW:
+			outv |= BWC_16 << CTRL_BWC_SHIFT;
+			break;
+		}
+		outv |= (cl->flags & EP93XX_DMA_M2M_MEM_FILL) ? CTRL_SCT : 0;
+		outv |= TM_M2M << CTRL_TM_SHIFT;
+		break;
+	}
+
+
+	// debug code
+	DPRINTK("PRE-Enable, status is: %08x\n", readl(ch->base+M2M_STATUS));
+
+
+	outv = set_direction_reg(outv, cl->flags);
+	/* STALL interrupt must be enabled */
+	outv |= CTRL_NFB_INT_EN | CTRL_DONE_INT_EN | CTRL_STALL_INT_EN;
+
+	writel(outv, ch->base + M2M_CONTROL);
+	outv = readl(ch->base + M2M_CONTROL);
+	DPRINTK("channel enable, writing control reg = %08x\n", outv);
+}
+
+static void channel_disable(struct m2m_channel *ch)
+{
+	u32 v;
+
+	DPRINTK("Disabling channel\n");
+	v = readl(ch->base + M2M_CONTROL);
+
+	writel(v & ~(CTRL_NFB_INT_EN | CTRL_DONE_INT_EN | CTRL_STALL_INT_EN),
+	       ch->base + M2M_CONTROL);
+
+	v = readl(ch->base + M2M_CONTROL);
+
+	while (readl(ch->base + M2M_STATUS) & STAT_NFB) {
+	  cpu_relax();
+	}
+
+
+	writel(0, ch->base + M2M_CONTROL);
+
+	v = readl(ch->base + M2M_CONTROL);
+
+	while (readl(ch->base + M2M_STATUS) & STAT_STALL) {
+	  cpu_relax();
+	}
+
+	clk_disable(ch->clk);
+}
+
+
+void ep93xx_dma_m2m_set_direction(struct ep93xx_dma_m2m_client *cl,
+				  int direction)
+{
+	struct m2m_channel *ch = cl->channel;
+	u32 outv;
+	unsigned long flags;
+
+	direction &= EP93XX_DMA_M2M_DIR_MASK;
+
+	spin_lock_irqsave(&ch->lock, flags);
+
+	cl->flags &= ~EP93XX_DMA_M2M_DIR_MASK;
+	cl->flags |= direction;
+
+	outv = readl(ch->base + M2M_CONTROL);
+	outv = set_direction_reg(outv, cl->flags);
+	writel(outv, ch->base + M2M_CONTROL);
+	outv = readl(ch->base + M2M_CONTROL);
+	DPRINTK("set_direction: configured control reg = %08x\n", outv);
+
+	spin_unlock_irqrestore(&ch->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ep93xx_dma_m2m_set_direction);
+
+int ep93xx_dma_m2m_client_register(struct ep93xx_dma_m2m_client *cl, int channel_spec)
+{
+	struct m2m_channel *ch;
+	int err;
+
+	ch = find_free_channel(cl,channel_spec);
+	if (ch == NULL)
+		return -1;
+
+	err = request_irq(ch->irq, m2m_irq, IRQF_DISABLED, cl->name ? cl->name
+			  : "dma-m2m", ch);
+	if (err)
+		return -EBUSY;
+
+	ch->client = cl;
+	ch->next_slot = 0;
+	ch->buffer_xfer = NULL;
+	ch->buffer_next = NULL;
+	INIT_LIST_HEAD(&ch->buffers_pending);
+
+	cl->channel = ch;
+
+	channel_enable(ch);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(ep93xx_dma_m2m_client_register);
+
+void ep93xx_dma_m2m_client_unregister(struct ep93xx_dma_m2m_client *cl)
+{
+	struct m2m_channel *ch = cl->channel;
+
+	if (ch) {
+	  channel_disable(ch);
+	  free_irq(ch->irq, ch);
+	  ch->client = NULL;
+	}
+}
+EXPORT_SYMBOL_GPL(ep93xx_dma_m2m_client_unregister);
+
+void ep93xx_dma_m2m_submit(struct ep93xx_dma_m2m_client *cl,
+			   struct ep93xx_dma_buffer *buf)
+{
+
+	struct m2m_channel *ch = cl->channel;
+	unsigned long flags;
+
+
+
+	spin_lock_irqsave(&ch->lock, flags);
+
+	if (ch->buffer_xfer == NULL) {
+		ch->buffer_xfer = buf;
+		feed_buf(ch, buf);
+		if (readl(ch->base + M2M_CONTROL) & CTRL_ENABLE) {
+		  DPRINTK("CTRL_ENABLE\n");
+			if ((cl->flags & EP93XX_DMA_M2M_DEV_MASK) ==
+			    EP93XX_DMA_M2M_DEV_MEM) {
+			  DPRINTK("WRITING START2 TO M2M control\n");
+				writel(readl(ch->base + M2M_CONTROL) |
+				       CTRL_START, ch->base + M2M_CONTROL);
+				readl(ch->base + M2M_CONTROL);
+			}
+		}
+	} else if (ch->buffer_next == NULL) {
+		ch->buffer_next = buf;
+		feed_buf(ch, buf);
+	} else
+		list_add_tail(&buf->list, &ch->buffers_pending);
+	spin_unlock_irqrestore(&ch->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ep93xx_dma_m2m_submit);
+
+void ep93xx_dma_m2m_start(struct ep93xx_dma_m2m_client *cl)
+{
+	struct m2m_channel *ch = cl->channel;
+	u32 v;
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&ch->lock, flags);
+
+
+	writel(readl(ch->base + M2M_STATUS), ch->base+M2M_STATUS);
+	//printk("At start, status is: %08x\n", readl(ch->base + M2M_STATUS));
+
+
+	v = readl(ch->base + M2M_CONTROL) | CTRL_ENABLE;
+	writel(v, ch->base + M2M_CONTROL);
+	v = readl(ch->base + M2M_CONTROL);
+	if (ch->buffer_xfer != NULL) {
+		if (((cl->flags & EP93XX_DMA_M2M_DEV_MASK) ==
+		     EP93XX_DMA_M2M_DEV_MEM)) {
+		  DPRINTK("WRITING START3 to M2M controller\n");
+			v |= CTRL_START;
+			writel(v, ch->base + M2M_CONTROL);
+			v = readl(ch->base + M2M_CONTROL);
+		}
+	}
+
+	spin_unlock_irqrestore(&ch->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ep93xx_dma_m2m_start);
+
+void ep93xx_dma_m2m_stop(struct ep93xx_dma_m2m_client *cl)
+{
+	struct m2m_channel *ch = cl->channel;
+	u32 v;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ch->lock, flags);
+
+	DPRINTK("Stopping DMA by disabling CTRL_ENABLE\n");
+	v = readl(ch->base + M2M_CONTROL) & ~CTRL_ENABLE;
+	writel(v, ch->base + M2M_CONTROL);
+	readl(ch->base + M2M_CONTROL);
+	DPRINTK("configured control reg = %08x\n", v);
+
+	spin_unlock_irqrestore(&ch->lock, flags);
+}
+EXPORT_SYMBOL_GPL(ep93xx_dma_m2m_stop);
+
+void ep93xx_dma_m2m_flush(struct ep93xx_dma_m2m_client *cl)
+{
+	struct m2m_channel *ch = cl->channel;
+
+	channel_disable(ch);
+	ch->next_slot = 0;
+	ch->buffer_xfer = NULL;
+	ch->buffer_next = NULL;
+	INIT_LIST_HEAD(&ch->buffers_pending);
+	channel_enable(ch);
+}
+EXPORT_SYMBOL_GPL(ep93xx_dma_m2m_flush);
+
+static int init_channel(struct m2m_channel *ch)
+{
+	ch->clk = clk_get(NULL, ch->name);
+	if (ch->clk == NULL)
+		return -1;
+
+	spin_lock_init(&ch->lock);
+	ch->client = NULL;
+
+	return 0;
+}
+
+static int __init ep93xx_dma_m2m_init(void)
+{
+	int i;
+
+	for (i = 0; m2m_rxtx[i].base; i++) {
+		if (init_channel(m2m_rxtx + i))
+			return -1;
+	}
+
+	return 0;
+}
+
+arch_initcall(ep93xx_dma_m2m_init);
diff --git a/arch/arm/mach-ep93xx/include/mach/dma.h b/arch/arm/mach-ep93xx/include/mach/dma.h
index ef6bd9d..ef6ec3a 100644
--- a/arch/arm/mach-ep93xx/include/mach/dma.h
+++ b/arch/arm/mach-ep93xx/include/mach/dma.h
@@ -7,6 +7,7 @@
 struct ep93xx_dma_buffer {
 	struct list_head	list;
 	u32			bus_addr;
+	u32			bus_addr2; /* only used by M2M */
 	u16			size;
 };
 
@@ -24,6 +25,7 @@ struct ep93xx_dma_m2p_client {
 	void			*channel;
 };
 
+/* flags (m2p client) */
 #define EP93XX_DMA_M2P_PORT_I2S1	0x00
 #define EP93XX_DMA_M2P_PORT_I2S2	0x01
 #define EP93XX_DMA_M2P_PORT_AAC1	0x02
@@ -41,6 +43,58 @@ struct ep93xx_dma_m2p_client {
 #define EP93XX_DMA_M2P_IGNORE_ERROR	0x40
 #define EP93XX_DMA_M2P_ERROR_MASK	0x60
 
+
+struct ep93xx_dma_m2m_client {
+	char			*name;
+	u32			flags;
+	void			*cookie;
+	void			(*buffer_started)(void *cookie,
+					struct ep93xx_dma_buffer *buf);
+	void			(*buffer_finished)(void *cookie,
+					struct ep93xx_dma_buffer *buf,
+					int bytes, int error);
+
+	/* Internal to the DMA code.  */
+	void			*channel;
+};
+
+/* flags (m2m client) */
+#define EP93XX_DMA_M2M_RX		0x000	/* read from periph./memory */
+#define EP93XX_DMA_M2M_TX		0x004	/* write to periph./memory */
+#define EP93XX_DMA_M2M_DIR_MASK		0x004	/* direction mask */
+#define EP93XX_DMA_M2M_DEV_EXT		0x000	/* external peripheral */
+#define EP93XX_DMA_M2M_DEV_SSP		0x001	/* internal SSP */
+#define EP93XX_DMA_M2M_DEV_IDE		0x002	/* internal IDE */
+#define EP93XX_DMA_M2M_DEV_MEM		0x003	/* memory to memory transfer */
+#define EP93XX_DMA_M2M_DEV_MASK		0x003   /* device mask */
+#define EP93XX_DMA_M2M_EXT_FIFO		0x008	/* external peripheral is one location fifo */
+#define EP93XX_DMA_M2M_EXT_NO_HDSK	0x010	/* external peripheral doesn't require regular handshaking protocol */
+#define EP93XX_DMA_M2M_EXT_WIDTH_MASK	0x300
+#define EP93XX_DMA_M2M_EXT_WIDTH_BYTE	0x000	/* external peripheral transfer is one byte width */
+#define EP93XX_DMA_M2M_EXT_WIDTH_2BYTES	0x100
+#define EP93XX_DMA_M2M_EXT_WIDTH_4BYTES	0x200
+#define EP93XX_DMA_M2M_MEM_SPEED_FULL	0x000	/* M2M bandwidth control */
+#define EP93XX_DMA_M2M_MEM_SPEED_HALF	0x040	/* half bus bandwidth */
+#define EP93XX_DMA_M2M_MEM_SPEED_QUART	0x080	/* quarter bus bandwidth */
+#define EP93XX_DMA_M2M_MEM_SPEED_SLOW	0x0c0	/* slowest speed */
+#define EP93XX_DMA_M2M_MEM_SPEED_MASK	0x0c0   /* memory speed mask */
+#define EP93XX_DMA_M2M_MEM_FILL		0x020	/* M2M is one location to block fill */
+
+/* FIXME */
+#define CTRL_PWSC_MASK		0xfe000000	/* peripheral wait states count */
+#define CTRL_PWSC_SHIFT		25
+#define EP93XX_DREQ_SHIFT 19
+#define EP93XX_DREQ_MASK  0x00180000
+#define EP93XX_DMA_M2M_DREQ_LS_L (00 << EP93XX_DREQ_SHIFT)
+#define EP93XX_DMA_M2M_DREQ_LS_H (01 << EP93XX_DREQ_SHIFT)
+#define EP93XX_DMA_M2M_DREQ_ES_L (10 << EP93XX_DREQ_SHIFT)
+#define EP93XX_DMA_M2M_DREQ_ES_H (11 << EP93XX_DREQ_SHIFT)
+
+/* See ep93xx_dma_m2m_client_register (channel_spec) */
+#define EP93XX_DMA_M2M_REQUIRES_CH_ANY	0
+#define EP93XX_DMA_M2M_REQUIRES_CH_0	1
+#define EP93XX_DMA_M2M_REQUIRES_CH_1	2
+
 int  ep93xx_dma_m2p_client_register(struct ep93xx_dma_m2p_client *m2p);
 void ep93xx_dma_m2p_client_unregister(struct ep93xx_dma_m2p_client *m2p);
 void ep93xx_dma_m2p_submit(struct ep93xx_dma_m2p_client *m2p,
@@ -49,4 +103,15 @@ void ep93xx_dma_m2p_submit_recursive(struct ep93xx_dma_m2p_client *m2p,
 				     struct ep93xx_dma_buffer *buf);
 void ep93xx_dma_m2p_flush(struct ep93xx_dma_m2p_client *m2p);
 
+int  ep93xx_dma_m2m_client_register(struct ep93xx_dma_m2m_client *m2m,
+				    int channel_spec);
+void ep93xx_dma_m2m_client_unregister(struct ep93xx_dma_m2m_client *m2m);
+void ep93xx_dma_m2m_submit(struct ep93xx_dma_m2m_client *m2m,
+			   struct ep93xx_dma_buffer *buf);
+void ep93xx_dma_m2m_flush(struct ep93xx_dma_m2m_client *m2m);
+void ep93xx_dma_m2m_start(struct ep93xx_dma_m2m_client *m2m);
+void ep93xx_dma_m2m_stop(struct ep93xx_dma_m2m_client *m2m);
+void ep93xx_dma_m2m_set_direction(struct ep93xx_dma_m2m_client *m2m,
+				  int direction);
+
 #endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h b/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h
index b1f937e..3563367 100644
--- a/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h
+++ b/arch/arm/mach-ep93xx/include/mach/ep93xx-regs.h
@@ -83,6 +83,7 @@
 
 #define EP93XX_BOOT_ROM_BASE		EP93XX_AHB_IOMEM(0x00090000)
 
+#define EP93XX_IDE_PHYS_BASE            EP93XX_AHB_PHYS(0x000a0000)
 #define EP93XX_IDE_BASE			EP93XX_AHB_IOMEM(0x000a0000)
 
 #define EP93XX_VIC1_BASE		EP93XX_AHB_IOMEM(0x000b0000)
@@ -111,16 +112,26 @@
 #define EP93XX_I2S_BASE			EP93XX_APB_IOMEM(0x00020000)
 
 #define EP93XX_SECURITY_BASE		EP93XX_APB_IOMEM(0x00030000)
+#define EP93XX_SECURITY_REG(x)		(EP93XX_SECURITY_BASE + (x))
+#define EP93XX_SECURITY_UNIQID		EP93XX_SECURITY_REG(0x2440)
 
 #define EP93XX_GPIO_BASE		EP93XX_APB_IOMEM(0x00040000)
 #define EP93XX_GPIO_REG(x)		(EP93XX_GPIO_BASE + (x))
 #define EP93XX_GPIO_F_INT_STATUS	EP93XX_GPIO_REG(0x5c)
+#define EP93XX_GPIO_F_INT_DEBOUNCE	EP93XX_GPIO_REG(0x64)
 #define EP93XX_GPIO_A_INT_STATUS	EP93XX_GPIO_REG(0xa0)
+#define EP93XX_GPIO_A_INT_DEBOUNCE	EP93XX_GPIO_REG(0xa8)
 #define EP93XX_GPIO_B_INT_STATUS	EP93XX_GPIO_REG(0xbc)
+#define EP93XX_GPIO_B_INT_DEBOUNCE	EP93XX_GPIO_REG(0xc4)
 #define EP93XX_GPIO_EEDRIVE		EP93XX_GPIO_REG(0xc8)
 
+#define EP93XX_GPIO_A_DATA		EP93XX_GPIO_REG(0x00)
+#define EP93XX_GPIO_A_DIRECTION		EP93XX_GPIO_REG(0x10)
+#define EP93XX_GPIO_B_DATA		EP93XX_GPIO_REG(0x04)
+
 #define EP93XX_AAC_BASE			EP93XX_APB_IOMEM(0x00080000)
 
+#define EP93XX_SPI_PHYS_BASE		(EP93XX_APB_PHYS_BASE + 0x000a0000)
 #define EP93XX_SPI_BASE			EP93XX_APB_IOMEM(0x000a0000)
 
 #define EP93XX_IRDA_BASE		EP93XX_APB_IOMEM(0x000b0000)
@@ -220,6 +231,7 @@
 #define EP93XX_SYSCON_SYSCFG_LEECLK	(1<<3)
 #define EP93XX_SYSCON_SYSCFG_LCSN2	(1<<1)
 #define EP93XX_SYSCON_SYSCFG_LCSN1	(1<<0)
+#define EP93XX_SYSCON_CHIPID		EP93XX_SYSCON_REG(0x94)
 #define EP93XX_SYSCON_SWLOCK		EP93XX_SYSCON_REG(0xc0)
 
 #define EP93XX_WATCHDOG_BASE		EP93XX_APB_IOMEM(0x00140000)
diff --git a/arch/arm/mach-ep93xx/include/mach/memory.h b/arch/arm/mach-ep93xx/include/mach/memory.h
index 554064e..78eaacf 100644
--- a/arch/arm/mach-ep93xx/include/mach/memory.h
+++ b/arch/arm/mach-ep93xx/include/mach/memory.h
@@ -19,4 +19,32 @@
 #error "Kconfig bug: No EP93xx PHYS_OFFSET set"
 #endif
 
+/*
+ * Non-linear mapping like so:
+ * phys       => virt
+ * 0x00000000 => 0xc0000000
+ * 0x01000000 => 0xc1000000
+ * 0x04000000 => 0xc4000000
+ * 0x05000000 => 0xc5000000
+ * 0xe0000000 => 0xc8000000
+ * 0xe1000000 => 0xc9000000
+ * 0xe4000000 => 0xcc000000
+ * 0xe5000000 => 0xcd000000
+ *
+ * As suggested here: http://marc.info/?l=linux-arm&m=122754446724900&w=2
+ *
+ * Note that static inline functions won't work here because
+ * arch/arm/include/asm/memory.h uses "#ifndef __virt_to_phys" to check whether to
+ * use generic functions or not.
+ */
+
+#define __phys_to_virt(p)   \
+            (((p) & 0x07ffffff) | (((p) & 0xe0000000) ? 0x08000000 : 0) | PAGE_OFFSET)
+
+#define __virt_to_phys(v)   \
+            (((v) & 0x07ffffff) | (((v) & 0x08000000) ? 0xe0000000 : 0 ))
+
+#define SECTION_SIZE_BITS 24
+#define MAX_PHYSMEM_BITS 32
+
 #endif
diff --git a/arch/arm/mach-ep93xx/include/mach/spi.h b/arch/arm/mach-ep93xx/include/mach/spi.h
new file mode 100644
index 0000000..0e07fc9
--- /dev/null
+++ b/arch/arm/mach-ep93xx/include/mach/spi.h
@@ -0,0 +1,18 @@
+/*
+ * arch/arm/mach-ep93xx/include/mach/spi.h
+ */
+
+struct ep93xx_spi_data {
+	u16 chip_select_num;
+};
+
+
+/* spi_board_info.controller_data for SPI slave devices */
+struct ep93xx_spi_chip {
+	void (*cs_control)(u32 command);
+};
+
+/* Chip-select state */
+#define SPI_CS_ASSERT    0x1
+#define SPI_CS_DEASSERT  0x2
+#define SPI_CS_INIT      0x4
diff --git a/arch/arm/mach-ep93xx/include/mach/ts72xx-keypad.h b/arch/arm/mach-ep93xx/include/mach/ts72xx-keypad.h
new file mode 100644
index 0000000..bf44759
--- /dev/null
+++ b/arch/arm/mach-ep93xx/include/mach/ts72xx-keypad.h
@@ -0,0 +1,30 @@
+/*
+ *  TS-72xx "GPIO Port X" input keypad driver
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ * Based on OMAP Keypad Driver (omap-keypad.c)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __ASM_ARCH_TS72XX_KEYPAD_H
+#define __ASM_ARCH_TS72XX_KEYPAD_H
+
+#define EP93XX_PORTX_MAXROW 4
+#define EP93XX_PORTX_MAXCOL 4
+
+/* Example: Port X bit 0..7 = C0,..Cx,R0..Ry
+ * Cols are outputs
+ * Rows are inputs
+ */
+struct ep93xx_gpio_portx_keypad_platform_data {
+  int nr_rows, nr_cols;
+  int keycodes[EP93XX_PORTX_MAXROW][EP93XX_PORTX_MAXCOL]; /* Left to right, from top to bottom */
+  int gpio_rows[EP93XX_PORTX_MAXROW];                     /* R0, R1, .., R_{MAXROW-1} */
+  int gpio_cols[EP93XX_PORTX_MAXCOL];                     /* C0, C1, .., C_{MAXCOL-1} */
+};
+
+#endif	/* __ASM_ARCH_TS72XX_KEYPAD_H */
diff --git a/arch/arm/mach-ep93xx/include/mach/ts72xx.h b/arch/arm/mach-ep93xx/include/mach/ts72xx.h
index 3bd934e..d9d79e5 100644
--- a/arch/arm/mach-ep93xx/include/mach/ts72xx.h
+++ b/arch/arm/mach-ep93xx/include/mach/ts72xx.h
@@ -8,21 +8,35 @@
  * virt		phys		size
  * febff000	22000000	4K	model number register
  * febfe000	22400000	4K	options register
- * febfd000	22800000	4K	options register #2
+ * febfd000	22800000	4K	options register #2 (JP6 and TS-9420 flags)
  * febfc000	[67]0000000	4K	NAND data register
  * febfb000	[67]0400000	4K	NAND control register
  * febfa000	[67]0800000	4K	NAND busy register
  * febf9000	10800000	4K	TS-5620 RTC index register
  * febf8000	11700000	4K	TS-5620 RTC data register
+ * febf7000	23800000	4K	CPLD watchdog (control register)
+ * febf6000	23c00000	4K	CPLD watchdog (feed register)
+ * febf5000	23400000	4K	PLD version (3 bits)
+ * febf4000	22c00000	4K	RS-485 control register
+ * febf3000	23000000	4K	RS-485 mode register
+ * febf2000	10800000	4K	jumpers/max197 busy bit/COM1 dcd register (8-bit, read only)
+ * febf1000	10f00000	4K	max197 sample/control register (16-bit read/8-bit write)
+ * febf0000	11e00000	4K	PC/104 8-bit I/O
+ * febef000	21e00000	4K	PC/104 16-bit I/O
+ * fea00000	11a00000	1MB	PC/104 8-bit memory
+ * fe900000	21a00000	1MB	PC/104 16-bit memory
  */
 
 #define TS72XX_MODEL_PHYS_BASE		0x22000000
 #define TS72XX_MODEL_VIRT_BASE		0xfebff000
 #define TS72XX_MODEL_SIZE		0x00001000
 
-#define TS72XX_MODEL_TS7200		0x00
-#define TS72XX_MODEL_TS7250		0x01
-#define TS72XX_MODEL_TS7260		0x02
+#define TS7XXX_MODEL_TS7200		0x00
+#define TS7XXX_MODEL_TS7250		0x01
+#define TS7XXX_MODEL_TS7260		0x02
+#define TS7XXX_MODEL_TS7300		0x03
+#define TS7XXX_MODEL_TS7400		0x04
+#define TS7XXX_MODEL_MASK		0x07
 
 
 #define TS72XX_OPTIONS_PHYS_BASE	0x22400000
@@ -50,12 +64,13 @@
 #define TS72XX_NAND2_CONTROL_PHYS_BASE	0x70400000
 #define TS72XX_NAND_CONTROL_VIRT_BASE	0xfebfb000
 #define TS72XX_NAND_CONTROL_SIZE	0x00001000
+#define TS72XX_NAND_CONTROL_OFFSET	0x00400000
 
 #define TS72XX_NAND1_BUSY_PHYS_BASE	0x60800000
 #define TS72XX_NAND2_BUSY_PHYS_BASE	0x70800000
 #define TS72XX_NAND_BUSY_VIRT_BASE	0xfebfa000
 #define TS72XX_NAND_BUSY_SIZE		0x00001000
-
+#define TS72XX_NAND_BUSY_OFFSET	0x00800000
 
 #define TS72XX_RTC_INDEX_VIRT_BASE	0xfebf9000
 #define TS72XX_RTC_INDEX_PHYS_BASE	0x10800000
@@ -65,33 +80,135 @@
 #define TS72XX_RTC_DATA_PHYS_BASE	0x11700000
 #define TS72XX_RTC_DATA_SIZE		0x00001000
 
+#define TS72XX_WATCHDOG_CONTROL_VIRT_BASE	0xfebf7000
+#define TS72XX_WATCHDOG_CONTROL_PHYS_BASE	0x23800000
+#define TS72XX_WATCHDOG_CONTROL_SIZE	0x00001000
+
+#define TS72XX_WATCHDOG_FEED_VIRT_BASE	0xfebf6000
+#define TS72XX_WATCHDOG_FEED_PHYS_BASE	0x23c00000
+#define TS72XX_WATCHDOG_FEED_SIZE	0x00001000
+
+#define TS72XX_PLD_VERSION_VIRT_BASE	0xfebf5000
+#define TS72XX_PLD_VERSION_PHYS_BASE	0x23400000
+#define TS72XX_PLD_VERSION_SIZE	0x00001000
+
+#define TS72XX_RS485_CONTROL_VIRT_BASE	0xfebf4000
+#define TS72XX_RS485_CONTROL_PHYS_BASE	0x22c00000
+#define TS72XX_RS485_CONTROL_SIZE	0x00001000
+
+#define TS72XX_RS485_MODE_VIRT_BASE	0xfebf3000
+#define TS72XX_RS485_MODE_PHYS_BASE	0x23000000
+#define TS72XX_RS485_MODE_SIZE	0x00001000
+
+#define TS72XX_JUMPERS_MAX197_VIRT_BASE	0xfebf2000
+#define TS72XX_JUMPERS_MAX197_PHYS_BASE	0x10800000
+#define TS72XX_JUMPERS_MAX197_SIZE	0x00001000
+
+#define TS72XX_MAX197_SAMPLE_VIRT_BASE	0xfebf1000
+#define TS72XX_MAX197_SAMPLE_PHYS_BASE	0x10f00000
+#define TS72XX_MAX197_SAMPLE_SIZE	0x00001000
+
+#define TS72XX_RS485_AUTO485FD         1
+#define TS72XX_RS485_AUTO485HD         2
+#define TS72XX_RS485_MODE_RS232     0x00
+#define TS72XX_RS485_MODE_FD        0x01
+#define TS72XX_RS485_MODE_9600_HD   0x04
+#define TS72XX_RS485_MODE_19200_HD  0x05
+#define TS72XX_RS485_MODE_57600_HD  0x06
+#define TS72XX_RS485_MODE_115200_HD 0x07
+
+#define TS7260_POWER_MANAGEMENT_PHYS_BASE	0x12000000
+#define TS7260_POWER_MANAGEMENT_SIZE		0x00001000
+#define		TS7260_PM_RS232_LEVEL_CONVERTER	0x01
+#define		TS7260_PM_USB			0x02
+#define		TS7260_PM_LCD			0x04
+#define		TS7260_PM_5V_SWITCHER		0x08
+#define		TS7260_PM_PC104_CLOCK		0x10
+#define		TS7260_PM_PC104_FAST_STROBES	0x20
+#define		TS7260_PM_TTL_UART_ENABLE	0x40
+#define		TS7260_PM_SCRATCH_BIT		0x80
+
+#define TS72XX_PC104_8BIT_IO_VIRT_BASE  0xfebf0000
+#define TS72XX_PC104_8BIT_IO_PHYS_BASE  0x11e00000
+#define TS72XX_PC104_8BIT_IO_SIZE       0x00001000
+#define TS72XX_PC104_8BIT_MEM_VIRT_BASE 0xfea00000
+#define TS72XX_PC104_8BIT_MEM_PHYS_BASE 0x11a00000
+#define TS72XX_PC104_8BIT_MEM_SIZE      0x00100000
+
+#define TS72XX_PC104_16BIT_IO_VIRT_BASE  0xfebef000
+#define TS72XX_PC104_16BIT_IO_PHYS_BASE  0x21e00000
+#define TS72XX_PC104_16BIT_IO_SIZE       0x00001000
+#define TS72XX_PC104_16BIT_MEM_VIRT_BASE 0xfe900000
+#define TS72XX_PC104_16BIT_MEM_PHYS_BASE 0x21a00000
+#define TS72XX_PC104_16BIT_MEM_SIZE      0x00100000
+
+/*
+ * TS7200 CF memory map:
+ *
+ * phys		size	description
+ * 11000000	7	CF registers (8-bit each), starting at 11000001
+ * 10400006	2	CF aux registers (8-bit)
+ * 21000000	2	CF data register (16-bit)
+ */
+
+#define TS7200_CF_CMD_PHYS_BASE  0x11000000
+#define TS7200_CF_AUX_PHYS_BASE  0x10400006
+#define TS7200_CF_DATA_PHYS_BASE 0x21000000
+
+#define TS7260_SDCARD_PHYS_BASE  0x13000000
 
 #ifndef __ASSEMBLY__
 
 static inline int board_is_ts7200(void)
 {
-	return __raw_readb(TS72XX_MODEL_VIRT_BASE) == TS72XX_MODEL_TS7200;
+	return (__raw_readb(TS72XX_MODEL_VIRT_BASE) &
+			TS7XXX_MODEL_MASK) == TS7XXX_MODEL_TS7200;
 }
 
 static inline int board_is_ts7250(void)
 {
-	return __raw_readb(TS72XX_MODEL_VIRT_BASE) == TS72XX_MODEL_TS7250;
+	return (__raw_readb(TS72XX_MODEL_VIRT_BASE) &
+			TS7XXX_MODEL_MASK) == TS7XXX_MODEL_TS7250;
 }
 
 static inline int board_is_ts7260(void)
 {
-	return __raw_readb(TS72XX_MODEL_VIRT_BASE) == TS72XX_MODEL_TS7260;
+	return (__raw_readb(TS72XX_MODEL_VIRT_BASE) &
+			TS7XXX_MODEL_MASK) == TS7XXX_MODEL_TS7260;
+}
+
+static inline int board_is_ts7400(void)
+{
+	return (__raw_readb(TS72XX_MODEL_VIRT_BASE) &
+			TS7XXX_MODEL_MASK) == TS7XXX_MODEL_TS7400;
 }
 
 static inline int is_max197_installed(void)
 {
 	return !!(__raw_readb(TS72XX_OPTIONS_VIRT_BASE) &
-					TS72XX_OPTIONS_MAX197);
+			TS72XX_OPTIONS_MAX197);
 }
 
 static inline int is_ts9420_installed(void)
 {
 	return !!(__raw_readb(TS72XX_OPTIONS2_VIRT_BASE) &
-					TS72XX_OPTIONS2_TS9420);
+			TS72XX_OPTIONS2_TS9420);
+}
+
+static inline int is_rs485_installed(void)
+{
+	return !!(__raw_readb(TS72XX_OPTIONS_VIRT_BASE) &
+			TS72XX_OPTIONS_COM2_RS485);
+}
+
+static inline int get_ts72xx_pld_version(void)
+{
+	return (__raw_readb(TS72XX_PLD_VERSION_VIRT_BASE) & 0x7);
+}
+
+/* User jumper */
+static inline int is_jp6_set(void)
+{
+	return (__raw_readb(TS72XX_OPTIONS2_VIRT_BASE) & 0x1);
 }
 #endif
diff --git a/arch/arm/mach-ep93xx/pm.c b/arch/arm/mach-ep93xx/pm.c
new file mode 100644
index 0000000..d3714c8
--- /dev/null
+++ b/arch/arm/mach-ep93xx/pm.c
@@ -0,0 +1,78 @@
+/*
+ *  arch/arm/mach-ep93xx/pm.c
+ *
+ *  EP93xx Power Management Routines
+ *
+ *  Based on pm.c from Andre Renaud, Bluewater Systems Ltd.
+ *
+ *  (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/suspend.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+
+
+static inline void ep93xx_standby(void)
+{
+  u32 v;
+  v = __raw_readl(EP93XX_SYSCON_DEVCFG);
+  v |= EP93XX_SYSCON_DEVCFG_SHENA;
+  __raw_writel(0xaa, EP93XX_SYSCON_SWLOCK);
+  __raw_writel(v, EP93XX_SYSCON_DEVCFG);
+
+  v = __raw_readl(EP93XX_SYSCON_STANDBY);
+
+  asm("nop; nop; nop; nop; nop");
+}
+
+static inline void ep93xx_resume(void)
+{
+  u32 v;
+
+  v = __raw_readl(EP93XX_SYSCON_DEVCFG);
+  v &= ~EP93XX_SYSCON_DEVCFG_SHENA;
+  __raw_writel(0xaa, EP93XX_SYSCON_SWLOCK);
+  __raw_writel(v, EP93XX_SYSCON_DEVCFG);
+}
+
+static int suspend_ep93xx_enter(suspend_state_t state)
+{
+  switch (state) {
+    case PM_SUSPEND_STANDBY:
+    case PM_SUSPEND_MEM:
+      ep93xx_standby(); /* go zzz */
+      ep93xx_resume();
+  }
+  return 0;
+}
+
+static int suspend_ep93xx_valid(suspend_state_t state)
+{
+  return (state == PM_SUSPEND_STANDBY) ||
+    (state == PM_SUSPEND_MEM);
+}
+
+
+static struct platform_suspend_ops ep93xx_suspend_ops = {
+  .enter	= suspend_ep93xx_enter,
+  .valid	= suspend_ep93xx_valid,
+};
+
+static int __init ep93xx_pm_init(void)
+{
+  pr_info("ep93xx: Power Management\n");
+  suspend_set_ops(&ep93xx_suspend_ops);
+  return 0;
+}
+__initcall(ep93xx_pm_init);
diff --git a/arch/arm/mach-ep93xx/ts72xx.c b/arch/arm/mach-ep93xx/ts72xx.c
index 259f782..a6407ae 100644
--- a/arch/arm/mach-ep93xx/ts72xx.c
+++ b/arch/arm/mach-ep93xx/ts72xx.c
@@ -16,9 +16,14 @@
 #include <linux/io.h>
 #include <linux/m48t86.h>
 #include <linux/mtd/physmap.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/spi/spi.h>
 
 #include <mach/hardware.h>
 #include <mach/ts72xx.h>
+#include <mach/spi.h>
 
 #include <asm/mach-types.h>
 #include <asm/mach/map.h>
@@ -32,6 +37,11 @@ static struct map_desc ts72xx_io_desc[] __initdata = {
 		.length		= TS72XX_MODEL_SIZE,
 		.type		= MT_DEVICE,
 	}, {
+		.virtual	= TS72XX_PLD_VERSION_VIRT_BASE,
+		.pfn		= __phys_to_pfn(TS72XX_PLD_VERSION_PHYS_BASE),
+		.length		= TS72XX_PLD_VERSION_SIZE,
+		.type		= MT_DEVICE,
+	}, {
 		.virtual	= TS72XX_OPTIONS_VIRT_BASE,
 		.pfn		= __phys_to_pfn(TS72XX_OPTIONS_PHYS_BASE),
 		.length		= TS72XX_OPTIONS_SIZE,
@@ -51,7 +61,36 @@ static struct map_desc ts72xx_io_desc[] __initdata = {
 		.pfn		= __phys_to_pfn(TS72XX_RTC_DATA_PHYS_BASE),
 		.length		= TS72XX_RTC_DATA_SIZE,
 		.type		= MT_DEVICE,
-	}
+	},
+	/* Use this for debug only. Each device will map its own PC/104 address space */
+	///* PC/104 (8-bit) I/O bus */
+	//{
+	//  .virtual  = TS72XX_PC104_8BIT_IO_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_8BIT_IO_PHYS_BASE),
+	//  .length   = TS72XX_PC104_8BIT_IO_SIZE,
+	//  .type   = MT_DEVICE,
+	//},
+	///* PC/104 (16-bit) I/O bus */
+	//{
+	//  .virtual  = TS72XX_PC104_16BIT_IO_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_16BIT_IO_PHYS_BASE),
+	//  .length   = TS72XX_PC104_16BIT_IO_SIZE,
+	//  .type   = MT_DEVICE,
+	//},
+	///* PC/104 (8-bit) MEM bus */
+	//{
+	//  .virtual  = TS72XX_PC104_8BIT_MEM_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_8BIT_MEM_PHYS_BASE),
+	//  .length   = TS72XX_PC104_8BIT_MEM_SIZE,
+	//  .type   = MT_DEVICE,
+	//},
+	///* PC/104 (16-bit) MEM bus */
+	//{
+	//  .virtual  = TS72XX_PC104_16BIT_MEM_VIRT_BASE,
+	//  .pfn    = __phys_to_pfn(TS72XX_PC104_16BIT_MEM_PHYS_BASE),
+	//  .length   = TS72XX_PC104_16BIT_MEM_SIZE,
+	//  .type   = MT_DEVICE,
+	//}
 };
 
 static struct map_desc ts72xx_nand_io_desc[] __initdata = {
@@ -140,6 +179,9 @@ static void __init ts72xx_register_flash(void)
 		platform_device_register(&ts72xx_flash);
 }
 
+/*************************************************************************
+ * RTC
+ *************************************************************************/
 static unsigned char ts72xx_rtc_readbyte(unsigned long addr)
 {
 	__raw_writeb(addr, TS72XX_RTC_INDEX_VIRT_BASE);
@@ -166,17 +208,104 @@ static struct platform_device ts72xx_rtc_device = {
 	.num_resources	= 0,
 };
 
+/*************************************************************************
+ * SPI
+ *************************************************************************/
+
+#if defined(CONFIG_SPI_TMP124) || defined(CONFIG_SPI_TMP124_MODULE)
+void tmp124_spi_cs(u32 command) // FGPIO[2]
+{
+	if (command & SPI_CS_ASSERT) {
+		gpio_set_value(EP93XX_GPIO_LINE_MCCD2, 0);
+	} else if (command & SPI_CS_DEASSERT) {
+		gpio_set_value(EP93XX_GPIO_LINE_MCCD2, 1);
+	} else if (command & SPI_CS_INIT) {
+		gpio_request(EP93XX_GPIO_LINE_MCCD2, "TMP124 cs");
+		gpio_direction_output(EP93XX_GPIO_LINE_MCCD2, 1);
+	}
+}
+
+static struct ep93xx_spi_chip tmp124_hw = {
+	.cs_control = tmp124_spi_cs,
+};
+
+static struct spi_board_info ts72xx_spi_bus[] __initdata = {
+	{
+		/* TMP124 */
+		.modalias		= "tmp124",
+		.controller_data	= &tmp124_hw,
+		.bus_num		= 1,
+		.chip_select		= 0,
+		.max_speed_hz		= 2 * 1000 * 1000,
+	}
+};
+#endif
+
+/*************************************************************************
+ * Ethernet
+ *************************************************************************/
 static struct ep93xx_eth_data ts72xx_eth_data = {
 	.phy_id		= 1,
 };
 
+/*************************************************************************
+ * i2c peripheral handling
+ *************************************************************************/
+static struct i2c_gpio_platform_data ts72xx_i2c_gpio_data = {
+	.sda_pin		= EP93XX_GPIO_LINE_EGPIO14, // DIO_6 (TS72XX DIO 2x8 header)
+	.sda_is_open_drain      = 0,
+	.scl_pin		= EP93XX_GPIO_LINE_EGPIO15, // DIO_7 (TS72XX DIO 2x8 header)
+	.scl_is_open_drain      = 0,
+	.udelay                 = 0,    /* default to 100 kHz */
+	.timeout                = 0,    /* default to 100 ms */
+};
+
+static struct i2c_board_info __initdata ts72xx_i2c_board_info[] = {
+};
+
+/*************************************************************************
+ * SD Card (TS-7260 only)
+ *************************************************************************/
+
+static struct resource ts72xx_sdcard_resource = {
+	.start		= TS7260_SDCARD_PHYS_BASE,
+	.end		= TS7260_SDCARD_PHYS_BASE + 0x20,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device ts72xx_sdcard = {
+	.name		= "ts72xx-sdcard",
+	.id		= 0,
+	.num_resources	= 1,
+	.resource	= &ts72xx_sdcard_resource,
+};
+
+static void __init ts72xx_register_sdcard(void)
+{
+	if (board_is_ts7260())
+		platform_device_register(&ts72xx_sdcard);
+}
+
+
 static void __init ts72xx_init_machine(void)
 {
 	ep93xx_init_devices();
 	ts72xx_register_flash();
+	ts72xx_register_sdcard();
 	platform_device_register(&ts72xx_rtc_device);
 
+	ep93xx_register_i2c(&ts72xx_i2c_gpio_data,
+			ts72xx_i2c_board_info,
+			ARRAY_SIZE(ts72xx_i2c_board_info));
 	ep93xx_register_eth(&ts72xx_eth_data, 1);
+
+	#if defined(CONFIG_SPI_TMP124) || defined(CONFIG_SPI_TMP124_MODULE)
+	spi_register_board_info(ts72xx_spi_bus,
+			ARRAY_SIZE(ts72xx_spi_bus));
+	#endif
+
+	/* PWM1 is DIO_6 on TS-72xx header */
+	ep93xx_register_pwm(0, 1);
 }
 
 MACHINE_START(TS72XX, "Technologic Systems TS-72xx SBC")
diff --git a/arch/arm/mach-ep93xx/ts72xx_sbcinfo.c b/arch/arm/mach-ep93xx/ts72xx_sbcinfo.c
new file mode 100644
index 0000000..8fc6a6f
--- /dev/null
+++ b/arch/arm/mach-ep93xx/ts72xx_sbcinfo.c
@@ -0,0 +1,200 @@
+/*
+ *  Technologic Systems TS-72XX sbc /proc/driver/sbcinfo entry.
+ *
+ *  Original idea by Liberty Young (Technologic Systems).
+ *
+ *	(c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <mach/hardware.h>
+#include <mach/ts72xx.h>
+
+struct infos {
+	const char *cpu_rev;
+	int model, pld, wdt;
+	int option_ad;
+	int option_rs485;
+	unsigned char jumpers[6]; // 0=off,1=on,2=error
+
+	/* Power management : TS-7260 only */
+	int pm;
+};
+
+static const char *revisions[] = { "A", "B", "C", "D0", "D1", "E0", "E1", "E2", "??" };
+
+
+static void get_sbcinfo(struct infos *data)
+{
+	void __iomem *p;
+	short rev;
+
+	/* CPU revision */
+	rev = __raw_readl(EP93XX_SYSCON_CHIPID) >> 28;
+	if (rev > ARRAY_SIZE(revisions))
+		rev = ARRAY_SIZE(revisions) - 1;
+	data->cpu_rev = revisions[rev];
+
+	/* Board model */
+	if (board_is_ts7200())
+		data->model = 7200;
+	else if (board_is_ts7250())
+		data->model = 7250;
+	else if (board_is_ts7260())
+		data->model = 7260;
+	else if (board_is_ts7400())
+		data->model = 7400;
+	else
+		data->model = 0;
+
+	data->pld = get_ts72xx_pld_version();
+
+	/* A/D converter (8 x 12-bit channels) */
+	if ((data->model == 7200) || (data->model == 7250)) {
+		data->option_ad = is_max197_installed();
+	} else {
+		data->option_ad = 0;
+	}
+
+	/* COM2 RS-485 */
+	if (is_rs485_installed()) {
+		data->option_rs485 = 1;
+	} else {
+		data->option_rs485 = 0;
+	}
+
+	/* jumpers */
+	p = ioremap(TS72XX_JUMPERS_MAX197_PHYS_BASE, TS72XX_JUMPERS_MAX197_SIZE);
+	if (p) {
+		unsigned char c = __raw_readb(p);
+
+		data->jumpers[0] = 2;                // JP1 (bootstrap)
+		data->jumpers[1] = !!(c & 0x01);     // JP2 (enable serial console)
+		data->jumpers[2] = !!(c & 0x02);     // JP3 (flash write enable)
+		data->jumpers[3] = !(c & 0x08);      // JP4 (console on COM2)
+		data->jumpers[4] = !(c & 0x10);      // JP5 (test)
+		data->jumpers[5] = !!(is_jp6_set()); // JP6 (user jumper)
+
+		iounmap(p);
+	} else {
+		data->jumpers[0] = data->jumpers[1] = data->jumpers[2] = 2;
+		data->jumpers[3] = data->jumpers[4] = data->jumpers[5] = 2;
+	}
+
+	/* cpld watchdog */
+	p = ioremap(TS72XX_WATCHDOG_CONTROL_PHYS_BASE, TS72XX_WATCHDOG_CONTROL_SIZE);
+	if (p) {
+		data->wdt = __raw_readb(p) & 0x7;
+		iounmap(p);
+	} else {
+		data->wdt = 8;
+	}
+
+	/* power management */
+	data->pm = -1;
+	if (data->model == 7260) {
+		p = ioremap(TS7260_POWER_MANAGEMENT_PHYS_BASE, TS7260_POWER_MANAGEMENT_SIZE);
+		if (p) {
+			data->pm = __raw_readb(p);
+			iounmap(p);
+		}
+	}
+}
+
+static char *get_pm_string(int reg, char *buffer, size_t size)
+{
+	static const char *pm_state = "rs232=%d usb=%d lcd=%d pc104=%d ttl=%d";
+
+	if (reg < 0) {
+		strncpy(buffer, "n/a", size);
+	} else {
+		/* 1 means on/enabled */
+		snprintf(buffer, size, pm_state,
+				reg & TS7260_PM_RS232_LEVEL_CONVERTER,
+				!!(reg & TS7260_PM_USB),
+				!!(reg & TS7260_PM_LCD),
+				!(reg & TS7260_PM_PC104_CLOCK),
+				!!(reg & TS7260_PM_TTL_UART_ENABLE));
+	}
+	return buffer;
+}
+
+static int ts72xx_sbcinfo_read_proc(char *buffer, char **start, off_t offset,
+		int count, int *eof, void *data)
+{
+	int len, size = count;
+	char *p = buffer;
+	char temp[64];
+	struct infos nfo;
+
+	static const char jpc[3] = { 'n', 'y', '?' };
+	static const char *wdt[9] = { "disabled", "250ms", "500ms", "1s", "reserved", "2s", "4s", "8s", "n/a" };
+
+	get_sbcinfo(&nfo);
+	len = scnprintf(p, size,
+			"Model             : TS-%d (CPU rev %s) (PLD rev %c)\n"
+			"Option max197 A/D : %s\n"
+			"Option RS-485     : %s\n"
+			"Jumpers           : JP2=%c JP3=%c JP4=%c JP5=%c JP6=%c\n"
+			"CPLD Watchdog     : %s\n"
+			"Power management  : %s\n",
+			nfo.model, nfo.cpu_rev, nfo.pld + 0x40,
+			(nfo.option_ad ? "yes" : "no"),
+			(nfo.option_rs485 ? "yes" : "no"),
+			jpc[nfo.jumpers[1]], jpc[nfo.jumpers[2]], jpc[nfo.jumpers[3]], jpc[nfo.jumpers[4]],
+			jpc[nfo.jumpers[5]], wdt[nfo.wdt],
+			get_pm_string(nfo.pm, &temp[0], 64));
+
+	if (len <= offset + count)
+		*eof = 1;
+
+	*start = buffer + offset;
+	len -= offset;
+
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+
+	return len;
+}
+
+
+static int __init ts72xx_sbcinfo_init(void)
+{
+	struct proc_dir_entry *entry;
+	int ret = 0;
+
+	entry = create_proc_read_entry("driver/sbcinfo", 0,
+			NULL, ts72xx_sbcinfo_read_proc, NULL);
+
+	if (!entry) {
+		printk(KERN_ERR "sbcinfo: can't create /proc/driver/sbcinfo\n");
+		ret = -ENOMEM;
+	}
+
+	return ret;
+}
+
+static void __exit ts72xx_sbcinfo_exit(void)
+{
+	remove_proc_entry("driver/sbcinfo", NULL);
+	return;
+}
+
+module_init(ts72xx_sbcinfo_init);
+module_exit(ts72xx_sbcinfo_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("Show information of Technologic Systems TS-72XX sbc");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.03");
diff --git a/arch/arm/mm/proc-arm920.S b/arch/arm/mm/proc-arm920.S
index 2b7c197..f85476b 100644
--- a/arch/arm/mm/proc-arm920.S
+++ b/arch/arm/mm/proc-arm920.S
@@ -198,7 +198,7 @@ ENTRY(arm920_coherent_kern_range)
  */
 ENTRY(arm920_coherent_user_range)
 	bic	r0, r0, #CACHE_DLINESIZE - 1
-1:	mcr	p15, 0, r0, c7, c10, 1		@ clean D entry
+1:	mcr	p15, 0, r0, c7, c14, 1		@ clean+invalidate D entry
 	mcr	p15, 0, r0, c7, c5, 1		@ invalidate I entry
 	add	r0, r0, #CACHE_DLINESIZE
 	cmp	r0, r1
@@ -373,6 +373,9 @@ __arm920_setup:
 	mrc	p15, 0, r0, c1, c0		@ get control register v4
 	bic	r0, r0, r5
 	orr	r0, r0, r6
+#ifdef CONFIG_CR1_NFBIT
+        orr     r0, r0, #0x40000000             @ set nF
+#endif
 	mov	pc, lr
 	.size	__arm920_setup, . - __arm920_setup
 
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index f2df6e2..0a310b4 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -781,5 +781,25 @@ config PATA_BF54X
 
 	  If unsure, say N.
 
+config PATA_TS72XX
+	bool "TS72XX ATA support"
+	depends on ARCH_EP93XX && MACH_TS72XX
+	help
+	  This option enables support for ATA devices on Technologic Systems SBC.
+
+config PATA_TS7200_CF
+	tristate "TS7200 Compact Flash support"
+	depends on PATA_TS72XX
+	help
+	  This option enables support for the compact flash control on
+	  Technologic System TS-7200 SBC.
+
+config PATA_TS9600
+	tristate "TS9600 IDE interface support"
+	depends on PATA_TS72XX && BLK_DEV_IDE_TS9600 != y
+	help
+	  This option enables support for Technologic Systems TS-9600 PC/104 IDE interface.
+
 endif # ATA_SFF
+
 endif # ATA
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index 01e126f..f784f0e 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -77,6 +77,9 @@ obj-$(CONFIG_PATA_PLATFORM)	+= pata_platform.o
 obj-$(CONFIG_PATA_AT91)	+= pata_at91.o
 obj-$(CONFIG_PATA_OF_PLATFORM)	+= pata_of_platform.o
 obj-$(CONFIG_PATA_ICSIDE)	+= pata_icside.o
+obj-$(CONFIG_PATA_TS72XX)	+= pata_ts72xx.o
+obj-$(CONFIG_PATA_TS7200_CF)	+= pata_ts7200_cf.o
+obj-$(CONFIG_PATA_TS9600)	+= pata_ts9600.o
 # Should be last but two libata driver
 obj-$(CONFIG_PATA_ACPI)		+= pata_acpi.o
 # Should be last but one libata driver
diff --git a/drivers/ata/pata_ts7200_cf.c b/drivers/ata/pata_ts7200_cf.c
new file mode 100644
index 0000000..cc884b5
--- /dev/null
+++ b/drivers/ata/pata_ts7200_cf.c
@@ -0,0 +1,85 @@
+/*
+ *  Technologic Systems TS-7200 Compact Flash PATA device driver.
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/libata.h>
+#include <scsi/scsi_host.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/ts72xx.h>
+
+#define DRV_NAME  "pata_ts7200_cf"
+#define DRV_VERSION "0.2"
+
+static struct resource ts7200_cf_resources[] = {
+  [0] = {
+    .start = TS7200_CF_CMD_PHYS_BASE,
+    .end   = TS7200_CF_CMD_PHYS_BASE + 8,
+    .flags = IORESOURCE_MEM,
+  },
+  [1] = {
+    .start = TS7200_CF_AUX_PHYS_BASE,
+    .end   = TS7200_CF_AUX_PHYS_BASE + 1,
+    .flags = IORESOURCE_MEM,
+  },
+  [2] = {
+    .start = TS7200_CF_DATA_PHYS_BASE,
+    .end   = TS7200_CF_DATA_PHYS_BASE + 2,
+    .flags = IORESOURCE_MEM,
+  },
+  [3] = {
+    .start = IRQ_EP93XX_EXT0, /* pin 103 of EP9301 */
+    .end   = IRQ_EP93XX_EXT0,
+    .flags = IORESOURCE_IRQ,
+  }
+};
+
+
+static struct platform_device ts7200_cf_device = {
+  .name = "ts72xx-ide",
+  .id = 0,
+  .dev  = {
+		.dma_mask = &ts7200_cf_device.dev.coherent_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+  },
+  .num_resources  = ARRAY_SIZE(ts7200_cf_resources),
+  .resource = ts7200_cf_resources,
+};
+
+
+static __init int pata_ts7200_cf_init(void)
+{
+  return (board_is_ts7200()) ? \
+    platform_device_register(&ts7200_cf_device) : -ENODEV;
+}
+
+static __exit void pata_ts7200_cf_exit(void)
+{
+  platform_device_unregister(&ts7200_cf_device);
+}
+
+module_init(pata_ts7200_cf_init);
+module_exit(pata_ts7200_cf_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("TS-7200 CF PATA device driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/ata/pata_ts72xx.c b/drivers/ata/pata_ts72xx.c
new file mode 100644
index 0000000..e96cee3
--- /dev/null
+++ b/drivers/ata/pata_ts72xx.c
@@ -0,0 +1,155 @@
+/*
+ *  TS-72XX PATA driver for Technologic Systems boards.
+ *
+ *  Based on pata_platform.c by Paul Mundt &
+ *      Alessandro Zummo <a.zummo@towertech.it>
+ *  and old pata-ts72xx.c by Alessandro Zummo <a.zummo@towertech.it>
+ *
+ *	(c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <scsi/scsi_host.h>
+#include <linux/ata.h>
+#include <linux/libata.h>
+
+#define DRV_NAME  "pata_ts72xx"
+#define DRV_VERSION "2.01"
+
+
+/*
+ * Provide our own set_mode() as we don't want to change anything that has
+ * already been configured..
+ */
+static int ts72xx_set_mode(struct ata_link *link, struct ata_device **unused)
+{
+  struct ata_device *dev;
+
+  ata_for_each_dev(dev, link, ENABLED) {
+    if (ata_dev_enabled(dev)) {
+      /* We don't really care */
+      dev->pio_mode = dev->xfer_mode = XFER_PIO_0;
+      dev->xfer_shift = ATA_SHIFT_PIO;
+      dev->flags |= ATA_DFLAG_PIO;
+      ata_dev_printk(dev, KERN_INFO, "configured for PIO\n");
+    }
+  }
+  return 0;
+}
+
+static struct scsi_host_template ts72xx_sht = {
+  ATA_PIO_SHT(DRV_NAME),
+};
+
+static struct ata_port_operations ts72xx_port_ops = {
+  .inherits     = &ata_sff_port_ops,
+  .set_mode     = ts72xx_set_mode,
+};
+
+static __devinit int ts72xx_pata_probe(struct platform_device *pdev)
+{
+  struct ata_host *host;
+  struct ata_port *ap;
+  int irq;
+
+  struct resource *pata_cmd  = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  struct resource *pata_aux  = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+  struct resource *pata_data = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+
+  if (!pata_cmd || !pata_aux || !pata_data) {
+    dev_err(&pdev->dev, "missing resource(s)\n");
+    return -EINVAL;
+  }
+
+  irq = platform_get_irq(pdev, 0);
+  if (irq < 0)
+    irq = 0;  /* no irq */
+
+  /*
+   * Now that that's out of the way, wire up the port
+   */
+  host = ata_host_alloc(&pdev->dev, 1);
+  if (!host)
+    return -ENOMEM;
+  ap = host->ports[0];
+
+  ap->ops = &ts72xx_port_ops;
+  ap->pio_mask = 0x1f; /* PIO0-4 */
+  ap->flags |= ATA_FLAG_SLAVE_POSS;
+
+  /*
+   * Use polling mode if there's no IRQ
+   */
+  if (!irq) {
+    ap->flags |= ATA_FLAG_PIO_POLLING;
+    ata_port_desc(ap, "no IRQ, using PIO polling");
+  }
+
+  ap->ioaddr.cmd_addr = devm_ioremap(&pdev->dev, pata_cmd->start,
+      pata_cmd->end - pata_cmd->start + 1);
+  ap->ioaddr.ctl_addr = devm_ioremap(&pdev->dev, pata_aux->start,
+      pata_aux->end - pata_aux->start + 1);
+
+  if (!ap->ioaddr.cmd_addr || !ap->ioaddr.ctl_addr) {
+    dev_err(&pdev->dev, "failed to map IO/CTL base\n");
+    return -ENOMEM;
+  }
+
+  ap->ioaddr.altstatus_addr = ap->ioaddr.ctl_addr;
+
+  ata_sff_std_ports(&ap->ioaddr);
+  ap->ioaddr.data_addr = devm_ioremap(&pdev->dev, pata_data->start,
+      pata_data->end - pata_data->start + 1);
+
+  ata_port_desc(ap, "mmio cmd 0x%llx ctl 0x%llx",
+      (unsigned long long)pata_cmd->start,
+      (unsigned long long)pata_aux->start);
+
+  return ata_host_activate(host, irq, irq ? ata_sff_interrupt : NULL,
+      0 /* irq flags */, &ts72xx_sht);
+}
+
+static __devexit int ts72xx_pata_remove(struct platform_device *pdev)
+{
+  struct device *dev = &pdev->dev;
+  struct ata_host *host = dev_get_drvdata(dev);
+
+  ata_host_detach(host);
+
+  return 0;
+}
+
+static struct platform_driver ts72xx_pata_platform_driver = {
+  .probe    = ts72xx_pata_probe,
+  .remove   = __devexit_p(ts72xx_pata_remove),
+  .driver = {
+    .name   = "ts72xx-ide",
+    .owner  = THIS_MODULE,
+  },
+};
+
+static int __init ts72xx_pata_init(void)
+{
+  return platform_driver_register(&ts72xx_pata_platform_driver);
+}
+
+static void __exit ts72xx_pata_exit(void)
+{
+  platform_driver_unregister(&ts72xx_pata_platform_driver);
+}
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("low-level driver for TS-72xx device PATA");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+module_init(ts72xx_pata_init);
+module_exit(ts72xx_pata_exit);
diff --git a/drivers/ata/pata_ts9600.c b/drivers/ata/pata_ts9600.c
new file mode 100644
index 0000000..0eb485a
--- /dev/null
+++ b/drivers/ata/pata_ts9600.c
@@ -0,0 +1,88 @@
+/*
+ *  Technologic Systems TS-9600 PATA device driver.
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/libata.h>
+#include <scsi/scsi_host.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/ts72xx.h>
+
+#define DRV_NAME  "pata_ts9600"
+#define DRV_VERSION "0.2"
+
+#define TS9600_IDE_IO   (TS72XX_PC104_8BIT_IO_PHYS_BASE + 0x1F0)
+#define TS9600_IDE_DATA (TS72XX_PC104_16BIT_IO_PHYS_BASE + 0x1F0)
+#define TS9600_IDE_IRQ  IRQ_EP93XX_EXT3  // IRQ7 (no other possibility for arm)
+
+static struct resource ts9600_resources[] = {
+  [0] = {
+    .start = TS9600_IDE_IO,
+    .end   = TS9600_IDE_IO + 8,
+    .flags = IORESOURCE_MEM,
+  },
+  [1] = {
+    .start = TS9600_IDE_IO + 0x206,
+    .end   = TS9600_IDE_IO + 0x206 + 1,
+    .flags = IORESOURCE_MEM,
+  },
+  [2] = {
+    .start = TS9600_IDE_DATA,
+    .end   = TS9600_IDE_DATA + 2,
+    .flags = IORESOURCE_MEM,
+  },
+  [3] = {
+    .start = TS9600_IDE_IRQ,
+    .end   = TS9600_IDE_IRQ,
+    .flags = IORESOURCE_IRQ,
+  }
+};
+
+
+static struct platform_device ts9600_device = {
+  .name = "ts72xx-ide",
+  .id = 9600,
+  .dev  = {
+		.dma_mask = &ts9600_device.dev.coherent_dma_mask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
+  },
+  .num_resources  = ARRAY_SIZE(ts9600_resources),
+  .resource = ts9600_resources,
+};
+
+
+static __init int pata_ts9600_init(void)
+{
+  return platform_device_register(&ts9600_device);
+}
+
+static __exit void pata_ts9600_exit(void)
+{
+  platform_device_unregister(&ts9600_device);
+}
+
+module_init(pata_ts9600_init);
+module_exit(pata_ts9600_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("TS-9600 PATA device driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 1d886e0..7bcc230 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -486,4 +486,11 @@ config BLK_DEV_HD
 
 	  If unsure, say N.
 
+config BLK_DEV_TS72XX_SDCARD
+	tristate "TS72XX SD Card support"
+	depends on ARCH_EP93XX && MACH_TS72XX
+	help
+	  This option enables support SD Card control on Technologic Systems
+	  TS-7260 SBC.
+
 endif # BLK_DEV
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index cdaa3f8..d3eba2a 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -34,7 +34,9 @@ obj-$(CONFIG_VIODASD)		+= viodasd.o
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
 obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
 obj-$(CONFIG_BLK_DEV_HD)	+= hd.o
+obj-$(CONFIG_BLK_DEV_TS72XX_SDCARD)	+= ts72xx_sdcard_mod.o
 
 obj-$(CONFIG_XEN_BLKDEV_FRONTEND)	+= xen-blkfront.o
 
 swim_mod-objs	:= swim.o swim_asm.o
+ts72xx_sdcard_mod-objs	:= tssdcard.o sdcore2.o
diff --git a/drivers/block/sdcore2.c b/drivers/block/sdcore2.c
new file mode 100644
index 0000000..edaee2a
--- /dev/null
+++ b/drivers/block/sdcore2.c
@@ -0,0 +1,2391 @@
+/*
+ * Copyright (c) 2006-2009, Technologic Systems
+ * All rights reserved.
+ */
+
+/*
+ * This code is 100% operating system/CPU independent-- not a single global
+ * reference, external symbol, or #include is required.  Centric upon one data 
+ * structure "struct sdcore".  OS-specific callbacks for things like DMA 
+ * acceleration and sleeping are defined by function pointers to OS-specific
+ * code in the struct sdcore.  Minimally requires the os_sleep() callback to be 
+ * implemented for proper SD card initialization and a pointer to start
+ * of SD card registers.  Auto-determines TS SD core version.  All other
+ * callback functions may be left NULL-- they are only to allow speed/CPU
+ * utilization improvements.
+ * 
+ * 3 main public functions - sdreset(), sdread() and sdwrite().  sdreset()
+ * returns card size.  OS specific shim is required to turn this
+ * simple API into the complicated, constantly changing, hacker "designed"
+ * horrible excuses for abstraction, block driver APIs required in other 
+ * "modern" operating systems.  
+ *
+ * Not all SD cards over the years have followed spec perfectly -- many
+ * don't even check CRC's on the CMD or DAT busses and some have problems
+ * (lock up) when reading/writing the last sectors with SD read/write multiple
+ * commands.
+ *
+ * The TS SD hardware cores are not much more than GPIO bit-bang cores with
+ * a few well-placed hardware optimizations to achieve reasonable
+ * performance goals.  In the roughly 2000 lines of code that follow, there
+ * is support for all distinct TS hardware SD cores on PPC and ARM platforms, 
+ * a generic (private) SD  command layer, sdcmd(), and SD flash card 
+ * (public) routines for initialization + read/write + some SD security 
+ * features. 
+ *
+ */
+
+/* Register offset definitions.  TS-SDCORE is 4 regs total. */
+#define SDCMD		0
+#define SDGPIO		0	/* version 2 register */
+#define SDDAT		1
+#define SDSTAT2		1
+#define SDSTATE		2
+#define SDCTRL		3
+#define SDDAT2		4
+#define SDCMD2		8
+#define SDCTRL2		12
+#define SDLUN2		2
+
+struct sdcore {
+	/* virtual address of SD block register start, to be filled in
+	 * by client code before calling any sdcore functions.
+	 */
+	unsigned int sd_regstart; 
+
+	/* public bits for sd_state bitfield, can be read from client code.
+	 * Do not write!  Other bits are used internally.
+	 */
+	#define SDDAT_RX	(1<<0)
+	#define SDDAT_TX	(1<<1)
+	#define SDCMD_RX	(1<<2)
+	#define SDCMD_TX	(1<<3)
+	unsigned int sd_state; 
+
+	/* Erase hint for subsequent sdwrite() call, used to optimize 
+	 * write throughput on multi-sector writes by pre-erasing this
+	 * many sectors. XXX: this doesn't have much benefit on most SDs
+	 */
+	unsigned int sd_erasehint;
+
+	/* Following this comment are 3 function pointer declarations to 
+	 * OS helper functions.  The 'os_arg' member is passed as the 
+	 * first argument to the helpers and should be set by
+	 * client code before issueing sdreset()
+	 *
+	 * os_dmastream(os_arg, buf, buflen)
+	 * This function should look at sd_state and set up and run an
+	 * appropriate DMA transfer.  If buf is NULL, callee doesn't care 
+	 * about the actual data sent/received and helper function 
+	 * can do whatever it wants.  Should return 0 when DMA transfer was 
+	 * run and completed successfully.  If this function pointer is
+	 * NULL, PIO methods of transfer will be used instead of DMA.
+	 *
+	 * os_dmaprep(os_arg, buf, buflen)
+	 * This function is used to prepare an area of memory for a possible 
+	 * DMA transfer.  This function is called once per distinct buffer
+	 * passed in.  After this function is called, os_dmastream() may be
+	 * called one or more times (for sequential addresses) on subregions
+	 * of the address range passed here.  Should write-back or invalidate 
+	 * L1 cache lines and possibly look up physical addresses for buf 
+	 * passed in if I/O buffers.  If 'os_dmaprep' is set to NULL, function
+	 * call will not happen. (though os_dmastream() calls may still)
+	 *
+	 * os_delay(os_arg, microseconds)
+	 * This function is supposed to delay or stall the processor for
+	 * the passed in value number of microseconds.
+	 */
+	void *os_arg;
+	int (*os_dmastream)(void *, unsigned char *, unsigned int);
+	void (*os_dmaprep)(void *, unsigned char *, unsigned int);
+	void (*os_delay)(void *, unsigned int);
+	void (*os_irqwait)(void *, unsigned int);
+	int (*os_powerok)(void *);
+	int (*os_timeout)(void *);
+	int (*os_reset_timeout)(void *);
+
+	/* If the SD card last successfully reset is write protected, this
+	 * member will be non-zero.
+	 */
+	unsigned int sd_wprot;
+
+	/* If this card may have been already initialized by TS-SDBOOT, place
+	 * the magic token it placed in the EP93xx SYSCON ScratchReg1 here
+	 * to avoid re-initialization.
+	 */
+	unsigned int sdboot_token;
+
+	/* CRC hint for subsequent sdwrite() call, used to optimize
+	 * write throughput while using DMA by pre-calculating CRC's for
+	 * next write
+	 */
+	unsigned char *sd_crchint;
+
+	/* The block size of the memory device.  Normally 512, but can be 1024
+	 * for larger cards
+	 */
+	unsigned int sd_blocksize;
+
+	/* Password for auto-unlocking in sdreset()
+	 */
+	unsigned char *sd_pwd;
+	
+	/* If the SD card was password locked, this will be non-zero. 
+	 */
+	unsigned int sd_locked;
+
+	/* Whether or not writes can be parked.
+	 */
+	unsigned int sd_writeparking;
+
+	/* Logical unit number.  Some SD cores will have multiple card slots.
+	 */
+	unsigned int sd_lun;
+
+	/* The rest of these members are for private internal use and should
+	 * not be of interest to client code.
+	 */
+	unsigned int sd_rcaarg;
+	unsigned int sd_csd[17];
+	unsigned int sd_crcseq;
+	unsigned short sd_crcs[4];
+	unsigned int sd_crctmp[4];
+	unsigned int sd_timeout;
+	unsigned int parked_sector;
+	unsigned int hw_version;
+	unsigned char sd_scr[8];
+	unsigned int sd_sz;
+};
+
+/* For sdreadv() / sdwritev() */
+struct sdiov {
+	unsigned char *sdiov_base;
+	unsigned int sdiov_nsect;
+};
+
+int sdreset(struct sdcore *);
+int sdread(struct sdcore *, unsigned int, unsigned char *, int);
+int sdwrite(struct sdcore *, unsigned int, unsigned char *, int);
+int sdreadv(struct sdcore *, unsigned int, struct sdiov *, int);
+int sdwritev(struct sdcore *, unsigned int, struct sdiov *, int);
+int sdsetwprot(struct sdcore *, unsigned int);
+#define SDLOCK_UNLOCK	0
+#define SDLOCK_SETPWD	1
+#define SDLOCK_CLRPWD	2
+#define SDLOCK_ERASE	8
+#ifndef SD_NOLOCKSUPPORT
+int sdlockctl(struct sdcore *, unsigned int, unsigned char *, unsigned char *);
+#endif
+
+/*
+ * Everything below here is secret!  This code shouldn't have to change
+ * even for different OS. 
+ */
+
+const static unsigned short crc16tbl[256] = {
+	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
+	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
+	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
+	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
+	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
+	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
+	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
+	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
+	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
+	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
+	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
+	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
+	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
+	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
+	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
+	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
+	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
+	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
+	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
+	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
+	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
+	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
+	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
+	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
+	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
+	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
+	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
+	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
+	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
+	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
+	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
+	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
+};
+
+const static unsigned char destagger[256] = {
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,
+	2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,
+};
+
+#ifndef MAX_SDCORES
+#define MAX_SDCORES 64
+#endif
+static struct sdcore *sdcores[MAX_SDCORES];
+
+static unsigned int crc7(unsigned int, const unsigned int *, unsigned int);
+static int sdreset2(struct sdcore *);
+static int version(struct sdcore *);
+static int sdfastinit(struct sdcore *sd);
+static int sdcmd2(struct sdcore *, unsigned short, unsigned int, 
+  unsigned int *, unsigned char **);
+static int sdcmd(struct sdcore *, unsigned short, unsigned int,
+  unsigned int *, unsigned char **);
+static void mkcommand(unsigned int, unsigned int, unsigned int *);
+static int stop(struct sdcore *);
+static int stop2(struct sdcore *);
+static int sdread2(struct sdcore *, unsigned int, unsigned char *, int)
+  __attribute__ ((unused));
+static int do_read2(struct sdcore *, unsigned int, struct sdiov *,
+  unsigned int);
+static int do_read(struct sdcore *, unsigned int, struct sdiov *,
+  unsigned int);
+static int do_write(struct sdcore *, unsigned int, struct sdiov *, 
+  unsigned int);
+static int do_write2(struct sdcore *, unsigned int, struct sdiov *, 
+  unsigned int);
+static int sdsetwprot2(struct sdcore *, unsigned int);
+#ifndef SD_NOLOCKSUPPORT
+static int sdlockctl2(struct sdcore *, unsigned int, unsigned char *,
+  unsigned char *);
+#endif
+
+#ifndef SDPOKE8
+# define SDPOKE8(sd, x, y)	\
+  *(volatile unsigned char *)((sd)->sd_regstart + (x)) = (y)
+#endif
+#ifndef SDPOKE32
+# define SDPOKE32(sd, x, y)	\
+  *(volatile unsigned int *)((sd)->sd_regstart + (x)) = (y)
+#endif
+#ifndef SDPOKE16
+# define SDPOKE16(sd, x, y)	\
+  *(volatile unsigned short *)((sd)->sd_regstart + (x)) = (y)
+#endif
+#ifndef SDPEEK8
+# define SDPEEK8(sd, x)	*(volatile unsigned char *)((sd)->sd_regstart + (x))
+#endif
+#ifndef SDPEEK32
+# define SDPEEK32(sd, x)	*(volatile unsigned int *)((sd)->sd_regstart + (x))
+#endif
+#ifndef SDPEEK16
+# define SDPEEK16(sd, x)	*(volatile unsigned short *)((sd)->sd_regstart + (x))
+#endif
+
+#define S_DUMMY_CLK	0
+#define S_SEND_CMD	1
+#define S_WAIT_RESP	2
+#define S_RX_RESP	3
+#define S_WAIT_BUSY	4
+#define S_TX_WRITE	5
+#define S_CRC_CHECK	6
+#define S_OFF		7
+
+#define TYPE_SHORTRESP	2
+#define TYPE_LONGRESP	3
+#define TYPE_BSYRESP	4
+#define TYPE_NORESP	1
+#define TYPE_RXDAT	0
+#define TYPE_TXDAT	5
+#define TYPE_ABORT	6
+#define TYPE_RXDAT_IGNRESP	7
+
+#define CMD(idx, type)	(0x40 | (idx) | ((type)<<8))
+
+#define CMD_GO_IDLE_STATE		CMD(0, TYPE_NORESP)
+#define CMD_ALL_SEND_CID		CMD(2, TYPE_LONGRESP)
+#define CMD_SEND_RELATIVE_ADDR		CMD(3, TYPE_SHORTRESP)
+#define CMD_SWITCH_FUNC			CMD(6, TYPE_RXDAT)
+#define CMD_SWITCH_FUNC2		CMD(6, TYPE_RXDAT_IGNRESP)
+#define CMD_SELECT_CARD			CMD(7, TYPE_BSYRESP)
+#define CMD_DESELECT_CARD		CMD(7, TYPE_NORESP)
+#define CMD_SEND_IF_COND		CMD(8, TYPE_SHORTRESP)
+#define CMD_SEND_CSD			CMD(9, TYPE_LONGRESP)
+#define CMD_PROGRAM_CSD			CMD(27, TYPE_TXDAT)
+#define CMD_SET_BLOCKLEN		CMD(16, TYPE_SHORTRESP)
+#define CMD_LOCK_UNLOCK			CMD(42, TYPE_TXDAT)
+#define CMD_APP_CMD			CMD(55, TYPE_SHORTRESP)
+#define CMD_READ_SINGLE_BLOCK		CMD(17, TYPE_RXDAT)
+#define CMD_READ_MULTIPLE_BLOCK		CMD(18, TYPE_RXDAT)
+#define CMD_READ_MULTIPLE_BLOCK2	CMD(18, TYPE_RXDAT_IGNRESP)
+#define CMD_STOP_TRANSMISSION		CMD(12, TYPE_ABORT)
+#define CMD_SEND_STATUS			CMD(13, TYPE_SHORTRESP)
+#define CMD_WRITE_BLOCK			CMD(24, TYPE_TXDAT)
+#define CMD_WRITE_MULTIPLE_BLOCK	CMD(25, TYPE_TXDAT)
+
+#define ACMD_SD_SEND_OP_COND		CMD(41, TYPE_SHORTRESP)
+#define ACMD_SET_CLR_CARD_DETECT	CMD(42, TYPE_SHORTRESP)
+#define ACMD_SET_BUS_WIDTH		CMD(6, TYPE_SHORTRESP)
+#define ACMD_SET_WR_BLK_ERASE_COUNT	CMD(23, TYPE_SHORTRESP)
+#define ACMD_SEND_NUM_WR_BLOCKS		CMD(22, TYPE_RXDAT)
+#define ACMD_SEND_SCR			CMD(51, TYPE_RXDAT)
+#define ACMD_SEND_SCR2			CMD(51, TYPE_RXDAT_IGNRESP)
+
+/* Private bits for struct sdcore, sd_state member */
+#define DATSSP_NOCRC		(1<<4)
+#define DATSSP_4BIT		(1<<5)
+#define SD_HC			(1<<6)
+#define SD_HISPEED		(1<<7)
+#define SD_LOSPEED		(1<<8)
+#define SD_SELECTED		(1<<9)
+#define SD_RESET		(1<<10)
+
+#define	NULL			((void *)0)
+
+static void remember_sdcore(struct sdcore *sd) {
+	int i, newlun = 0;
+	
+	for (i = 0; i < sizeof(sdcores); i++) {
+		if (sdcores[i] == NULL) {
+			/* new core, first reset */
+			sdcores[i] = sd;
+			/* core was almost definitely power-cycled on prev lun
+			 * sdreset2(), so we don't need to have the sdreset2()
+			 * do it again.
+			 */
+			if (newlun) sd->sd_state = SD_RESET;
+			break;
+		} else if (sdcores[i]->sd_regstart == sd->sd_regstart) {
+			newlun = 1;
+			if (sdcores[i]->sd_lun == sd->sd_lun) {
+				sdcores[i] = sd;
+				break;
+			}
+		}
+	}
+}
+
+static int activate(struct sdcore *sd) {
+	int i;
+
+	/* Are we already selected? */
+	if ((sd->sd_state & (SD_SELECTED|SD_RESET)) == SD_SELECTED)
+	  return 0;
+
+	/* Find currently activated SD slot for this HW core */
+	for (i = 0; i < sizeof(sdcores); i++) {
+		if (sdcores[i] == NULL) break;
+		if (sdcores[i]->sd_regstart == sd->sd_regstart &&
+		  sdcores[i]->sd_state & SD_SELECTED) break;
+	}
+
+	/* Stop whatever parked transfer it has going on. */
+	if (sdcores[i]) {
+		stop2(sdcores[i]);
+		sdcores[i]->sd_state &= ~SD_SELECTED;
+	}
+
+	/* Change clock routing, mark us as selected */
+#ifdef BIGENDIAN
+	SDPOKE16(sd, SDLUN2, sd->sd_lun << 8);
+#else
+	SDPOKE16(sd, SDLUN2, sd->sd_lun);
+#endif
+
+	/* Change clock frequency */
+	if (sd->sd_state & SD_HISPEED) SDPOKE8(sd, SDSTAT2, 0x38);
+	else SDPOKE8(sd, SDSTAT2, 0x18);
+
+	sd->sd_state |= SD_SELECTED;
+	if (sd->sd_state & SD_RESET) return 1;
+	else return 0;
+
+}
+
+inline static unsigned short
+crc16_acc(unsigned short crc, unsigned int b)
+{
+	return (crc << 8) ^ crc16tbl[(crc >> 8) ^ b];
+}
+
+static void sd_initcrc(struct sdcore *sd)
+{
+	int i;
+	
+	for (i = 0; i < 4; i++) {
+		sd->sd_crctmp[i] = 0;
+		sd->sd_crcs[i] = 0;
+	}
+	sd->sd_crcseq = 6;
+}
+
+static void sd_1bit_feedcrc(struct sdcore *sd, unsigned int dat)
+{
+	sd->sd_crcs[0] = crc16_acc(sd->sd_crcs[0], dat);
+}
+
+static void sd_4bit_feedcrc(struct sdcore *sd, unsigned int dat)
+{
+	unsigned int a = 0, b = 0, c = 0, d = 0;
+	unsigned int shift = (sd->sd_crcseq & 0x7);
+
+	a = sd->sd_crctmp[0];
+	b = sd->sd_crctmp[1];
+	c = sd->sd_crctmp[2];
+	d = sd->sd_crctmp[3];
+
+	a |= destagger[dat] << shift;
+	dat >>= 1;
+	b |= destagger[dat] << shift;
+	dat >>= 1;
+	c |= destagger[dat] << shift;
+	dat >>= 1;
+	d |= destagger[dat] << shift;
+
+	if (shift == 0) {
+		sd->sd_crcs[0] = crc16_acc(sd->sd_crcs[0], a);
+		sd->sd_crcs[1] = crc16_acc(sd->sd_crcs[1], b);
+		sd->sd_crcs[2] = crc16_acc(sd->sd_crcs[2], c);
+		sd->sd_crcs[3] = crc16_acc(sd->sd_crcs[3], d);
+		a = b = c = d = 0;
+	}
+
+	sd->sd_crcseq -= 2;
+	sd->sd_crctmp[0] = a;
+	sd->sd_crctmp[1] = b;
+	sd->sd_crctmp[2] = c;
+	sd->sd_crctmp[3] = d;
+}
+
+/* This should be called 8 times to get the full 8 bytes of CRC generated */
+static unsigned int sd_4bit_getcrc(struct sdcore *sd)
+{
+	static const unsigned char restaggertbl[4] = { 0x0, 0x1, 0x10, 0x11 };
+	static const unsigned char restaggertbl_lsl1[4] =
+		{ 0x0, 0x2, 0x20, 0x22 };
+	static const unsigned char restaggertbl_lsl2[4] =
+		{ 0x0, 0x4, 0x40, 0x44 };
+	static const unsigned char restaggertbl_lsl3[4] =
+		{ 0x0, 0x8, 0x80, 0x88 };
+	unsigned int ret;
+
+	ret = restaggertbl[sd->sd_crcs[0] >> 14];
+	sd->sd_crcs[0] <<= 2;
+	ret |= restaggertbl_lsl1[sd->sd_crcs[1] >> 14];
+	sd->sd_crcs[1] <<= 2;
+	ret |= restaggertbl_lsl2[sd->sd_crcs[2] >> 14];
+	sd->sd_crcs[2] <<= 2;
+	ret |= restaggertbl_lsl3[sd->sd_crcs[3] >> 14];
+	sd->sd_crcs[3] <<= 2;
+
+	return ret;
+}
+
+/* This should be called 2 times to get the full 2 bytes of CRC generated */
+static unsigned int sd_1bit_getcrc(struct sdcore *sd)
+{
+	unsigned int ret;
+
+	ret = sd->sd_crcs[0] >> 8;
+	sd->sd_crcs[0] = (sd->sd_crcs[0] & 0xff) << 8;
+	return ret;
+}
+
+static inline void datssp_feedcrc(struct sdcore *sd, unsigned int dat)
+{
+	if (!(sd->sd_state & DATSSP_NOCRC)) {
+		if (sd->sd_state & DATSSP_4BIT) sd_4bit_feedcrc(sd, dat);
+		else sd_1bit_feedcrc(sd, dat);
+	}
+}
+
+static inline unsigned int datssp_getcrc(struct sdcore *sd)
+{
+	unsigned int ret = 0;
+
+	if (!(sd->sd_state & DATSSP_NOCRC)) {
+		if (sd->sd_state & DATSSP_4BIT) ret = sd_4bit_getcrc(sd);
+		else ret = sd_1bit_getcrc(sd);
+	}
+	return ret;
+}
+
+static inline unsigned int
+crc7(unsigned int crc, const unsigned int *pc, unsigned int len)
+{
+	unsigned int i;
+	unsigned char ibit;
+	unsigned char c;
+
+	for (i = 0; i < len; i++, pc++) {
+		c = *pc;
+		for (ibit = 0; ibit < 8; ibit++) {
+			crc <<= 1;
+			if ((c ^ crc) & 0x80) crc ^= 0x09;
+
+			c <<= 1;
+		}
+
+		crc &= 0x7F;
+	}
+
+	return crc;
+}
+
+static inline void
+mkcommand(unsigned int cmdidx, unsigned int arg, unsigned int *retcmd)
+{
+	retcmd[0] = cmdidx;
+	retcmd[1] = arg >> 24;
+	retcmd[2] = arg >> 16;
+	retcmd[3] = arg >> 8;
+	retcmd[4] = arg;
+	retcmd[5] = (0x1 | (crc7(0, retcmd, 5) << 1));
+}
+
+static inline void reset_timeout(struct sdcore *sd) {
+	sd->sd_timeout = 0;
+	if (sd->os_reset_timeout) sd->os_reset_timeout(sd); 
+}
+
+static inline int timeout(struct sdcore *sd) {
+	if (sd->sd_timeout > 1000000) return 1;
+	else if (sd->os_timeout) return sd->os_timeout(sd);
+	else sd->sd_timeout++;
+	return 0;
+}
+
+static
+unsigned int sdsize(struct sdcore *sd)
+{
+	unsigned int csize, csize_mult, rd_bl_len;
+
+	if (sd->sd_sz != 0) return sd->sd_sz;
+
+	if (sd->sd_csd[1] & 0xc0) {
+		csize = (sd->sd_csd[10] | (sd->sd_csd[9] << 8));
+		sd->sd_sz = (csize + 1) * 1024;
+	} else {
+	        rd_bl_len = 1 << ((sd->sd_csd[6] & 0xf) - 9);
+		csize = ((sd->sd_csd[7] & 0x03) << 10) | 
+		  ((sd->sd_csd[8] << 2) | ((sd->sd_csd[9] & 0xc0) >> 6));
+		csize_mult = ((sd->sd_csd[10] & 0x03) << 1) | 
+		  ((sd->sd_csd[11] & 0x80) >> 7);
+		sd->sd_sz = (csize + 1) * (1 << (csize_mult + 2)) * rd_bl_len;
+	}
+	return sd->sd_sz;
+}
+
+static unsigned int tend_ssp(struct sdcore *sd, unsigned int **cmdresp, 
+  unsigned char **dat) {
+	unsigned int d;
+	unsigned int s = SDPEEK8(sd, SDSTATE);
+
+	if (s & 0x8) {
+		if (sd->sd_state & SDCMD_RX) {
+			d = SDPEEK8(sd, SDCMD);
+			if (cmdresp) {
+				**cmdresp = d;
+				*cmdresp = *cmdresp + 1;
+				reset_timeout(sd);
+			}
+		} else if (sd->sd_state & SDCMD_TX) {
+			SDPOKE8(sd, SDCMD, **cmdresp);
+			*cmdresp = *cmdresp + 1;
+			reset_timeout(sd);
+		}
+	}
+
+	if (s & 0x10) {
+		if (sd->sd_state & SDDAT_RX) {
+			d = SDPEEK8(sd, SDDAT);
+			if (dat) {
+				**dat = d;
+				*dat = *dat + 1;
+				reset_timeout(sd);
+			}
+		} else if (sd->sd_state & SDDAT_TX) {
+			reset_timeout(sd);
+			if (dat) {
+				d = **dat;
+				*dat = *dat + 1;
+				SDPOKE8(sd, SDDAT, d);
+				datssp_feedcrc(sd, d);
+			} else {
+				d = datssp_getcrc(sd);
+				SDPOKE8(sd, SDDAT, d);
+			}
+		}
+	}
+
+	return s;
+}
+
+static int
+error(unsigned int *resp, unsigned short req)
+{
+	unsigned int crc, status;
+
+	if ((req & 0x3f) != resp[0]) return 1;
+
+	crc = (0x1 | (crc7(0, resp, 5) << 1));
+	if (crc != resp[5]) return 1;
+
+	status = resp[1] << 24;
+	status |= resp[2] << 16;
+	status |= resp[3] << 8;
+	status |= resp[4];
+
+	return status & 0xfdf90008;
+}
+
+static int
+sdcmd2(struct sdcore *sd, unsigned short req, unsigned int arg, 
+  unsigned int *resp, unsigned char **dat)
+{
+	unsigned int i, j, s, cmdresp[17];
+	unsigned int resplen;
+	unsigned int type = (req >> 8);
+	unsigned int cmdidx = req; 
+	unsigned int *cmdptr = cmdresp;
+	unsigned int *respptr;
+	unsigned int dly;
+	int ok32 = (sd->hw_version == 2);
+	int ok16 = (ok32 || (sd->hw_version == 3));
+	int sddat2_8;
+
+	// If no space for response provided by caller, use local buffer
+	if (resp == NULL) resp = cmdresp;
+	respptr = resp;
+
+	if (activate(sd)) return 1;
+
+	dly = sd->sd_state & SD_LOSPEED;
+
+	if (!dly) {
+		unsigned int x;
+		SDPOKE8(sd, SDGPIO, 0xbf);
+#ifdef BIGENDIAN
+		x = (cmdidx & 0xff);
+		x |= ((arg >> 24) & 0xff) << 8;
+		x |= ((arg >> 16) & 0xff) << 16;
+		x |= ((arg >> 8) & 0xff) << 24;
+		if (ok32) SDPOKE32(sd, SDCMD2, x);
+		else if (ok16) {
+			SDPOKE16(sd, SDCMD2, x);
+			SDPOKE16(sd, SDCMD2, x >> 16);
+		} else {
+			SDPOKE8(sd, SDCMD2, x);
+			SDPOKE8(sd, SDCMD2, x >> 8);
+			SDPOKE8(sd, SDCMD2, x >> 16);
+			SDPOKE8(sd, SDCMD2, x >> 24);
+		}
+#else
+		x = (cmdidx & 0xff) << 24;
+		x |= ((arg >> 24) & 0xff) << 16;
+		x |= ((arg >> 16) & 0xff) << 8;
+		x |= ((arg >> 8) & 0xff);
+		if (ok32) SDPOKE32(sd, SDCMD2, x);
+		else if (ok16) {
+			SDPOKE16(sd, SDCMD2, x >> 16);
+			SDPOKE16(sd, SDCMD2, x);
+		} else {
+			SDPOKE8(sd, SDCMD2, x >> 24);
+			SDPOKE8(sd, SDCMD2, x >> 16);
+			SDPOKE8(sd, SDCMD2, x >> 8);
+			SDPOKE8(sd, SDCMD2, x);
+		}
+#endif
+		SDPOKE8(sd, SDCMD2, arg);
+	} else {
+		// Build command packet
+		mkcommand(cmdidx, arg, cmdptr);
+
+		// Send command
+		for (i = 0; i < 6; i++) {
+			unsigned int b = *cmdptr++;
+			unsigned int x;
+	
+			if (timeout(sd)) break;
+			for (j = 0; j < 8; j++) {
+				x = 0x8f | ((b & 0x80) >> 3);
+				b = b << 1;
+				SDPOKE8(sd, SDGPIO, x); // clk negedge
+				SDPEEK8(sd, SDGPIO);    // delay
+				SDPEEK8(sd, SDGPIO);    // delay 
+				x |= 0x20; 
+				SDPOKE8(sd, SDGPIO, x); // clk posedge
+				SDPEEK8(sd, SDGPIO);    // delay
+				SDPEEK8(sd, SDGPIO);    // delay
+			}
+		}
+	}
+
+	if (type == TYPE_NORESP) goto done;
+	else if (type == TYPE_RXDAT_IGNRESP) goto ignresp;
+	else if (type == TYPE_LONGRESP) resplen = 17;
+	else resplen = 6;
+
+	// clock until start bit on CMD pin
+	while(1) {
+		if (timeout(sd)) {
+			goto done;
+		}
+		if (req == CMD_SEND_IF_COND) sd->sd_timeout += 100000;
+		SDPOKE8(sd, SDGPIO, 0xdf); // clk negedge
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		s = SDPEEK8(sd, SDGPIO);   // sample
+		if ((s & 0x10) == 0x0) break;
+		SDPOKE8(sd, SDGPIO, 0xff); // clk posedge
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+	} 
+	reset_timeout(sd);
+
+	// Next we receive the response. 
+	if (ok16 && !ok32) sddat2_8 = SDDAT2 + 1;
+	else sddat2_8 = SDDAT2;
+	if (dly) for (i = 0; i < resplen; i++) {
+		unsigned int r = 0;
+
+		for (j = 0; j < 8; j++) {
+			SDPOKE8(sd, SDGPIO, 0xdf); // clk negedge
+			SDPEEK8(sd, SDGPIO);       // delay
+			s = SDPEEK8(sd, SDGPIO);   // sample
+			SDPOKE8(sd, SDGPIO, 0xff); // clk posedge
+			SDPEEK8(sd, SDGPIO);       // delay
+			SDPEEK8(sd, SDGPIO);       // delay
+			r = r << 1;
+			r |= ((s & 0x10) >> 4);
+		}
+	
+		*respptr++ = r;
+	} else while (resplen > 0) {
+		unsigned int r;
+
+#ifdef BIGENDIAN
+		if (ok32 && resplen >= 4) {
+			r = SDPEEK32(sd, SDCMD2);
+			*respptr++ = r & 0xff;
+			*respptr++ = (r >> 8) & 0xff;
+			*respptr++ = (r >> 16) & 0xff;
+			*respptr++ = (r >> 24);
+			resplen -= 4;
+		} else if (ok16 && resplen >= 2) {
+			r = SDPEEK16(sd, SDCMD2);	
+			*respptr++ = r & 0xff;
+			*respptr++ = (r >> 8) & 0xff;
+			
+			resplen -= 2;
+		} else {
+			*respptr++ = SDPEEK8(sd, sddat2_8);
+			resplen--;
+		}
+#else
+		if (ok32 && resplen >= 4) {
+			r = SDPEEK32(sd, SDCMD2);
+			*respptr++ = (r >> 24);
+			*respptr++ = (r >> 16) & 0xff;
+			*respptr++ = (r >> 8) & 0xff;
+			*respptr++ = r & 0xff;
+			resplen -= 4;
+		} else if (ok16 && resplen >= 2) {
+			r = SDPEEK16(sd, SDCMD2);	
+			*respptr++ = (r >> 8) & 0xff;
+			*respptr++ = r & 0xff;
+			resplen -= 2;
+		} else {
+			*respptr++ = SDPEEK8(sd, sddat2_8);
+			resplen--;
+		}
+#endif
+	}
+	if (type == TYPE_BSYRESP) {
+		s = 0;
+		while ((s & 0x7) != 0x7) {
+			if (timeout(sd)) break;
+			SDPOKE8(sd, SDGPIO, 0x9f);  // clk negedge
+			if (dly) SDPEEK8(sd, SDGPIO);        // delay
+			s = s << 1;
+			s |= SDPEEK8(sd, SDGPIO) & 0x1;
+			SDPOKE8(sd, SDGPIO, 0xbf);
+			if (dly) SDPEEK8(sd, SDGPIO);
+		}
+	}
+
+ignresp:
+
+	if (type == TYPE_ABORT) 
+		sd->sd_state &= ~(SDDAT_RX|SDDAT_TX);
+
+#ifndef SD_READONLYDMA
+	if (type == TYPE_TXDAT) {
+		sd->sd_state |= SDDAT_TX;
+		/* 2 clocks for nWR */
+		SDPOKE8(sd, SDGPIO, 0xdf); // clk negedge
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay 
+		SDPOKE8(sd, SDGPIO, 0xff); // clk posedge
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		SDPOKE8(sd, SDGPIO, 0xdf); // clk negedge
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay 
+		SDPOKE8(sd, SDGPIO, 0xff); // clk posedge
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		if (sd->sd_state & DATSSP_4BIT)
+			SDPOKE8(sd, SDGPIO, 0x10); // assert start, clk negedge
+		else
+			SDPOKE8(sd, SDGPIO, 0x1e);
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay 
+		if (sd->sd_state & DATSSP_4BIT)
+			SDPOKE8(sd, SDGPIO, 0x30); // clk posedge
+		else
+			SDPOKE8(sd, SDGPIO, 0x3e);
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+		if (dly) SDPEEK8(sd, SDGPIO);       // delay
+	}
+#endif
+
+	if (type == TYPE_RXDAT || type == TYPE_RXDAT_IGNRESP) 
+	  sd->sd_state |= SDDAT_RX;
+
+done:
+	// 8 clocks before stopping
+	if (!(sd->sd_state & (SDDAT_TX|SDDAT_RX))) {
+		if (dly) for (i = 0; i < 8; i++) {
+			SDPOKE8(sd, SDGPIO, 0xdf);
+			SDPEEK8(sd, SDGPIO);       // delay
+			SDPEEK8(sd, SDGPIO);       // delay 
+			SDPOKE8(sd, SDGPIO, 0xff);
+			SDPEEK8(sd, SDGPIO);       // delay
+			SDPEEK8(sd, SDGPIO);       // delay
+		} else {
+			SDPOKE8(sd, SDGPIO, 0xff);
+			SDPOKE8(sd, SDCMD2, 0xff);
+		}
+	}
+	if (timeout(sd)) return 1;
+	else return 0;
+
+}
+
+
+static int
+sdcmd(struct sdcore *sd, unsigned short req, unsigned int arg, 
+  unsigned int *resp, unsigned char **dat)
+{
+	unsigned int s, cmdresp[17];
+	unsigned int resplen;
+	unsigned int type = (req >> 8);
+	unsigned int cmdidx = req; 
+	unsigned int *cmdptr = cmdresp;
+	unsigned int *cmd = cmdresp;
+	unsigned int *respptr;
+	unsigned int ndat;
+
+	if (sd->hw_version != 0) return sdcmd2(sd, req, arg, resp, dat);
+
+	// If no space for response provided by caller, use local buffer
+	if (resp == NULL) resp = cmdresp;
+	respptr = resp;
+
+	// Before continuing, we must wait for the FSM to get to the
+	// S_SEND_CMD state.  After a previous command, we may still be
+	// in S_DUMMY_CLK or in case of an ABORT, we may be in the middle of
+	// clocking a byte for TX or RX.
+	s = SDPEEK8(sd, SDSTATE);
+	while ((s & 0x7) != S_SEND_CMD) {
+		if (timeout(sd)) break;
+		s = SDPEEK8(sd, SDSTATE);
+	}
+
+	// We know we're in S_SEND_CMD, but we may need to change the
+	// command type.  This won't cause a state change.  
+	if ((s & 0xe7) != (S_SEND_CMD | (type << 5)))
+		SDPOKE8(sd, SDSTATE, S_SEND_CMD | (type << 5));
+
+	// Build command packet
+	mkcommand(cmdidx, arg, cmdptr);
+
+	// Next, we loop while tending the SSPs until we get our last
+	// byte of command data out.  We may get a few bytes from the DAT
+	// SSP if we are aborting a previous data transfer command.  If we do
+	// those get placed in a buffer or thrown away based on the callers
+	// "dat" parameter.
+	sd->sd_state |= SDCMD_TX;
+	while ((cmdptr - cmd) != 6) {
+		if (timeout(sd)) break;
+		s = tend_ssp(sd, &cmdptr, dat);
+	}
+	sd->sd_state &= ~SDCMD_TX;
+
+	// If we got out of sync with the hardware, that would be bad.
+	// The hardware should still be in S_SEND_CMD for the last CMDSSP
+	// byte.
+	if ((s & 0x7) != S_SEND_CMD) {
+		SDPOKE8(sd, SDSTATE, S_OFF);
+		return 1;
+	}
+
+	if (type == TYPE_NORESP) goto done;
+	else if (type == TYPE_LONGRESP) resplen = 17;
+	else resplen = 6;
+
+	// Next state should be S_WAIT_RESP or S_RX_RESP.  We may get 
+	// more bytes from the DATSSP while shifting out our last bits of cmd
+	while (((s & 0x7) != S_WAIT_RESP) && ((s & 0x7) != S_RX_RESP)) {
+		if (timeout(sd)) break;
+		if (req == CMD_SEND_IF_COND) sd->sd_timeout += 1000;
+		s = tend_ssp(sd, NULL, dat);
+	}
+	
+	// Once we're in S_WAIT_RESP or S_RX_RESP though, the DATSSP is only
+	// active for 2 more clocks at the beginning of the S_WAIT_RESP state.
+	// This is enough for one more byte in 4-bit mode, though we may have
+	// 2 bytes already in our DATSSP.
+	if (sd->sd_state & (SDDAT_RX|SDDAT_TX)) {
+		do {
+			if (timeout(sd)) break;
+			s = tend_ssp(sd, NULL, dat);
+		} while (!(s & 0x18));
+
+		// We've now read/wrote one more byte to the DATSSP
+		// which should allow our FSM to advance to the RX_RESP state.
+		// If we pick up more than 2 more DATSSP bytes, something is
+		// wrong.
+		ndat = 0;
+		while ((s & 0x7) != S_RX_RESP) {
+			if (timeout(sd) || ndat > 2) break;
+			s = tend_ssp(sd, NULL, dat);
+			if (s & 0x10) ndat++;
+		}
+
+		if (ndat > 2) {
+			SDPOKE8(sd, SDSTATE, S_OFF);
+			return 1;
+		}
+	}
+
+	// We're now done with whatever business we had remaining with the
+	// previous command's DATSSP transfer since we've either just got our 
+	// first byte of response or our last byte of data
+	sd->sd_state &= ~(SDDAT_RX|SDDAT_TX);
+	if (type == TYPE_RXDAT) sd->sd_state |= SDDAT_RX;
+
+	// Next we receive the response.  If this is TYPE_RXDAT command,
+	// or an abortion of a previous TYPE_RXDAT command, we may get a 
+	// few bytes from the DAT SSP also.
+	sd->sd_state |= SDCMD_RX;
+	while ((respptr - resp) != resplen) {
+		if (timeout(sd)) break;
+		s = tend_ssp(sd, &respptr, dat);
+		if ((s & 0x10) && (resp == respptr)) {
+			SDPOKE8(sd, SDSTATE, S_OFF);
+			sd->sd_state &= ~(SDCMD_RX|SDDAT_RX);
+			return 1;
+		}
+	}
+	sd->sd_state &= ~SDCMD_RX;
+
+	if (type == TYPE_ABORT) 
+		sd->sd_state &= ~(SDDAT_RX|SDDAT_TX);
+
+	if (type == TYPE_TXDAT) sd->sd_state |= SDDAT_TX;
+
+done:
+	if (timeout(sd)) return 1;
+	else return 0;
+
+}
+
+static int datssp_stream2(struct sdcore *sd, unsigned char **dat,
+  unsigned int buflen)
+{
+	unsigned char *d;
+	int ret;
+#ifndef SD_READONLYDMA
+	int ok32;
+	int ok16;
+	int sddat2_8;
+	unsigned int x;
+#endif
+
+	if (sd->os_dmastream /* && (sd->sd_state & SDDAT_RX) */) {
+		d = dat ? *dat : NULL;
+		ret = sd->os_dmastream(sd->os_arg, d, buflen);
+		if (!ret && d) *dat += buflen;
+		return ret;
+	}
+
+#ifndef SD_READONLYDMA
+	d = *dat;
+
+	while (buflen > 512) {
+		datssp_stream2(sd, dat, 512);
+		if (sd->os_irqwait) sd->os_irqwait(sd->os_arg, 1);
+		buflen -= 512;
+		d = *dat;
+	}
+
+	ok32 = (sd->hw_version == 2);
+	ok16 = (ok32 || (sd->hw_version == 3));
+	if (ok16 && !ok32) sddat2_8 = SDDAT2 + 1;
+	else sddat2_8 = SDDAT2;
+
+	if (sd->sd_state & SDDAT_RX) {
+
+		while (((int)d & 0x1) || buflen == 1) {
+			*d++ = SDPEEK8(sd, sddat2_8);
+			buflen--;
+		}
+	
+		if (((int)d & 0x2) && buflen >= 2) {
+			if (ok16) *(unsigned short *)(d) = SDPEEK16(sd, SDDAT2);
+			else {
+#ifdef BIGENDIAN
+				x = SDPEEK8(sd, sddat2_8) << 8;
+				x |= SDPEEK8(sd, sddat2_8);
+#else
+				x = SDPEEK8(sd, sddat2_8);
+				x |= SDPEEK8(sd, sddat2_8) << 8;
+#endif
+				*(unsigned short *)(d) = x;
+			}
+			buflen -= 2;
+			d += 2;
+		}
+
+		if (ok32) while (buflen >= 4) {
+			*(unsigned int *)(d) = SDPEEK32(sd, SDDAT2);
+			buflen -= 4;
+			d += 4;
+		} else if (ok16) while (buflen >= 4) {
+#ifdef BIGENDIAN
+			x = SDPEEK16(sd, SDDAT2) << 16;
+			x |= SDPEEK16(sd, SDDAT2);
+#else
+			x = SDPEEK16(sd, SDDAT2);
+			x |= SDPEEK16(sd, SDDAT2) << 16;
+#endif
+			buflen -= 4;
+			*(unsigned int *)(d) = x;
+			d += 4;
+		} else while (buflen >= 4) {
+#ifdef BIGENDIAN
+			x = SDPEEK8(sd, sddat2_8) << 24;
+			x |= SDPEEK8(sd, sddat2_8) << 16;
+			x |= SDPEEK8(sd, sddat2_8) << 8;
+			x |= SDPEEK8(sd, sddat2_8);
+#else
+			x = SDPEEK8(sd, sddat2_8);
+			x |= SDPEEK8(sd, sddat2_8) << 8;
+			x |= SDPEEK8(sd, sddat2_8) << 16;
+			x |= SDPEEK8(sd, sddat2_8) << 24;
+#endif
+			buflen -= 4;
+			*(unsigned int *)(d) = x;
+			d += 4;
+		}
+	} else {
+		while (((int)d & 0x1) || buflen == 1) {
+			SDPOKE8(sd, SDDAT2, *d++);
+			buflen--;
+		}
+	
+		if (((int)d & 0x2) && buflen >= 2) {
+			if (ok16) SDPOKE16(sd, SDDAT2, *(unsigned short *)(d));
+			else {
+				x = *(unsigned short *)(d);
+#ifdef BIGENDIAN
+				SDPOKE8(sd, SDDAT2, x >> 8); 
+				SDPOKE8(sd, SDDAT2, x); 
+#else
+				SDPOKE8(sd, SDDAT2, x); 
+				SDPOKE8(sd, SDDAT2, x >> 8); 
+#endif
+			}
+			buflen -= 2;
+			d += 2;
+		}
+
+		if (ok32) while (buflen >= 4) {
+			SDPOKE32(sd, SDDAT2, *(unsigned int *)(d));
+			buflen -= 4;
+			d += 4;
+		} else if (ok16) while (buflen >= 4) {
+			x = *(unsigned int *)(d);
+			buflen -= 4;
+			d += 4;
+#ifdef BIGENDIAN
+			SDPOKE16(sd, SDDAT2, x >> 16);
+			SDPOKE16(sd, SDDAT2, x);
+#else
+			SDPOKE16(sd, SDDAT2, x);
+			SDPOKE16(sd, SDDAT2, x >> 16);
+#endif
+		} else while (buflen >= 4) {
+			x = *(unsigned int *)(d);
+			buflen -= 4;
+			d += 4;
+#ifdef BIGENDIAN
+			SDPOKE8(sd, SDDAT2, x >> 24);
+			SDPOKE8(sd, SDDAT2, x >> 16);
+			SDPOKE8(sd, SDDAT2, x >> 8);
+			SDPOKE8(sd, SDDAT2, x);
+#else
+			SDPOKE8(sd, SDDAT2, x);
+			SDPOKE8(sd, SDDAT2, x >> 8);
+			SDPOKE8(sd, SDDAT2, x >> 16);
+			SDPOKE8(sd, SDDAT2, x >> 24);
+#endif
+		}
+	}
+
+	*dat = d;
+
+	if (buflen > 0) return datssp_stream2(sd, dat, buflen);
+	else return 0;
+#else
+	return 0;
+#endif
+}
+
+static int datssp_stream(struct sdcore *sd, unsigned char **dat, 
+  unsigned int buflen)
+{
+	unsigned int s, t, byte = 0;
+	unsigned char *d;
+
+	if (((sd->sd_state & SDDAT_RX) && sd->os_dmastream) /* ||
+	  ((sd->sd_state & SDDAT_TX) && sd->os_dmastream && dat) */ ) {
+		unsigned char *d = dat ? *dat : NULL;
+		int ret = sd->os_dmastream(sd->os_arg, d, buflen);
+		if (!ret && d) *dat += buflen;
+		return ret;
+	}
+
+	if (sd->hw_version > 0) return datssp_stream2(sd, dat, buflen);
+
+	while (buflen) {
+		if (timeout(sd)) return 1;
+		s = tend_ssp(sd, NULL, dat);
+		if (s & 0x10) {
+			buflen--;
+			if (byte++ > 7) {
+				if (sd->sd_state & SDDAT_RX)
+				  goto fastrx;
+				else goto fasttx;
+			}
+		} 
+	}
+
+	// Now we can go faster (PIO)
+fastrx:
+	if (dat) {
+		d = *dat;
+		while (buflen) {
+			s = SDPEEK8(sd, SDDAT);
+			*d = s;
+			buflen--;
+			d++;
+		}
+		*dat = d;
+	} else {
+		while (buflen--) SDPEEK8(sd, SDDAT);
+	}
+	return 0;
+
+fasttx:
+	if (dat) {
+		d = *dat;
+		while (buflen) {
+			t = *d;
+			SDPOKE8(sd, SDDAT, t);
+			buflen--;
+			d++;
+			datssp_feedcrc(sd, t);
+		}
+		*dat = d;
+	} else {
+		while (buflen--) SDPOKE8(sd, SDDAT, datssp_getcrc(sd));
+	}
+	return 0;
+}
+
+static int stop(struct sdcore *sd)
+{
+	int ret;
+	unsigned int resp[6];
+
+	if (sd->hw_version) return stop2(sd);
+
+	if (sd->parked_sector) {
+		if (sd->sd_state & SDDAT_TX) {
+			/* wait to get out of S_WAIT_BUSY */
+			while ((SDPEEK8(sd, SDSTATE) & 0x7) != S_TX_WRITE) 
+			  if (timeout(sd)) break;
+
+			/* abort parked write */
+			SDPOKE8(sd, SDSTATE, S_SEND_CMD | (TYPE_ABORT << 5));
+			sd->sd_state &= ~SDDAT_TX;
+			sd->sd_state |= SDDAT_RX;
+			ret = sdcmd(sd, CMD_STOP_TRANSMISSION, 0, resp, NULL);
+			sd->sd_state &= ~SDDAT_RX;
+			SDPOKE8(sd, SDSTATE, S_WAIT_BUSY | (TYPE_BSYRESP << 5));
+		} else {
+			/* abort parked read */
+			SDPOKE8(sd, SDSTATE, S_SEND_CMD | (TYPE_ABORT << 5));
+			ret = sdcmd(sd, CMD_STOP_TRANSMISSION, 0, resp, NULL);
+		}
+		sd->parked_sector = 0;
+		if (ret || error(resp, CMD_STOP_TRANSMISSION) || timeout(sd))
+		  return 1;
+	}
+	return 0;
+}
+
+static int stop2(struct sdcore *sd)
+{
+	int ret;
+	unsigned int resp[6];
+
+	if (sd->parked_sector) {
+		if (sd->os_irqwait) sd->os_irqwait(sd->os_arg, 0);
+		if (sd->sd_state & SDDAT_TX) {
+			/* abort parked write */
+		 	ret = sdcmd2(sd, CMD_STOP_TRANSMISSION, 0, resp, NULL);
+			SDPOKE8(sd, SDCTRL2, 0x0);
+			if (sd->os_irqwait) sd->os_irqwait(sd->os_arg, 5);
+			SDPOKE8(sd, SDGPIO, 0xff);
+
+			/*
+			while ((SDPEEK8(sd, SDGPIO) & 0xf) != 0xf) {
+				sd->os_delay(sd->os_arg, 1);
+				SDPOKE8(sd, SDGPIO, 0xdf);
+				SDPOKE8(sd, SDGPIO, 0xff);
+				if (timeout(sd)) return 1;
+			}
+			*/
+			reset_timeout(sd);
+		} else {
+			/* abort parked read */
+			ret = sdcmd2(sd, CMD_STOP_TRANSMISSION, 0, resp, NULL);
+		}
+		sd->parked_sector = 0;
+		if (ret || error(resp, CMD_STOP_TRANSMISSION) || timeout(sd)) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int do_read2(struct sdcore *sd, unsigned int sector, struct sdiov *iov, 
+  unsigned int iovcnt)
+{
+	unsigned int ret, n, s, sz;
+	unsigned char *datptr, *dat;
+
+	if (iovcnt == 0) return 0;
+
+	if (activate(sd)) return 1;
+
+	n = iov->sdiov_nsect;
+	datptr = dat = iov->sdiov_base;
+	sz = sdsize(sd);
+	if (sector >= sz) return 0;
+
+	if (sd->parked_sector) {
+		if (!(sd->sd_state & SDDAT_TX) && sd->parked_sector == sector) {
+			if (sd->os_irqwait && !sd->os_dmastream)
+			  sd->os_irqwait(sd->os_arg, 3);
+			goto receive;
+		}
+		
+		stop2(sd);
+	}
+
+	if (sd->sd_state & SD_HC) 
+	  ret = sdcmd2(sd, CMD_READ_MULTIPLE_BLOCK2, sector, NULL, NULL);
+	else
+	  ret = sdcmd2(sd, CMD_READ_MULTIPLE_BLOCK2, sector * 512, NULL, NULL);
+
+	do {
+		if (timeout(sd)) return 1;;
+		SDPOKE8(sd, SDGPIO, 0xdf);
+		s = SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, 0xff);
+	} while ((s & 0xf) != 0x0);
+	reset_timeout(sd);
+
+receive:
+	if (sd->os_dmaprep && sd->os_dmastream)
+	  sd->os_dmaprep(sd->os_arg, datptr, n * 512);
+
+	SDPOKE8(sd, SDGPIO, 0xdf);
+	sd->parked_sector = sector + n;
+
+nextiov:
+	if (sd->parked_sector > sz) {
+		n -= sd->parked_sector - sz;
+		sd->parked_sector = sz;
+	}
+	datssp_stream2(sd, &datptr, n * 512);
+
+	if (--iovcnt) {
+		++iov;
+		n = iov->sdiov_nsect;
+		datptr = iov->sdiov_base;
+		sd->parked_sector += n;
+		if (sd->os_dmaprep && sd->os_dmastream)
+		  sd->os_dmaprep(sd->os_arg, datptr, n * 512);
+		goto nextiov;
+	} 
+
+	/* s = SDPEEK8(sd, SDSTAT2);
+	if (s & 0x44) {
+		sd->sd_timeout = 1000001;
+		return 1;
+	}
+	else */ return 0;
+}
+
+static int do_read(struct sdcore *sd, unsigned int sector, struct sdiov *iov, 
+  unsigned int iovcnt)
+{
+	unsigned int resp[6], ret, n, sz;
+	unsigned char *datptr, *dat;
+
+	if (iovcnt == 0) return 0;
+
+	n = iov->sdiov_nsect;
+	datptr = dat = iov->sdiov_base;
+	sz = sdsize(sd);
+	if (sector >= sz) return 0;
+
+	if (sd->parked_sector) {
+		if (!(sd->sd_state & SDDAT_TX) && sd->parked_sector == sector) 
+		  goto receive;
+		
+		stop(sd);
+	}
+
+	if (sd->sd_state & SD_HC)
+	  ret = sdcmd(sd, CMD_READ_MULTIPLE_BLOCK, sector, resp, &datptr);
+	else
+	  ret = sdcmd(sd, CMD_READ_MULTIPLE_BLOCK, sector * 512, resp, &datptr);
+	if (ret || error(resp, CMD_READ_MULTIPLE_BLOCK)) return 1;
+
+receive:
+	if (sd->os_dmaprep && sd->os_dmastream)
+	  sd->os_dmaprep(sd->os_arg, datptr, n * 512 - (datptr - dat));
+
+	datssp_stream(sd, &datptr, 512 - (datptr - dat));
+	datssp_stream(sd, NULL, 6);
+
+	sd->parked_sector = sector + n;
+	if (sd->parked_sector > sz) {
+		n -= sd->parked_sector - sz;
+		sd->parked_sector = sz;
+	}
+	n--;
+
+nextiov:
+	while (n--) {
+		SDPOKE8(sd, SDSTATE, S_WAIT_RESP | (TYPE_RXDAT << 5));
+		datssp_stream(sd, NULL, 2); // last part of prev CRC
+		datssp_stream(sd, &datptr, 512);
+		datssp_stream(sd, NULL, 6); // first part of CRC
+	}
+
+	if (--iovcnt) {
+		++iov;
+		n = iov->sdiov_nsect;
+		datptr = iov->sdiov_base;
+		sd->parked_sector += n;
+		if (sd->parked_sector > sz) {
+			n -= sd->parked_sector - sz;
+			sd->parked_sector = sz;
+		}
+		if (sd->os_dmaprep && sd->os_dmastream && n > 0)
+		  sd->os_dmaprep(sd->os_arg, datptr, n * 512);
+		goto nextiov;
+	} 
+
+	SDPOKE8(sd, SDSTATE, S_WAIT_RESP | (TYPE_RXDAT << 5));
+	datssp_stream(sd, NULL, 2); // last part of prev CRC
+	return 0;
+}
+
+static int do_write2(struct sdcore *sd, unsigned int sector, struct sdiov *iov, 
+  unsigned int iovcnt)
+{
+	unsigned char *datptr;
+	unsigned int resp[6], ret, n, s, sz, ss;
+
+	if (sd->sd_wprot) return 1;
+
+	if (iovcnt == 0) return 0;
+	
+	if (activate(sd)) return 1;
+
+	sz = sdsize(sd);
+	if (sector >= sz) return 0;
+
+	if (sd->os_powerok) {
+		int ok = sd->os_powerok(sd);
+		if (!ok && sd->parked_sector) {
+			stop2(sd);
+			return 1;
+		} else if (!ok) return 1;
+	}
+
+	if (sd->parked_sector) {
+		if ((sd->sd_state & SDDAT_TX) && sd->parked_sector == sector)
+		  goto transmit;
+		
+		stop2(sd);
+	}
+
+	if (sd->sd_erasehint) {
+		sdcmd2(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+		sdcmd2(sd, ACMD_SET_WR_BLK_ERASE_COUNT, sd->sd_erasehint, 
+		  NULL, NULL);
+		sd->sd_erasehint = 0;
+	}
+
+	if (sd->sd_state & SD_HC)
+	  ret = sdcmd2(sd, CMD_WRITE_MULTIPLE_BLOCK, sector, resp, NULL);
+	else
+	  ret = sdcmd2(sd, CMD_WRITE_MULTIPLE_BLOCK, sector * 512, resp, NULL);
+	if (ret || error(resp, CMD_WRITE_MULTIPLE_BLOCK)) {
+		return 1;
+	}
+	sd->parked_sector = sector;
+	ss = SDPEEK8(sd, SDSTAT2);
+
+transmit:
+	while (iovcnt--) {
+		datptr = iov->sdiov_base;
+		n = iov->sdiov_nsect;
+		sd->parked_sector += n;
+		if (sd->parked_sector > sz) {
+			n -= sd->parked_sector - sz;
+			sd->parked_sector = sz;
+		}
+		datssp_stream2(sd, &datptr, n * 512);
+		iov++;
+	}
+
+	if (!sd->sd_writeparking) {
+		ret = stop2(sd);
+		if (ret) return ret;
+	}
+
+	if (sd->os_irqwait) sd->os_irqwait(sd->os_arg, 2);
+
+	s = SDPEEK8(sd, SDSTAT2);
+	if (s & 0x44) {
+		sd->sd_timeout = 1000001;
+		return 1;
+	} else {
+		reset_timeout(sd);
+		return 0;
+	}
+}
+
+static int do_write(struct sdcore *sd, unsigned int sector, struct sdiov *iov, 
+  unsigned int iovcnt)
+{
+	unsigned char *datptr, *crcptr, **crcptrptr;
+	unsigned int resp[6], ret, n, sz;
+
+	if (sd->sd_wprot) return 1;
+
+	if (iovcnt == 0) return 0;
+
+	sz = sdsize(sd);
+	if (sector >= sz) return 0;
+
+	if (0 /* sd->sd_crchint */) {
+		// CRC is pre-calculated so don't recalculate
+		crcptr = sd->sd_crchint;
+		crcptrptr = &crcptr;
+		sd->sd_state |= DATSSP_NOCRC;
+		sd->sd_crchint = NULL;
+	} else {
+		crcptrptr = NULL;
+		sd->sd_state &= ~DATSSP_NOCRC;
+	}
+
+	if (sd->parked_sector) {
+		if ((sd->sd_state & SDDAT_TX) && sd->parked_sector == sector) 
+		  goto transmit;
+		
+		stop(sd);
+	}
+
+	if (sd->sd_erasehint) {
+		sdcmd(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+		sdcmd(sd, ACMD_SET_WR_BLK_ERASE_COUNT, sd->sd_erasehint, 
+		  NULL, NULL);
+		sd->sd_erasehint = 0;
+	}
+
+	if (sd->sd_state & SD_HC)
+	  ret = sdcmd(sd, CMD_WRITE_MULTIPLE_BLOCK, sector, resp, NULL);
+	else
+	  ret = sdcmd(sd, CMD_WRITE_MULTIPLE_BLOCK, sector * 512, resp, NULL);
+	if (ret || error(resp, CMD_WRITE_MULTIPLE_BLOCK)) {
+		return 1;
+	}
+	sd->parked_sector = sector;
+
+transmit:
+	while (iovcnt--) {
+		datptr = iov->sdiov_base;
+		n = iov->sdiov_nsect;
+		sd->parked_sector += n;
+		if (sd->parked_sector > sz) {
+			n -= sd->parked_sector - sz;
+			sd->parked_sector = sz;
+		}
+		while (n--) {
+			datssp_stream(sd, &datptr, 512);
+			datssp_stream(sd, crcptrptr, 8); // CRC bytes
+			SDPOKE8(sd, SDSTATE, S_CRC_CHECK | (TYPE_TXDAT << 5));
+		}
+		iov++;
+	}
+
+	if (!sd->sd_writeparking) {
+		stop(sd);
+	}
+
+	return 0;
+}
+
+static
+int sdfastinit(struct sdcore *sd)
+{
+	SDPOKE8(sd, SDCTRL, 0x40);
+	sd->sd_state = DATSSP_4BIT;
+
+	sd->sd_rcaarg = ~sd->sdboot_token;
+	sdcmd(sd, CMD_DESELECT_CARD, ~sd->sd_rcaarg, NULL, NULL);
+	sdcmd(sd, CMD_SEND_CSD, sd->sd_rcaarg, sd->sd_csd, NULL);
+	sdcmd(sd, CMD_SELECT_CARD, sd->sd_rcaarg, NULL, NULL);
+
+	if (sd->os_dmastream) SDPOKE8(sd, SDCTRL, 0x42);
+	if ((SDPEEK8(sd, SDCTRL) & 0x80) || (sd->sd_csd[15] & 0x30)) 
+	  sd->sd_wprot = 1;
+	sd->sd_blocksize = 1 << ((sd->sd_csd[6] & 0xf));
+	if (timeout(sd)) return 0;
+	else return sdsize(sd);
+}
+
+static
+int sdreset2(struct sdcore *sd)
+{
+	unsigned int rca, s, i, x;
+	unsigned int resp[17];
+
+	reset_timeout(sd);
+	sd_initcrc(sd);
+	sd->parked_sector = 0;
+	sd->sd_wprot = 0;
+	sd->sd_blocksize = 0;
+	sd->sd_sz = 0;
+	if (sd->hw_version == 0) sd->hw_version = version(sd);
+	if (sd->hw_version == 0) return 0;
+	sd->sd_state &= SD_RESET;
+	remember_sdcore(sd);
+	activate(sd);
+	sd->sd_state |= SD_LOSPEED;
+
+	if (!(sd->sd_state & SD_RESET) && (SDPEEK8(sd, SDGPIO) != 0x0)) {
+		SDPOKE8(sd, SDGPIO, 0x0);
+#ifdef BIGENDIAN
+		for (i = 0; i < 8; i++) SDPOKE16(sd, SDLUN2, i << 8);
+#else
+		for (i = 0; i < 8; i++) SDPOKE16(sd, SDLUN2, i);
+#endif
+		sd->os_delay(sd->os_arg, 100000);
+	
+		/* this was a global reset, so let the other luns know */
+		for (i = 0; i < sizeof(sdcores); i++) {
+			if (sdcores[i] == NULL) break;
+			if (sdcores[i]->sd_regstart == sd->sd_regstart)
+			  sdcores[i]->sd_state |= SD_RESET;
+		}
+#ifdef BIGENDIAN
+		SDPOKE16(sd, SDLUN2, sd->sd_lun << 8);
+#else
+		SDPOKE16(sd, SDLUN2, sd->sd_lun);
+#endif
+	}
+	sd->sd_state &= ~SD_RESET;
+
+	// gratuitous clocks
+	SDPOKE8(sd, SDGPIO, 0xff);
+	sd->os_delay(sd->os_arg, 5000);
+	for (i = 0; i < 750; i++) {
+		SDPOKE8(sd, SDGPIO, 0xff);
+		SDPEEK8(sd, SDGPIO); /* delay */
+		SDPEEK8(sd, SDGPIO); /* delay */
+		SDPOKE8(sd, SDGPIO, 0xdf);
+		SDPEEK8(sd, SDGPIO); /* delay */
+		SDPEEK8(sd, SDGPIO); /* delay */
+	}
+
+	SDPEEK8(sd, SDSTAT2); /* reset any timeout/crc conditions */
+	SDPOKE8(sd, SDSTAT2, 0x18);
+	s = sdcmd2(sd, CMD_SEND_IF_COND, 0x1aa, resp, NULL);
+	if (s) { 
+		reset_timeout(sd); 
+		x = 0x00ff0000;
+	} else {
+		x = 0x40ff0000;
+	}
+
+	do {
+		sdcmd2(sd, CMD_APP_CMD, 0, NULL, NULL);
+		sdcmd2(sd, ACMD_SD_SEND_OP_COND, x, resp, NULL);
+		if (timeout(sd)) break;
+		// TODO: check for valid result or limit # of loops, 
+		// otherwise we may loop forever on malfunctioning cards.
+	} while (((resp[1] & 0x80) == 0x0));
+
+	if ((x & 0x40000000) && (resp[1] & 0x40)) {
+		sd->sd_state |= SD_HC;
+	}
+
+	sdcmd2(sd, CMD_ALL_SEND_CID, 0, resp, NULL);
+	sdcmd2(sd, CMD_SEND_RELATIVE_ADDR, 0, resp, NULL);
+	rca = resp[1] << 8 | resp[2];
+	sd->sd_rcaarg = (rca & 0xff00) << 16 | (rca & 0xff) << 16;
+	sd->sdboot_token = ~sd->sd_rcaarg;
+
+	sdcmd2(sd, CMD_SEND_CSD, sd->sd_rcaarg, sd->sd_csd, NULL);
+	sdcmd2(sd, CMD_SELECT_CARD, sd->sd_rcaarg, resp, NULL);
+
+	if ((resp[1] & 0x2)) {
+		unsigned int ret = 1;
+		sd->sd_locked = 1;
+#ifndef SD_NOLOCKSUPPORT
+		if (sd->sd_pwd) 
+	 	  ret = sdlockctl2(sd, SDLOCK_UNLOCK, sd->sd_pwd, NULL);
+#endif
+		if (ret != 0) return 0;
+	} else sd->sd_locked = 0;
+
+	sdcmd2(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+	sdcmd2(sd, ACMD_SET_CLR_CARD_DETECT, 0, NULL, NULL);
+	sdcmd2(sd, CMD_SET_BLOCKLEN, 512, NULL, NULL);
+	sdcmd2(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+	sdcmd2(sd, ACMD_SET_BUS_WIDTH, 2, resp, NULL);
+	sd->sd_state |= DATSSP_4BIT;
+	sd->sd_state &= ~SD_LOSPEED;
+
+	sdcmd2(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+	sdcmd2(sd, ACMD_SEND_SCR2, 0, NULL, NULL);
+	do {
+		if (timeout(sd)) break;
+		SDPOKE8(sd, SDGPIO, 0xdf);
+		SDPEEK8(sd, SDGPIO);
+		s = SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, 0xff);
+		SDPEEK8(sd, SDGPIO);
+	} while ((s & 0xf) != 0x0);
+	for (i = 0; i < 16; i++) {
+		SDPOKE8(sd, SDGPIO, 0xdf);
+		SDPEEK8(sd, SDGPIO);
+		s = (SDPEEK8(sd, SDGPIO) & 0xf) << 4;
+		SDPOKE8(sd, SDGPIO, 0xff);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, 0xdf);
+		SDPEEK8(sd, SDGPIO);
+		s |= (SDPEEK8(sd, SDGPIO) & 0xf);
+		SDPOKE8(sd, SDGPIO, 0xff);
+		SDPEEK8(sd, SDGPIO);
+		if (i < 8) sd->sd_scr[i] = s;
+	}
+	for (i = 0; i < 8; i++) {
+		SDPOKE8(sd, SDGPIO, 0xdf);
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, 0xff);
+		SDPEEK8(sd, SDGPIO);
+	}
+	sd->sd_state &= ~SDDAT_RX;
+
+#ifndef SD_NOHIGHSPEED
+	if ((sd->sd_scr[0] & 0xf) >= 1) { // SD version >= 1.10
+		unsigned char dat[64];
+		sdcmd2(sd, CMD_SWITCH_FUNC2, 0x80fffff1, NULL, NULL);
+		do {
+			if (timeout(sd)) break;
+			SDPOKE8(sd, SDGPIO, 0xdf);
+			SDPEEK8(sd, SDGPIO);
+			s = SDPEEK8(sd, SDGPIO);
+			SDPOKE8(sd, SDGPIO, 0xff);
+			SDPEEK8(sd, SDGPIO);
+		} while ((s & 0xf) != 0x0);
+		for (i = 0; i < 72; i++) {
+			SDPOKE8(sd, SDGPIO, 0xdf);
+			SDPEEK8(sd, SDGPIO);
+			s = (SDPEEK8(sd, SDGPIO) & 0xf) << 4;
+			SDPOKE8(sd, SDGPIO, 0xff);
+			SDPEEK8(sd, SDGPIO);
+			SDPOKE8(sd, SDGPIO, 0xdf);
+			SDPEEK8(sd, SDGPIO);
+			s |= (SDPEEK8(sd, SDGPIO) & 0xf);
+			SDPOKE8(sd, SDGPIO, 0xff);
+			SDPEEK8(sd, SDGPIO);
+			if (i < 64) dat[i] = s;
+		}
+		for (i = 0; i < 8; i++) {
+			SDPOKE8(sd, SDGPIO, 0xdf);
+			SDPEEK8(sd, SDGPIO);
+			SDPEEK8(sd, SDGPIO);
+			SDPOKE8(sd, SDGPIO, 0xff);
+			SDPEEK8(sd, SDGPIO);
+		}
+		sd->sd_state &= ~SDDAT_RX;
+		if (dat[0] | dat[1]) {
+			SDPOKE8(sd, SDSTAT2, 0x38);
+			sd->sd_state |= SD_HISPEED;
+		}
+	}
+#endif
+
+#ifdef BIGENDIAN
+	if ((sd->sd_csd[15] & 0x30) || (SDPEEK16(sd, SDGPIO) & 0x2))
+#else
+	if ((sd->sd_csd[15] & 0x30) || (SDPEEK16(sd, SDGPIO) & 0x200))
+#endif
+		sd->sd_wprot = 1;
+	sd->sd_blocksize = 1 << ((sd->sd_csd[6] & 0xf));
+	if (timeout(sd)) return 0;
+	else {
+		reset_timeout(sd);
+		return sdsize(sd);
+	}
+}
+
+/*
+ * return 0 : 8 bit TS-SDCORE v1
+ * return 1 : 8 bit 4x8 TS-SDCORE v2
+ * return 2 : 32 bit 4x32 TS-SDCORE v2
+ * return 3 : 16 bit 4x32 TS-SDCORE v2
+ * return 4 : 8 bit 4x32 TS-SDCORE v2
+ */
+static int version(struct sdcore *sd)
+{
+	int a, b, i;
+
+
+#ifdef SD_FORCEVERSION
+	return SD_FORCEVERSION;
+#endif
+	for (i = 0; i < sizeof(sdcores); i++) {
+		if (sdcores[i] == NULL) break;
+		if (sdcores[i]->sd_regstart == sd->sd_regstart) 
+		  return sdcores[i]->hw_version;
+	}
+
+	a = SDPEEK8(sd, 3);
+	SDPOKE8(sd, 3, (a ^ 0x40));
+	b = SDPEEK8(sd, 3);
+	SDPOKE8(sd, 3, a);
+	if ((a & 0x40) ^ (b & 0x40)) return 0;
+	else if (a & 0x40) return 1;
+	/* either 2, 3, or 4 */
+	a = SDPEEK32(sd, 12);
+	b = SDPEEK16(sd, 12);
+#ifdef BIGENDIAN
+	if ((a & 0x40000000) && (b & 0x4000)) return 2;
+#else
+	if ((a & 0x40) && (b & 0x40)) return 2;
+#endif
+	a = SDPEEK8(sd, 12);
+	if (a & 0x40) return 3;
+	else return 4;
+}
+
+int sdreset(struct sdcore *sd)
+{
+	unsigned int rca, s, x;
+	unsigned int resp[17];
+
+	reset_timeout(sd);
+	sd_initcrc(sd);
+	sd->parked_sector = 0;
+	sd->sd_wprot = 0;
+	sd->sd_blocksize = 0;
+	sd->sd_sz = 0;
+
+	sd->hw_version = version(sd);
+	if (sd->hw_version >= 2) return sdreset2(sd);
+
+	// check for no SD card present
+	if (SDPEEK8(sd, SDCTRL) & 0x8) return 0;
+
+	if (sd->sdboot_token) {
+		int ret = sdfastinit(sd);
+		sd->sdboot_token = 0;
+		if (ret) return ret;
+	}
+
+	// set controller for 1-bit mode, slow clock
+	SDPOKE8(sd, SDCTRL, 0x20);
+
+	SDPOKE8(sd, SDSTATE, S_DUMMY_CLK);
+	sd->sd_state = SDCMD_RX|SDDAT_RX;
+	s = SDPEEK8(sd, SDSTATE);
+	while ((s & 0x7) != S_SEND_CMD) {
+		// If we timeout here, it would be VERY BAD as we have no
+		// further recourse to set things right if we can't turn
+		// the SD off.
+		if (timeout(sd)) return 0;
+		sd->os_delay(sd->os_arg, 10000);
+		sd->sd_timeout += 10000;
+
+		// We won't be able to change state until both SSPs are empty
+		s = tend_ssp(sd, NULL, NULL);
+	}
+	SDPOKE8(sd, SDSTATE, S_OFF);
+	sd->sd_state = 0;
+
+	sd->os_delay(sd->os_arg, 50000);
+
+	SDPOKE8(sd, SDSTATE, S_DUMMY_CLK);
+	sd->os_delay(sd->os_arg, 100000);
+	if ((SDPEEK8(sd, SDSTATE) & 0x7) == S_OFF) {
+		// No card present
+		return 0;
+	}
+
+	SDPOKE8(sd, SDSTATE, S_WAIT_RESP);
+	// clock will freerun waiting for a response that will never come
+	sd->os_delay(sd->os_arg, 50000);
+
+	SDPOKE8(sd, SDSTATE, S_DUMMY_CLK);
+
+	s = sdcmd(sd, CMD_SEND_IF_COND, 0x1aa, resp, NULL);
+	if (s) { 
+		reset_timeout(sd); 
+		SDPOKE8(sd, SDSTATE, S_DUMMY_CLK);
+		x = 0x00ff0000;
+	} else {
+		x = 0x40ff0000;
+	}
+
+	do {
+		sdcmd(sd, CMD_APP_CMD, 0, NULL, NULL);
+		sdcmd(sd, ACMD_SD_SEND_OP_COND, x, resp, NULL);
+		if (timeout(sd)) break;
+	} while (((resp[1] & 0x80) == 0x0));
+
+	if ((x & 0x40000000) && (resp[1] & 0x40)) sd->sd_state |= SD_HC;
+
+	sdcmd(sd, CMD_ALL_SEND_CID, 0, resp, NULL);
+	sdcmd(sd, CMD_SEND_RELATIVE_ADDR, 0, resp, NULL);
+	rca = resp[1] << 8 | resp[2];
+	sd->sd_rcaarg = (rca & 0xff00) << 16 | (rca & 0xff) << 16;
+	sd->sdboot_token = ~sd->sd_rcaarg;
+
+	sdcmd(sd, CMD_SEND_CSD, sd->sd_rcaarg, sd->sd_csd, NULL);
+	sdcmd(sd, CMD_SELECT_CARD, sd->sd_rcaarg, resp, NULL);
+	
+	if ((resp[1] & 0x2)) {
+		unsigned int ret = 1;
+		sd->sd_locked = 1;
+#ifndef SD_NOLOCKSUPPORT
+		if (sd->sd_pwd) 
+	 	  ret = sdlockctl(sd, SDLOCK_UNLOCK, sd->sd_pwd, NULL);
+#endif
+		if (ret != 0) return 0;
+	} else sd->sd_locked = 0;
+
+	sdcmd(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+	sdcmd(sd, ACMD_SET_CLR_CARD_DETECT, 0, NULL, NULL);
+	/*
+	sdcmd(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+	sdcmd(sd, ACMD_SEND_SCR, 0, NULL, &datptr);
+	while ((datptr - sd->sd_scr) != 8) {
+		if (timeout(sd)) return 1;
+		tend_ssp(sd, NULL, &datptr);
+	}
+	datssp_stream(sd, NULL, 3);
+	SDPOKE8(sd, SDSTATE, (TYPE_ABORT << 5) | S_SEND_CMD);
+	sd->sd_state |= SDCMD_RX|SDDAT_RX;
+	while ((SDPEEK8(sd, SDSTATE) & 0x17) != S_SEND_CMD) {
+		if (timeout(sd)) break;
+		tend_ssp(sd, NULL, NULL);
+	}
+	sd->sd_state &= ~(SDCMD_RX|SDDAT_RX);
+	if ((sd->sd_scr[0] & 0xf) >= 1) { // SD version >= 1.10
+		unsigned char dat[64];
+		datptr = dat;
+		sdcmd(sd, CMD_SWITCH_FUNC, 0x80fffff1, NULL, &datptr);
+		while ((datptr - dat) != 64) {
+			if (timeout(sd)) break;
+			tend_ssp(sd, NULL, &datptr);
+		}
+		datssp_stream(sd, NULL, 3);
+		SDPOKE8(sd, SDSTATE, (TYPE_ABORT << 5) | S_SEND_CMD);
+		sd->sd_state |= SDCMD_RX|SDDAT_RX;
+		while ((SDPEEK8(sd, SDSTATE) & 0x7) != S_SEND_CMD) {
+			if (timeout(sd)) break;
+			tend_ssp(sd, NULL, NULL);
+		}
+		sd->sd_state &= ~(SDCMD_RX|SDDAT_RX);
+	}
+	*/
+
+	sdcmd(sd, CMD_SET_BLOCKLEN, 512, NULL, NULL);
+	sdcmd(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+	sdcmd(sd, ACMD_SET_BUS_WIDTH, 2, resp, NULL);
+
+	// set controller for 4-bit mode, fast clock
+	SDPOKE8(sd, SDCTRL, (0x40 | (sd->os_dmastream ? 0x2 : 0x0)));
+	sd->sd_state |= DATSSP_4BIT;
+	
+	/*
+	sdcmd(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+	sdcmd(sd, ACMD_SEND_SCR, 0, NULL, &datptr);
+	while ((datptr - sd->sd_scr) != 8) {
+		if (timeout(sd)) break;
+		tend_ssp(sd, NULL, &datptr);
+	}
+	datssp_stream(sd, NULL, 6);
+	SDPOKE8(sd, SDSTATE, S_DUMMY_CLK | (TYPE_SHORTRESP << 5));
+	bzero(resp, 6 * 4);
+	sdcmd(sd, CMD_SEND_STATUS, 0, resp, NULL);
+	*/
+
+	if ((SDPEEK8(sd, SDCTRL) & 0x80) || (sd->sd_csd[15] & 0x30))
+		sd->sd_wprot = 1;
+	sd->sd_blocksize = 1 << ((sd->sd_csd[6] & 0xf));
+	if (timeout(sd) || error(resp, ACMD_SET_BUS_WIDTH)) return 0;
+	else return sdsize(sd);
+}
+
+static
+int sdread2(struct sdcore *sd, unsigned int sector, unsigned char *dat, 
+  int nsectors)
+{
+	struct sdiov iov;
+	int ret;
+
+	iov.sdiov_base = dat;
+	iov.sdiov_nsect = nsectors;
+	ret = do_read2(sd, sector, &iov, 1);
+	return ret;
+}
+
+int sdread(struct sdcore *sd, unsigned int sector, unsigned char *dat, 
+  int nsectors)
+{
+	struct sdiov iov;
+	int ret;
+
+	iov.sdiov_base = dat;
+	iov.sdiov_nsect = nsectors;
+	if (sd->hw_version == 0) ret = do_read(sd, sector, &iov, 1);
+	else ret = do_read2(sd, sector, &iov, 1);
+	return ret;
+}
+
+int sdwrite(struct sdcore *sd, unsigned int sector, unsigned char *dat, 
+  int nsectors)
+{
+	struct sdiov iov;
+	unsigned int ret;
+
+	iov.sdiov_base = dat;
+	iov.sdiov_nsect = nsectors;
+	if (sd->hw_version == 0) ret = do_write(sd, sector, &iov, 1);
+	else ret = do_write2(sd, sector, &iov, 1);
+	return ret;
+
+}
+
+int sdreadv(struct sdcore *sd, unsigned int sector, struct sdiov *iov,
+  int niov)
+{
+	if (sd->hw_version == 0) return do_read(sd, sector, iov, niov);
+	else return do_read2(sd, sector, iov, niov);
+}
+
+int sdwritev(struct sdcore *sd, unsigned int sector, struct sdiov *iov,
+  int niov)
+{
+	if (sd->hw_version == 0) return do_write(sd, sector, iov, niov);
+	else return do_write2(sd, sector, iov, niov);
+}
+
+static
+int sdsetwprot2(struct sdcore *sd, unsigned int perm)
+{
+	int i, ret, s;
+	unsigned int csd[16], resp[6];
+	unsigned char csdchars[16];
+	unsigned char *csdptr = csdchars;
+
+	stop2(sd);
+
+	perm = perm ? 0x3 : 0x1;
+	for (i = 0; i < 16; i++) csd[i] = sd->sd_csd[i + 1];
+	csd[14] &= ~(0x3 << 4);
+	csd[14] |= (perm << 4);
+	csd[15] = 0x1 | crc7(0, csd, 15) << 1;
+	for (i = 0; i < 16; i++) csdchars[i] = csd[i];
+
+	ret = sdcmd2(sd, CMD_PROGRAM_CSD, 0, resp, NULL);
+	if (ret || error(resp, CMD_PROGRAM_CSD)) return 1;
+	for (i = 0; i < 16; i++) {
+		s = *csdptr++;
+		sd_4bit_feedcrc(sd, s);
+		SDPOKE8(sd, SDGPIO, (0x10|((s & 0xf0) >> 4))); 
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, (0x30|((s & 0xf0) >> 4)));
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, (0x10|(s & 0xf))); 
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, (0x30|(s & 0xf))); 
+		SDPEEK8(sd, SDGPIO);
+	}
+	for (i = 0; i < 8; i++) {
+		s = sd_4bit_getcrc(sd);
+		SDPOKE8(sd, SDGPIO, (0x10|((s & 0xf0) >> 4))); 
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, (0x30|((s & 0xf0) >> 4)));
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, (0x10|(s & 0xf))); 
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, (0x30|(s & 0xf))); 
+		SDPEEK8(sd, SDGPIO);
+	}
+	// End bit
+	SDPOKE8(sd, SDGPIO, 0x1f);
+	SDPEEK8(sd, SDGPIO);
+	SDPEEK8(sd, SDGPIO);
+	SDPOKE8(sd, SDGPIO, 0x3f);
+	SDPEEK8(sd, SDGPIO);
+	SDPOKE8(sd, SDGPIO, 0xbf);  //  tristate dat
+	// CRC ack
+	s = 0;
+	for (i = 0; i < 7; i++) { 
+		SDPOKE8(sd, SDGPIO, 0x9f);  // clk negedge
+		SDPEEK8(sd, SDGPIO);        // delay
+		s = s << 1;
+		s |= (SDPEEK8(sd, SDGPIO) & 0x1);
+		SDPOKE8(sd, SDGPIO, 0xbf);  // clk posedge
+	}
+	if ((s & 0xf) != 0x5) return 1;
+	// wait for unbusy
+	s = 0;
+	while ((s & 0x7) != 0x7) {
+		if (timeout(sd)) break;
+		SDPOKE8(sd, SDGPIO, 0x9f);  // clk negedge
+		SDPEEK8(sd, SDGPIO);        // delay
+		s = s << 1;
+		s |= SDPEEK8(sd, SDGPIO) & 0x1;
+		SDPOKE8(sd, SDGPIO, 0xbf);
+	}
+	for (i = 0; i < 8; i++) {
+		SDPOKE8(sd, SDGPIO, 0x9f);
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, 0xbf);
+		SDPEEK8(sd, SDGPIO);
+	}
+	sd->sd_state &= ~SDDAT_TX;
+
+	sdcmd2(sd, CMD_DESELECT_CARD, ~sd->sd_rcaarg, NULL, NULL);
+	ret = sdcmd2(sd, CMD_SEND_CSD, sd->sd_rcaarg, sd->sd_csd, NULL);
+	if (ret || sd->sd_csd[15] != csd[14]) {
+		return 1;
+	}
+	sdcmd2(sd, CMD_SELECT_CARD, sd->sd_rcaarg, resp, NULL);
+
+	sd->sd_wprot = 1;	
+	return 0;
+}
+
+int sdsetwprot(struct sdcore *sd, unsigned int perm)
+{
+	int i, ret;
+	unsigned int csd[16], resp[6];
+	unsigned char csdchars[16];
+	unsigned char *csdptr = csdchars;
+
+	if (sd->hw_version) return sdsetwprot2(sd, perm);
+
+	if (stop(sd)) return 1;
+
+	perm = perm ? 0x3 : 0x1;
+	for (i = 0; i < 16; i++) csd[i] = sd->sd_csd[i + 1];
+	csd[14] &= ~(0x3 << 4);
+	csd[14] |= (perm << 4);
+	csd[15] = 0x1 | crc7(0, csd, 15) << 1;
+	for (i = 0; i < 16; i++) csdchars[i] = csd[i];
+
+	ret = sdcmd(sd, CMD_PROGRAM_CSD, 0, resp, NULL);
+	if (ret || error(resp, CMD_PROGRAM_CSD)) return 1;
+	datssp_stream(sd, &csdptr, 16);
+	datssp_stream(sd, NULL, 8);
+	SDPOKE8(sd, SDSTATE, S_CRC_CHECK | (TYPE_BSYRESP << 5));
+	sd->sd_state &= ~SDDAT_TX;
+
+	sdcmd(sd, CMD_DESELECT_CARD, ~sd->sd_rcaarg, NULL, NULL);
+	ret = sdcmd(sd, CMD_SEND_CSD, sd->sd_rcaarg, sd->sd_csd, NULL);
+	if (ret || sd->sd_csd[15] != csd[14]) {
+		return 1;
+	}
+	sdcmd(sd, CMD_SELECT_CARD, sd->sd_rcaarg, resp, NULL);
+
+	sd->sd_wprot = 1;	
+	return 0;
+}
+
+#ifndef SD_NOLOCKSUPPORT
+int sdlockctl(struct sdcore *sd, unsigned int cmd, unsigned char *pwd, 
+  unsigned char *sdbootdat)
+{
+	unsigned char pwddat[18];
+	unsigned char *pwdptr = pwddat;
+	unsigned int resp[6];
+	int ret, i, len;
+	int ccc = (sd->sd_csd[5] << 4) | (sd->sd_csd[6] >> 4);
+
+	if (sd->hw_version) return sdlockctl2(sd, cmd, pwd, sdbootdat);
+	
+	if (!(ccc & 0x80)) return 1; // Class 7 is lock-unlock commands
+	
+	if (pwd == NULL && cmd != SDLOCK_ERASE) return 1;
+	
+	if (stop(sd)) return 1;
+
+	if (sd->sd_state & DATSSP_4BIT) {
+		int oldctrl = SDPEEK8(sd, SDCTRL);
+		int ret;
+
+		sdcmd(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+		sdcmd(sd, ACMD_SET_BUS_WIDTH, 0, NULL, NULL);
+		SDPOKE8(sd, SDCTRL, 0x20);
+		sd->sd_state &= ~DATSSP_4BIT;
+		ret = sdlockctl(sd, cmd, pwd, sdbootdat);
+		sdcmd(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+		sdcmd(sd, ACMD_SET_BUS_WIDTH, 2, NULL, NULL);
+		sd->sd_state |= DATSSP_4BIT;
+		SDPOKE8(sd, SDCTRL, oldctrl);
+		return ret;
+	}
+	
+	pwddat[0] = cmd; 
+	if (cmd != SDLOCK_ERASE) {
+		pwddat[1] = 16; // length
+		for (i = 0; i < 16; i++) {
+			pwddat[2 + i] = pwd[i];
+		}
+	}
+
+	if (cmd == SDLOCK_ERASE) len = 1; else len = 18;
+	ret = sdcmd(sd, CMD_SET_BLOCKLEN, len, resp, NULL);
+	if (ret || error(resp, CMD_SET_BLOCKLEN)) return 1;
+	ret = sdcmd(sd, CMD_LOCK_UNLOCK, 0, resp, NULL);
+	if (ret || error(resp, CMD_LOCK_UNLOCK)) return 1;
+
+	while ((pwdptr - pwddat) != len) {
+		if (timeout(sd)) return 1;
+		tend_ssp(sd, NULL, &pwdptr);
+	}
+
+	if (sd->sd_state & DATSSP_4BIT) datssp_stream(sd, NULL, 8);
+	else datssp_stream(sd, NULL, 2);
+
+	SDPOKE8(sd, SDSTATE, S_CRC_CHECK | (TYPE_BSYRESP << 5));
+	sd->sd_state &= ~SDDAT_TX;
+	ret = sdcmd(sd, CMD_SET_BLOCKLEN, 512, resp, NULL);
+	if (ret || error(resp, CMD_SET_BLOCKLEN)) return 1;
+	ret = sdcmd(sd, CMD_SEND_STATUS, sd->sd_rcaarg, resp, NULL);
+	if (ret || error(resp, CMD_SEND_STATUS)) return 1;
+	
+	if ((cmd == SDLOCK_ERASE || cmd == SDLOCK_UNLOCK ||
+	  cmd == SDLOCK_CLRPWD) && (resp[1] & 0x2)) {
+		return 1;
+	}
+
+	if (sdbootdat) {
+		sdbootdat[0] = SDLOCK_UNLOCK;
+		for (i = 1; i < 18; i++) {
+			sdbootdat[i] = pwddat[i];
+			sd_1bit_feedcrc(sd, pwddat[i]);
+		}
+		sdbootdat[18] = sd_1bit_getcrc(sd);
+		sdbootdat[19] = sd_1bit_getcrc(sd);
+	}
+	
+	return 0;
+}
+
+static
+int sdlockctl2(struct sdcore *sd, unsigned int cmd, unsigned char *pwd, 
+  unsigned char *sdbootdat)
+{
+	unsigned char pwddat[18];
+	unsigned char *pwdptr = pwddat;
+	unsigned int resp[6];
+	int ret, i, j, len, s;
+	int ccc = (sd->sd_csd[5] << 4) | (sd->sd_csd[6] >> 4);
+	
+	if (!(ccc & 0x80)) return 1; // Class 7 is lock-unlock commands
+	
+	if (pwd == NULL && cmd != SDLOCK_ERASE) return 1;
+	
+	stop2(sd);
+
+	if (sd->sd_state & DATSSP_4BIT) {
+		int ret;
+
+		sdcmd2(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+		sdcmd2(sd, ACMD_SET_BUS_WIDTH, 0, NULL, NULL);
+		sd->sd_state &= ~DATSSP_4BIT;
+		ret = sdlockctl2(sd, cmd, pwd, sdbootdat);
+		sdcmd2(sd, CMD_APP_CMD, sd->sd_rcaarg, NULL, NULL);
+		sdcmd2(sd, ACMD_SET_BUS_WIDTH, 2, NULL, NULL);
+		sd->sd_state |= DATSSP_4BIT;
+		return ret;
+	}
+	
+	pwddat[0] = cmd; 
+	if (cmd != SDLOCK_ERASE) {
+		pwddat[1] = 16; // length
+		for (i = 0; i < 16; i++) {
+			pwddat[2 + i] = pwd[i];
+		}
+	}
+
+	if (cmd == SDLOCK_ERASE) len = 1; else len = 18;
+	ret = sdcmd2(sd, CMD_SET_BLOCKLEN, len, resp, NULL);
+	if (ret || error(resp, CMD_SET_BLOCKLEN)) return 1;
+	ret = sdcmd2(sd, CMD_LOCK_UNLOCK, 0, resp, NULL);
+	if (ret || error(resp, CMD_LOCK_UNLOCK)) return 1;
+
+	for (i = 0; i < len; i++) {
+		unsigned int b = *pwdptr++;
+		unsigned int x;
+
+		sd_1bit_feedcrc(sd, b);
+		for (j = 0; j < 8; j++) {
+			x = 0x1e | ((b >> 7) & 0x1);
+			b = b << 1;
+			SDPOKE8(sd, SDGPIO, x);  // clk negedge
+			SDPEEK8(sd, SDGPIO);
+			SDPEEK8(sd, SDGPIO);
+			x |= 0x20;
+			SDPOKE8(sd, SDGPIO, x);  // clk posedge
+			SDPEEK8(sd, SDGPIO);
+		}
+	}
+	for (i = 0; i < 2; i++) {
+		unsigned int b = sd_1bit_getcrc(sd); 
+		unsigned int x;
+
+		for (j = 0; j < 8; j++) {
+			x = 0x1e | ((b >> 7) & 0x1);
+			b = b << 1;
+			SDPOKE8(sd, SDGPIO, x);  // clk negedge
+			SDPEEK8(sd, SDGPIO);
+			SDPEEK8(sd, SDGPIO);
+			x |= 0x20;
+			SDPOKE8(sd, SDGPIO, x);  // clk posedge
+			SDPEEK8(sd, SDGPIO);
+		}
+	}
+	// End bit 
+	SDPOKE8(sd, SDGPIO, 0x1f);  // clk negedge
+	SDPEEK8(sd, SDGPIO);
+	SDPOKE8(sd, SDGPIO, 0xbf);  // clk posedge, tristate dat
+	// CRC ack
+	s = 0;
+	for (i = 0; i < 7; i++) { 
+		SDPOKE8(sd, SDGPIO, 0x9f);  // clk negedge
+		SDPEEK8(sd, SDGPIO);        // delay
+		s = s << 1;
+		s |= SDPEEK8(sd, SDGPIO) & 0x1;
+		SDPOKE8(sd, SDGPIO, 0xbf);  // clk posedge
+		SDPEEK8(sd, SDGPIO);
+	}
+	if ((s & 0xf) != 0x5) return 1;
+
+	// wait for unbusy
+	s = 0;
+	while ((s & 0x7) != 0x7) {
+		if (timeout(sd)) break;
+		SDPOKE8(sd, SDGPIO, 0x9f);  // clk negedge
+		SDPEEK8(sd, SDGPIO);        // delay
+		s = s << 1;
+		s |= SDPEEK8(sd, SDGPIO) & 0x1;
+		SDPOKE8(sd, SDGPIO, 0xbf);
+		SDPEEK8(sd, SDGPIO);
+	}
+	for (i = 0; i < 8; i++) {
+		SDPOKE8(sd, SDGPIO, 0x9f);
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, 0xbf);
+		SDPEEK8(sd, SDGPIO);
+	}
+
+	sd->sd_state &= ~SDDAT_TX;
+	ret = sdcmd2(sd, CMD_SET_BLOCKLEN, 512, resp, NULL);
+	if (ret || error(resp, CMD_SET_BLOCKLEN)) {
+		return 1;
+	}
+	ret = sdcmd2(sd, CMD_SEND_STATUS, sd->sd_rcaarg, resp, NULL);
+	if (ret || error(resp, CMD_SEND_STATUS)) {
+		return 1;
+	}
+	
+	if ((cmd == SDLOCK_ERASE || cmd == SDLOCK_UNLOCK ||
+	  cmd == SDLOCK_CLRPWD) && (resp[1] & 0x2)) {
+		return 1;
+	}
+
+	if (sdbootdat) {
+		sdbootdat[0] = SDLOCK_UNLOCK;
+		for (i = 1; i < 18; i++) {
+			sdbootdat[i] = pwddat[i];
+			sd_1bit_feedcrc(sd, pwddat[i]);
+		}
+		sdbootdat[18] = sd_1bit_getcrc(sd);
+		sdbootdat[19] = sd_1bit_getcrc(sd);
+	}
+
+	for (i = 0; i < 8; i++) {
+		SDPOKE8(sd, SDGPIO, 0x9f);
+		SDPEEK8(sd, SDGPIO);
+		SDPEEK8(sd, SDGPIO);
+		SDPOKE8(sd, SDGPIO, 0xbf);
+		SDPEEK8(sd, SDGPIO);
+	}
+	return 0;
+}
+#endif
diff --git a/drivers/block/tssdcard.c b/drivers/block/tssdcard.c
new file mode 100644
index 0000000..0624436
--- /dev/null
+++ b/drivers/block/tssdcard.c
@@ -0,0 +1,414 @@
+/*
+ * TS SD Card device driver
+ *
+ * (c) Copyright 2010  Matthieu Crapet <mcrapet@gmail.com>
+ * Based on Technologic Systems & Breton M. Saunders work
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Notes:
+ *   - request processing method is: no request queue
+ *   - no M2M DMA is used
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/major.h>
+#include <linux/blkdev.h>
+#include <linux/bio.h>
+#include <linux/delay.h>
+#include <linux/hdreg.h>
+#include <linux/platform_device.h>
+
+#include "tssdcore.h"
+
+#define SDCARD_DEV_NAME          "tssd" /* will appear in /proc/partitions & /sys/class/block */
+#define SD_SHIFT                 4      /* max 16 partitions = 1 << 4 */
+
+#define KERN_SECTOR_SIZE         512    /* in bytes */
+#define HARD_SECTOR_SIZE         512    /* in bytes */
+#define HARD_2_KERN_SECTOR_RATIO 1      /* 1 kernel sector = 1 hardware sector */
+
+
+struct ts72xx_sdcard_device {
+	struct sdcore tssdcore;         /* Physical core layer */
+	void __iomem *mmio_base;
+	long size;                      /* Device size in (hardware) sectors */
+	int id;
+	int media_change;
+	int users;
+
+	spinlock_t lock;
+	struct device *dev;
+	struct request_queue *queue;
+	struct gendisk *disk;
+};
+
+
+/*
+ * Low level function to handle an I/O request
+ */
+static inline int sdcard_ll_transfer(struct ts72xx_sdcard_device *dev,
+		unsigned long sector, unsigned long nsect, char *buffer, int rw)
+{
+	int ret;
+
+	//spin_unlock(&dev->lock); // ???
+
+	if ((sector + nsect) > (dev->size * HARD_2_KERN_SECTOR_RATIO)) {
+		dev_err(dev->dev, "tranfer: beyond-end write (%ld %ld)\n", sector, nsect);
+		//spin_lock(&dev->lock); // ???
+		return -1;
+	}
+
+	switch (rw) {
+		case WRITE:
+			ret = sdwrite(&dev->tssdcore, sector, buffer, nsect);
+			if (ret && !dev->tssdcore.sd_wprot) {
+				sdreset(&dev->tssdcore);
+				ret = sdwrite(&dev->tssdcore, sector, buffer, nsect);
+			}
+			break;
+
+		case READ:
+		case READA:
+			ret = sdread(&dev->tssdcore, sector, buffer, nsect);
+			if (ret) {
+				// SDCARD RESET may be printed when the core determines that the SD card has
+				// f*ed up.this is not handled correctly yet; and should likely be inside a while loop
+				dev_err(dev->dev, "transfer: SDCARD RESET\n");
+				sdreset(&dev->tssdcore);
+				ret = sdread(&dev->tssdcore, sector, buffer, nsect);
+			}
+			break;
+	}
+
+	//spin_lock(&dev->lock); // ???
+	return 0;
+}
+
+/*
+ * The direct make request version.
+ */
+static int sdcard_make_request(struct request_queue *q, struct bio *bio)
+{
+	struct ts72xx_sdcard_device *dev = q->queuedata;
+
+	struct bio_vec *bvec;
+	sector_t sector;
+	int i, rw;
+	int err = -EIO;
+
+	/* handle bio */
+	sector = bio->bi_sector;
+	rw = bio_rw(bio);
+
+	bio_for_each_segment(bvec, bio, i) {
+		char *buffer = __bio_kmap_atomic(bio, i, KM_USER0);
+		unsigned int len = bvec->bv_len / HARD_SECTOR_SIZE;
+
+		//printk("bvec: len=%d offt=%d page=%p\n", bvec->bv_len, bvec->bv_offset, bvec->bv_page);
+
+		err = sdcard_ll_transfer(dev, sector, len, buffer, rw);
+		if (err)
+			break;
+
+		sector += len;
+		__bio_kunmap_atomic(bio, KM_USER0);
+	}
+	bio_endio(bio, err);
+
+	return 0;
+}
+
+static void sdcard_delay(void *arg, unsigned int us)
+{
+	udelay(us);
+}
+
+static int sdcard_open(struct block_device *bdev, fmode_t mode)
+{
+	struct ts72xx_sdcard_device *dev = bdev->bd_disk->private_data;
+	unsigned long flags;
+
+	dev_dbg(dev->dev, "open() users=%i\n", dev->users + 1);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->users++;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	check_disk_change(bdev);
+	return 0;
+};
+
+static int sdcard_release(struct gendisk *disk, fmode_t mode)
+{
+	struct ts72xx_sdcard_device *dev = disk->private_data;
+	unsigned long flags;
+
+	dev_dbg(dev->dev, "release() users=%i\n", dev->users - 1);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->users--;
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+static int sdcard_media_changed(struct gendisk *disk)
+{
+	struct ts72xx_sdcard_device *dev = disk->private_data;
+
+	char buf[HARD_SECTOR_SIZE];
+	dev->media_change = sdread(&dev->tssdcore, 1, buf, 1);
+
+	dev_dbg(dev->dev, "media_changed() %i\n", dev->media_change);
+	return dev->media_change;
+}
+
+static int sdcard_revalidate(struct gendisk *disk)
+{
+	struct ts72xx_sdcard_device *dev = disk->private_data;
+	int ret = 0;
+
+	dev_dbg(dev->dev, "revalidate() %i\n", dev->media_change);
+	if (dev->media_change) {
+		dev->size = sdreset(&dev->tssdcore);
+		set_disk_ro(dev->disk, !!(dev->tssdcore.sd_wprot));
+		if (dev->size > 0) {
+			set_capacity(dev->disk, dev->size * HARD_2_KERN_SECTOR_RATIO);
+			dev->media_change = 0;
+		} else {
+			dev_err(dev->dev, "revalidate() no card found\n");
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+static int sdcard_getgeo(struct block_device *bdev, struct hd_geometry *geo)
+{
+	struct gendisk *disk = bdev->bd_disk;
+	struct ts72xx_sdcard_device *dev = disk->private_data;
+
+	/* We don't have real geometry info, but let's at least return
+	 * values consistent with the size of the device */
+	geo->heads = 16;
+	geo->sectors = 32;
+	geo->cylinders = get_capacity(disk) / (16 * 32);
+
+	dev_dbg(dev->dev, "getgeo() %d heads, %d sectors, %d cylinders\n",
+			geo->heads, geo->sectors, geo->cylinders);
+	return 0;
+}
+
+/*
+ * The device operations structure.
+ */
+static struct block_device_operations ts72xx_sdcard_ops = {
+	.owner			= THIS_MODULE,
+	.open			= sdcard_open,
+	.release		= sdcard_release,
+	.media_changed		= sdcard_media_changed,
+	.revalidate_disk	= sdcard_revalidate,
+	.getgeo			= sdcard_getgeo
+};
+
+static int sdcard_major;
+
+/* ---------------------------------------------------------------------
+ * Device setup
+ */
+
+static int ts72xx_sdcard_setup(const char *name, struct ts72xx_sdcard_device *dev)
+{
+	int rc;
+
+	spin_lock_init(&dev->lock);
+
+	/*
+	 * Initialize the request queue
+	 */
+	dev->queue = blk_alloc_queue(GFP_KERNEL);
+	if (!dev->queue)
+		goto err_alloc_queue;
+
+	dev->queue->queuedata = dev;
+	blk_queue_make_request(dev->queue, sdcard_make_request);
+	blk_queue_logical_block_size(dev->queue, HARD_SECTOR_SIZE);
+
+      	dev->tssdcore.sd_regstart = (unsigned char *)dev->mmio_base;
+	dev->tssdcore.os_arg       = dev;
+	dev->tssdcore.os_delay     = sdcard_delay;
+	dev->tssdcore.os_dmastream = NULL;
+	dev->tssdcore.os_dmaprep   = NULL;
+
+	// don't want to write park
+	dev->tssdcore.sd_writeparking = 1;
+	// I do want to pre-erase blocks - 8 blocks pre-erase
+	dev->tssdcore.sd_erasehint = 8;
+	dev->tssdcore.sdboot_token = 0;
+
+	dev->disk = alloc_disk(1 << SD_SHIFT);
+	if (!dev->disk) {
+		goto err_alloc_disk;
+	}
+
+	dev->disk->major = sdcard_major;
+	dev->disk->first_minor = dev->id << SD_SHIFT;
+	dev->disk->flags = GENHD_FL_REMOVABLE;
+	dev->disk->fops = &ts72xx_sdcard_ops;
+	dev->disk->queue = dev->queue;
+	dev->disk->private_data = dev;
+	snprintf(dev->disk->disk_name, 32, SDCARD_DEV_NAME "%c", dev->id + 'a');
+
+	/* SD Card size and Reset
+	 * (set_disk_ro, set_capacity will be called) */
+	dev->media_change = 1;
+	rc = sdcard_revalidate(dev->disk);
+	if (rc) {
+		dev_info(dev->dev, "No SD card detected!\n");
+		goto err_alloc_disk;
+	}
+
+	dev_info(dev->dev, "SD card hardware revision: %08x\n",
+			dev->tssdcore.sdcore_version);
+	dev_info(dev->dev, "block device major number = %d\n",
+			sdcard_major);
+	dev_info(dev->dev, "New SD card detected, name=%s size=%ld (sectors)\n",
+			dev->disk->disk_name, dev->size);
+
+	/* Make the sysace device 'live' */
+	add_disk(dev->disk);
+
+	return 0;
+
+err_alloc_disk:
+	blk_cleanup_queue(dev->queue);
+err_alloc_queue:
+	return -ENOMEM;
+}
+
+
+/* ---------------------------------------------------------------------
+ * Platform drivers functons
+ */
+
+static int __init ts72xx_sdcard_probe(struct platform_device *pdev)
+{
+	struct ts72xx_sdcard_device *dev;
+	struct resource *res;
+	int rc;
+
+	dev = kzalloc(sizeof(struct ts72xx_sdcard_device), GFP_KERNEL);
+	if (!dev) {
+		rc = -ENOMEM;
+		goto fail_no_mem;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		rc = -ENXIO;
+		goto fail_no_mem_resource;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		rc = -EBUSY;
+		goto fail_no_mem_resource;
+	}
+
+	dev->mmio_base = ioremap(res->start, resource_size(res));
+	if (dev->mmio_base == NULL) {
+		rc = -ENXIO;
+		goto fail_no_ioremap;
+	}
+
+	dev->dev = &pdev->dev;
+	dev->id = pdev->id;
+	platform_set_drvdata(pdev, dev);
+
+	rc = ts72xx_sdcard_setup(SDCARD_DEV_NAME, dev);
+	if (rc) {
+		dev_err(dev->dev, "ts72xx_sdcard_setup failed\n");
+		goto fail_sdcard_setup;
+	}
+
+	return 0;
+
+fail_sdcard_setup:
+	iounmap(dev->mmio_base);
+fail_no_ioremap:
+	release_mem_region(res->start, resource_size(res));
+fail_no_mem_resource:
+	kfree(dev);
+fail_no_mem:
+	return rc;
+}
+
+static int __exit ts72xx_sdcard_remove(struct platform_device *pdev)
+{
+	struct ts72xx_sdcard_device *dev = platform_get_drvdata(pdev);
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	platform_set_drvdata(pdev, NULL);
+	iounmap(dev->mmio_base);
+	release_mem_region(res->start, resource_size(res));
+	blk_cleanup_queue(dev->queue);
+	del_gendisk(dev->disk);
+	put_disk(dev->disk);
+	kfree(dev);
+
+	return 0;
+}
+
+static struct platform_driver ts72xx_sdcard_driver = {
+	.driver		= {
+		.name	= "ts72xx-sdcard",
+		.owner	= THIS_MODULE,
+	},
+	.remove		= __exit_p(ts72xx_sdcard_remove),
+};
+
+
+/* ---------------------------------------------------------------------
+ * Module init/exit routines
+ */
+
+static int __init ts72xx_sdcard_init(void)
+{
+	int rc;
+
+	sdcard_major = rc = register_blkdev(sdcard_major, SDCARD_DEV_NAME);
+	if (rc <= 0) {
+		printk(KERN_ERR "%s:%u: register_blkdev failed %d\n", __func__,
+				__LINE__, rc);
+		return rc;
+	}
+
+	rc = platform_driver_probe(&ts72xx_sdcard_driver, ts72xx_sdcard_probe);
+	if (rc)
+		unregister_blkdev(sdcard_major, SDCARD_DEV_NAME);
+
+	return rc;
+}
+
+static void __exit ts72xx_sdcard_exit(void)
+{
+	unregister_blkdev(sdcard_major, SDCARD_DEV_NAME);
+	platform_driver_unregister(&ts72xx_sdcard_driver);
+}
+
+module_init(ts72xx_sdcard_init);
+module_exit(ts72xx_sdcard_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("TS72xx SD Card block driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_BLOCKDEV_MAJOR(SCSI_DISK0_MAJOR);
+MODULE_ALIAS("tssd");
diff --git a/drivers/block/tssdcore.h b/drivers/block/tssdcore.h
new file mode 100644
index 0000000..38d5b96
--- /dev/null
+++ b/drivers/block/tssdcore.h
@@ -0,0 +1,372 @@
+/*
+ * Copyright (c) 2006-2008, Technologic Systems
+ * All rights reserved.
+ */
+
+#ifndef _SDCORE_H_
+#define _SDCORE_H_
+
+// Additional missing defs
+#define SDCMD 0                // cmd register
+#define SDDAT 1                // data register
+#define SDSTATE 2              // state register
+#define SDCTRL 3               // ctrl register
+
+
+// this bit is set when no card inserted
+#define SDCTRL_CARD_ABSENT 0x08
+
+
+
+/* public bits for sd_state bitfield, can be read from client code.
+ * Do not write!  Other bits are used internally.
+ */
+#define SDDAT_RX	(1<<0)
+#define SDDAT_TX	(1<<1)
+#define SDCMD_RX	(1<<2)
+#define SDCMD_TX	(1<<3)
+
+// used to disable CRC calculations in write mode
+#define SDCRC_DISABLE   (1 << 4)
+
+
+
+// used to choose between 4 bit crc mode and 1 bit crc mode
+
+// note - likely set in sdreset when configuring interface bit width
+#define SDSSP_4BIT_MODE (1 << 5)
+
+// SD_ADDRESSING_DIRECT means that sd card addresses
+// will be communicated in read/write mode using
+// full offsets, not 512 byte block offsets.
+// the core will mulitply the address by 512 if this
+// bit is cleared
+#define SD_ADDRESSING_DIRECT (1 << 6)
+
+
+/* These structs should start intialized to all 0's (bzero()'ed).  Proper
+ * operation can be assured by setting sd_regstart, and the os_delay
+ * callback.  sdreset() should be called to initialize the core, then
+ * sdread() and sdwrite() can be used.
+ */
+struct sdcore {
+	/* virtual address of SD block register start, to be filled in
+	 * by client code before calling any sdcore functions.
+	 */
+  // 0-3
+	unsigned char* sd_regstart;
+
+
+
+  // 4-7
+	unsigned int sd_state;
+
+	/* Erase hint for subsequent sdwrite() call, used to optimize
+	 * write throughput on multi-sector writes by pre-erasing this
+	 * many sectors.
+	 */
+  // 8-11
+	unsigned int sd_erasehint;
+
+	/* Following this comment are 5 function pointer declarations to
+	 * OS helper functions.  The 'os_arg' member is passed as the
+	 * first argument to the helpers and should be set by
+	 * client code before issueing sdreset()
+	 *
+	 * os_dmastream(os_arg, buf, buflen)
+	 * This function should look at sd_state and set up and run an
+	 * appropriate DMA transfer.  If buf is NULL, callee doesn't care
+	 * about the actual data sent/received and helper function
+	 * can do whatever it wants.  Should return 0 when DMA transfer was
+	 * run and completed successfully.  If this function pointer is
+	 * NULL, PIO methods of transfer will be used instead of DMA.
+	 *
+	 * os_dmaprep(os_arg, buf, buflen)
+	 * This function is used to prepare an area of memory for a possible
+	 * DMA transfer.  This function is called once per distinct buffer
+	 * passed in.  After this function is called, os_dmastream() may be
+	 * called one or more times (for sequential addresses) on subregions
+	 * of the address range passed here.  Should write-back or invalidate
+	 * L1 cache lines and possibly look up physical addresses for buf
+	 * passed in if I/O buffers.  If 'os_dmaprep' is set to NULL, function
+	 * call will not happen. (though os_dmastream() calls may still)
+	 *
+	 * os_delay(os_arg, microseconds)
+	 * This function is supposed to delay or stall the processor for
+	 * the passed in value number of microseconds.
+	 *
+	 * os_irqwait(os_arg, type)
+	 * Called at certain times to request to be put to sleep/block until
+	 * an SD interrupt occurs.  It is not critical to set this function.
+	 * When NULL, the sdcore routines simply busy-wait.
+	 *
+	 * os_powerok(os_arg)
+	 * Experimental callback function -- set to NULL for now.
+	 */
+  // 12-15
+	void *os_arg;
+  // 16-19
+	int (*os_dmastream)(void *, unsigned char *, unsigned int);
+  // 20-23
+	void (*os_dmaprep)(void *, unsigned char *, unsigned int);
+  // 24-27
+	void (*os_delay)(void *, unsigned int);
+  // 28-31
+	void (*os_irqwait)(void *, unsigned int);
+  // 32-35
+	int (*os_powerok)(void *);
+
+	int (*os_timeout)(void *);
+	int (*os_reset_timeout)(void *);
+
+	/* If the SD card last successfully reset is write protected, this
+	 * member will be non-zero.
+	 */
+  // 36-39
+	unsigned int sd_wprot;
+
+	/* If this card may have been already initialized by TS-SDBOOT, place
+	 * the magic token it placed in the EP93xx SYSCON ScratchReg1 here
+	 * before calling sdreset() to avoid re-initialization.
+	 */
+  // 40-43
+	unsigned int sdboot_token;
+
+	/* CRC hint for subsequent sdwrite() call, used to optimize
+	 * write throughput while using DMA by pre-calculating CRC's for
+	 * next write.  NULL means no hint supplied.
+	 */
+  // 44-47
+	unsigned char *sd_crchint;
+
+	/* The block size of the memory device.  Normally 512, but can be 1024
+	 * for larger cards.  Read-only member and actually not very useful.
+	 */
+  // 48-51
+	unsigned int sd_blocksize;
+
+	/* Password for auto-unlocking in sdreset()
+	 */
+  // 52-55
+	unsigned char *sd_pwd;
+
+	/* If the SD card was password locked, this will be non-zero after
+	 * unsuccessful sdreset().
+	 */
+  // 56-59
+	unsigned int sd_locked;
+
+	/* Whether or not writes can be parked.  Definitely should be set to 1
+	 * as writes are very slow without it.
+	 */
+  // 60-63
+	unsigned int sd_writeparking;
+
+	/* Logical unit number.  Some SD cores will have multiple card slots.
+	 * LUN #0 is the first.
+	 */
+  // 64-67
+	unsigned int sd_lun;
+
+	/* The rest of these members are for private internal use and should
+	 * not be of interest to client code.
+	 */
+
+
+  // 68-71
+  unsigned int rca;  // relative card address
+
+
+  unsigned int sd_csd[17];
+  /*
+
+
+  // 72 -75    0
+  unsigned int unknown72;      // one of the csds?
+
+  // 76 -79    1
+  unsigned int unknown76;      // csd 0x00
+  // 80 -83    2
+  unsigned int unknown04;      // csd 0x01
+  // 84 - 87   3
+  unsigned int unknown05;      // csd 0x02
+  // 88 - 91   4
+  unsigned int unknown06;      // csd 0x03
+  // 92 - 95   5
+  unsigned int unknown92;      // csd 0x04
+  // 96 - 100  6
+  unsigned int unknown96;      // csd 0x05
+  // 100 - 103 7
+  unsigned int unknown100;     // csd 0x06
+  // 104 - 107 8
+  unsigned int unknown104;     // csd 0x07
+  // 108 - 111 9
+  unsigned int unknown108;     // csd 0x08
+  // 112 - 115 10
+  unsigned int unknown112;     // csd 0x09
+  // 116 - 119 11
+  unsigned int unknown116;     // csd 0x0a
+  // 120       12
+  unsigned int unknown24;      // csd 0x0b
+  // 124       13
+  unsigned int unknown25;      // csd 0x0c
+  // 128       14
+  unsigned int unknown26;      // csd 0x0d
+  // 132       15
+  unsigned int unknown132;      // csd 0x0e
+  // 136       16
+  unsigned int unknown28;      // csd 0x0f
+  */
+
+
+  // 140
+  unsigned int sd_crc_shift;
+
+  // 144 + 4 + 4
+  unsigned short s_crc_table[4]; // 4 shorts
+  // 152 + 4 + 4 + 4 + 4
+  unsigned int   l_crc_table[4]; // 4 longs
+
+  // 168
+  unsigned int sd_timeout;       // used to busy wait
+
+  // 172
+  unsigned int sd_cur_sector;    // stop indicator - if zero , then stop procedure will be skipped
+
+  // 176
+  unsigned int sdcore_version;   // hardware version
+  // 180
+  unsigned int unknown39;
+  // 184
+  unsigned int unknown40;
+  // 188
+  unsigned int sdcore_sdsize;
+
+
+
+  unsigned int unknown42;
+  unsigned int unknown43;
+  unsigned int unknown44;
+  unsigned int unknown45;
+  unsigned int unknown46;
+  unsigned int unknown47;
+
+
+
+
+
+
+
+
+
+
+
+
+
+};
+
+/* I believe sdcores is a table mapping
+   id -> sdcore struct.  The table is
+   64 long, meaning that one could build a ts device with
+   64 sdcores on it.
+*/
+//extern unsigned char sdcores[256];
+
+
+
+
+/* For sdreadv() / sdwritev() */
+struct sdiov {
+  unsigned char *sdiov_base;
+  unsigned int sdiov_nsect;
+};
+
+
+
+
+int sdreset(struct sdcore *);
+
+int sdsize(struct sdcore* sdcore);
+
+
+int sdread(struct sdcore* sdcore,
+	   unsigned int sector,
+	   unsigned char* buffer,
+	   int nsect);
+
+int sdwrite(struct sdcore *, unsigned int, unsigned char *, int);
+
+
+// same signature as do_read
+int do_read(struct sdcore*, unsigned int, struct sdiov*, int);
+int sdreadv(struct sdcore * sdcore,
+	    unsigned int sector,
+	    struct sdiov * sdiov,
+	    int nsdiov);
+
+// same signature as do_write
+int do_write(struct sdcore* sdcore,
+	     unsigned int sector,
+	     struct sdiov* sdiov,
+	     int nsdiov);
+
+int sdwritev(struct sdcore *, unsigned int, struct sdiov *, int);
+
+
+void sd_1bit_feedcrc(struct sdcore*, unsigned int);
+void sd_4bit_feedcrc(struct sdcore*, unsigned int);
+
+unsigned char sd_1bit_getcrc(struct sdcore*);
+unsigned char sd_4bit_getcrc(struct sdcore*);
+
+/** stop takes only sdcore parameters */
+int stop(struct sdcore*);
+
+
+int tend_ssp(struct sdcore* sdcore,
+	     unsigned int** unknown_r1,      // r1
+	     unsigned char** unknown_r2);
+
+
+int datssp_stream(struct sdcore* sdcore,
+		  unsigned char** data,
+		  int count);
+
+/*
+ * @param cmd is the command - I believe that the lower byte is the command, and
+ *       the upper one is the crc
+ *
+ * @param data is a character buffer for data received in the ssp dat register, as
+ * a result of a command execution.
+ */
+
+int sdcmd(struct sdcore* sdcore,
+	  unsigned short cmd,
+	  unsigned int sdargs,
+	  unsigned int* response,
+	  unsigned char** data); // command response buffer?
+
+
+/**
+ * Error tests if a sdcommand error has been received.
+ * It does this by checking that the command was
+ * correctly returned by the card (the first byte in buffer),
+ * and that a CRC error has not occurred.  IF one has occurred
+ * it will attempt a 1bit fix. (suspected)
+ */
+int error(unsigned int* buffer, unsigned int cmd);
+
+
+
+int sdsetwprot(struct sdcore *, unsigned int);
+#define SDLOCK_UNLOCK	0
+#define SDLOCK_SETPWD	1
+#define SDLOCK_CLRPWD	2
+#define SDLOCK_ERASE	8
+
+int sdlockctl(struct sdcore *,
+	      unsigned int,      // op code
+	      unsigned char *,
+	      unsigned char *);
+
+#endif
diff --git a/drivers/ide/Kconfig b/drivers/ide/Kconfig
index 9a5d0aa..2c5182b 100644
--- a/drivers/ide/Kconfig
+++ b/drivers/ide/Kconfig
@@ -732,6 +732,13 @@ config BLK_DEV_IDE_AT91
 	depends on ARM && ARCH_AT91 && !ARCH_AT91RM9200 && !ARCH_AT91X40
 	select IDE_TIMINGS
 
+config BLK_DEV_TS7200_CF
+	tristate "TS-7200 IDE (CompactFlash) interface support"
+	depends on ARM && ARCH_EP93XX
+	help
+	  Say Y here if you want to support the TS-7200 Compact Flash IDE controller
+	  (manufactured by Technologic Systems).
+
 config BLK_DEV_IDE_ICSIDE
 	tristate "ICS IDE interface support"
 	depends on ARM && ARCH_ACORN
diff --git a/drivers/ide/Makefile b/drivers/ide/Makefile
index 81df925..4bef198 100644
--- a/drivers/ide/Makefile
+++ b/drivers/ide/Makefile
@@ -111,6 +111,7 @@ obj-$(CONFIG_BLK_DEV_PLATFORM)		+= ide_platform.o
 obj-$(CONFIG_BLK_DEV_IDE_ICSIDE)	+= icside.o
 obj-$(CONFIG_BLK_DEV_IDE_RAPIDE)	+= rapide.o
 obj-$(CONFIG_BLK_DEV_PALMCHIP_BK3710)	+= palm_bk3710.o
+obj-$(CONFIG_BLK_DEV_TS7200_CF)		+= ide_ts7200_cf.o
 
 obj-$(CONFIG_BLK_DEV_IDE_AU1XXX)	+= au1xxx-ide.o
 
diff --git a/drivers/ide/ide_ts7200_cf.c b/drivers/ide/ide_ts7200_cf.c
new file mode 100644
index 0000000..14c9765
--- /dev/null
+++ b/drivers/ide/ide_ts7200_cf.c
@@ -0,0 +1,64 @@
+/*
+ *  Technologic Systems TS-7200 Compact Flash IDE device driver.
+ *
+ * (c) Copyright 2009  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <mach/ts72xx.h>
+
+
+static const struct ide_port_info ts7200_cf_ide_port_info = {
+	.host_flags		= IDE_HFLAG_NO_DMA, // IDE_HFLAG_MMIO
+	.chipset		= ide_generic,
+};
+
+static __init int ide_ts7200_cf_init(void)
+{
+  struct ide_hw hw, *hws[] = { &hw };
+  void __iomem *base, *ctl, *data;
+  struct ide_host *host;
+
+  base = ioremap(TS7200_CF_CMD_PHYS_BASE, 0x10);  // 8-bit access
+  ctl  = ioremap(TS7200_CF_AUX_PHYS_BASE, 0x10);  // 8-bit access (usually base+0x206)
+  data = ioremap(TS7200_CF_DATA_PHYS_BASE, 0x10); // 16-bit access
+
+  if ((base != NULL) && (ctl != NULL) && (data != NULL)) {
+    memset(&hw, 0, sizeof(hw));
+
+    ide_std_init_ports(&hw, (unsigned long)base, (unsigned long)ctl);
+    hw.io_ports.data_addr = (unsigned long)data;
+    hw.irq = IRQ_EP93XX_EXT0;
+
+    return ide_host_add(&ts7200_cf_ide_port_info, hws, 1, &host);
+  }
+
+  if (base) iounmap(base);
+  if (ctl)  iounmap(ctl);
+  if (data) iounmap(data);
+
+  return -ENODEV;
+}
+
+
+module_init(ide_ts7200_cf_init);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("TS-7200 Compact Flash IDE driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.2");
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index ee98b1b..3c5c421 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -164,6 +164,48 @@ config KEYBOARD_EP93XX
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called ep93xx_keypad.
+ 
+config KEYBOARD_TS72XX
+	tristate "TS72XX matrix keypad support"
+	depends on MACH_TS72XX
+	help
+	  This driver implements supports for a matrix keypad connected
+	  to EP93XX GPIO port B (aka DIO of TS-72XX SBCs).
+	  Maximum of 4 rows and 4 cols are supported (using up to 4 interrupts).
+	  This is implemented as a platform driver.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ep93xx-keypad.
+
+if KEYBOARD_TS72XX
+	
+choice
+	prompt "Keypad type"
+	default TS72XX_DIO_4X4_KEYPAD
+
+config TS72XX_DIO_3X4_KEYPAD
+	tristate "TS-72xx 3x4 matrix keypad"
+	depends on MACH_TS72XX
+	help
+	  This a 12 keys (4 rows, 3 cols using DIO_0-6) keypad with the following layout:
+	  1 2 3
+	  4 5 6
+	  7 8 9
+	  * 0 #
+
+config TS72XX_DIO_4X4_KEYPAD
+	tristate "TS-72xx 4x4 matrix keypad"
+	depends on MACH_TS72XX
+	help
+	  This a 16 keys (4 rows, 4 cols using DIO_0-7) keypad with the following layout:
+	  7 8 9 F
+	  4 5 6 E
+	  1 2 3 D
+	  A 0 B C
+
+endchoice
+
+endif # KEYBOARD_TS72XX
 
 config KEYBOARD_GPIO
 	tristate "GPIO Buttons"
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index babad5e..1a96733 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -37,3 +37,7 @@ obj-$(CONFIG_KEYBOARD_TOSA)		+= tosakbd.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+
+obj-$(CONFIG_KEYBOARD_TS72XX)		+= ts72xx_keypad.o
+obj-$(CONFIG_TS72XX_DIO_3X4_KEYPAD)	+= ts72xx_dio_3x4.o
+obj-$(CONFIG_TS72XX_DIO_4X4_KEYPAD)	+= ts72xx_dio_4x4.o
diff --git a/drivers/input/keyboard/ep93xx_keypad.c b/drivers/input/keyboard/ep93xx_keypad.c
index 181d30e..0012907 100644
--- a/drivers/input/keyboard/ep93xx_keypad.c
+++ b/drivers/input/keyboard/ep93xx_keypad.c
@@ -23,6 +23,7 @@
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
 #include <linux/input.h>
+#include <linux/io.h>
 #include <linux/clk.h>
 
 #include <mach/hardware.h>
diff --git a/drivers/input/keyboard/ts72xx_dio_3x4.c b/drivers/input/keyboard/ts72xx_dio_3x4.c
new file mode 100644
index 0000000..b149a7a
--- /dev/null
+++ b/drivers/input/keyboard/ts72xx_dio_3x4.c
@@ -0,0 +1,65 @@
+/*
+ *  TS-72xx keypad device driver for DIO1 header (DIO_0 thru DIO_7 are using port B)
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+
+#include <mach/ts72xx-keypad.h>
+
+/* Port B = XX R0 R1 R2 R3 C0 C1 C2
+ * (i.e. col2 is bit 0, row0 is bit 6, ...)
+ */
+static struct ep93xx_gpio_portx_keypad_platform_data kp_portb_3x4 = {
+  .nr_rows = 4,
+  .nr_cols = 3,
+  { { KEY_1, KEY_2, KEY_3 },
+    { KEY_4, KEY_5, KEY_6 },
+    { KEY_7, KEY_8, KEY_9 },
+    { KEY_KPASTERISK, KEY_0, KEY_ENTER }
+  },
+  .gpio_rows = { 6, 5, 4, 3 },
+  .gpio_cols = { 2, 1, 0 },
+};
+
+
+static void ts72xx_dio_release(struct device *dev)
+{
+  // nothing to do (no kfree) because we have static struct
+}
+
+static struct platform_device kp_portb_3x4_device = {
+  .name = "ep93xx-gpio-keypad",
+  .id   = -1, // one instance only
+  .dev    = {
+    .platform_data = &kp_portb_3x4,
+    .release = ts72xx_dio_release,
+  },
+};
+
+static int __init ts72xx_dio_init(void)
+{
+  return platform_device_register(&kp_portb_3x4_device);
+}
+
+static void __exit ts72xx_dio_exit(void)
+{
+  platform_device_unregister(&kp_portb_3x4_device);
+}
+
+module_init(ts72xx_dio_init);
+module_exit(ts72xx_dio_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("Platform device 3x4 keypad");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/keyboard/ts72xx_dio_4x4.c b/drivers/input/keyboard/ts72xx_dio_4x4.c
new file mode 100644
index 0000000..2d8089a
--- /dev/null
+++ b/drivers/input/keyboard/ts72xx_dio_4x4.c
@@ -0,0 +1,65 @@
+/*
+ *  TS-72xx keypad device driver for DIO1 header (DIO_0 thru DIO_7 are using port B)
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+
+#include <mach/ts72xx-keypad.h>
+
+/* Port B = C0 R3 C1 R2 C2 C3 R1 R0
+ * (i.e. row0 is bit 0, row1 is bit 1, ...)
+ */
+static struct ep93xx_gpio_portx_keypad_platform_data kp_portb_4x4 = {
+  .nr_rows = 4,
+  .nr_cols = 4,
+  { { KEY_7, KEY_8, KEY_9, KEY_F },
+    { KEY_4, KEY_5, KEY_6, KEY_E },
+    { KEY_1, KEY_2, KEY_3, KEY_D },
+    { KEY_A, KEY_0, KEY_B, KEY_C }
+  },
+  .gpio_rows = { 0, 1, 4, 6 },
+  .gpio_cols = { 7, 5, 3, 2 },
+};
+
+
+static void ts72xx_dio_release(struct device *dev)
+{
+  // nothing to do (no kfree) because we have static struct
+}
+
+static struct platform_device kp_portb_4x4_device = {
+  .name = "ep93xx-gpio-keypad",
+  .id   = -1, // one instance only
+  .dev    = {
+    .platform_data = &kp_portb_4x4,
+    .release = ts72xx_dio_release,
+  },
+};
+
+static int __init ts72xx_dio_init(void)
+{
+  return platform_device_register(&kp_portb_4x4_device);
+}
+
+static void __exit ts72xx_dio_exit(void)
+{
+  platform_device_unregister(&kp_portb_4x4_device);
+}
+
+module_init(ts72xx_dio_init);
+module_exit(ts72xx_dio_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("Platform device 4x4 keypad");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/keyboard/ts72xx_keypad.c b/drivers/input/keyboard/ts72xx_keypad.c
new file mode 100644
index 0000000..e59d823
--- /dev/null
+++ b/drivers/input/keyboard/ts72xx_keypad.c
@@ -0,0 +1,342 @@
+/*
+ *  TS-72xx "GPIO Port B" input keypad driver
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ * Based on OMAP Keypad Driver (omap-keypad.c)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include <mach/ts72xx-keypad.h>
+
+#define DRV_NAME_PREFIX "ts72xx_keypad: "
+#define DRV_VERSION "3.0"
+
+/* We choose port B */
+#define EP93XX_GPIO_LINE_X      EP93XX_GPIO_LINE_B
+
+#define SCAN_INTERVAL		(150) /* ms */
+
+
+struct ep93xx_gpio_portx_keypad {
+	u8 rows;
+	u8 cols;
+	int irqs[EP93XX_PORTX_MAXROW];
+	u8 mask_input;
+	u8 mask_output;
+	u8 row_trigger, col_trigger;
+	u8 mask_input_trigger;
+	struct timer_list timer;
+	struct input_dev *input;
+	struct ep93xx_gpio_portx_keypad_platform_data *rsc;
+};
+
+static void ep93xx_gpio_portx_tasklet(unsigned long);
+static void ep93xx_gpio_portx_timer(unsigned long);
+
+DECLARE_TASKLET_DISABLED(kp_tasklet, ep93xx_gpio_portx_tasklet, 0);
+
+
+static void ep93xx_gpio_portx_timer(unsigned long data)
+{
+	struct ep93xx_gpio_portx_keypad *ctx = (struct ep93xx_gpio_portx_keypad *)data;
+	int i;
+
+	for (i = 0; i < ctx->rows; i++)
+		enable_irq(ctx->irqs[i]);
+}
+
+/* This should be atomic */
+static inline u8 ep93xx_gpio_read_portx(u8 mask)
+{
+	u8 data = (!!gpio_get_value(EP93XX_GPIO_LINE_X(7))) << 7;
+	data |= (!!gpio_get_value(EP93XX_GPIO_LINE_X(6))) << 6;
+	data |= (!!gpio_get_value(EP93XX_GPIO_LINE_X(5))) << 5;
+	data |= (!!gpio_get_value(EP93XX_GPIO_LINE_X(4))) << 4;
+	data |= (!!gpio_get_value(EP93XX_GPIO_LINE_X(3))) << 3;
+	data |= (!!gpio_get_value(EP93XX_GPIO_LINE_X(2))) << 2;
+	data |= (!!gpio_get_value(EP93XX_GPIO_LINE_X(1))) << 1;
+	data |= (!!gpio_get_value(EP93XX_GPIO_LINE_X(0)));
+	return (data & mask);
+}
+
+/* This should be atomic */
+static inline void ep93xx_gpio_write_portx(u8 value, u8 mask)
+{
+	if (mask & 0x01)
+		gpio_set_value(EP93XX_GPIO_LINE_X(0), value & 0x01);
+	if (mask & 0x02)
+		gpio_set_value(EP93XX_GPIO_LINE_X(1), value & 0x02);
+	if (mask & 0x04)
+		gpio_set_value(EP93XX_GPIO_LINE_X(2), value & 0x04);
+	if (mask & 0x08)
+		gpio_set_value(EP93XX_GPIO_LINE_X(3), value & 0x08);
+	if (mask & 0x10)
+		gpio_set_value(EP93XX_GPIO_LINE_X(4), value & 0x10);
+	if (mask & 0x20)
+		gpio_set_value(EP93XX_GPIO_LINE_X(5), value & 0x20);
+	if (mask & 0x40)
+		gpio_set_value(EP93XX_GPIO_LINE_X(6), value & 0x40);
+	if (mask & 0x80)
+		gpio_set_value(EP93XX_GPIO_LINE_X(7), value & 0x80);
+}
+
+static void ep93xx_gpio_portx_tasklet(unsigned long data)
+{
+	struct ep93xx_gpio_portx_keypad *ctx = (struct ep93xx_gpio_portx_keypad *)data;
+	int i, j;
+	u8 save;
+
+	/* Save data register */
+	save = ep93xx_gpio_read_portx(ctx->mask_input | ctx->mask_output);
+
+	/* Make sure row is still 0 */
+	if (!(save & ctx->mask_input_trigger)) {
+
+		for (i = 0; i < ctx->cols; i++) {
+			for (j = 0; j < ctx->cols; j++) {
+				if (i == j)
+					gpio_set_value(EP93XX_GPIO_LINE_X(ctx->rsc->gpio_cols[j]), 1); //high
+				else
+					gpio_set_value(EP93XX_GPIO_LINE_X(ctx->rsc->gpio_cols[j]), 0); //low
+			}
+
+			if (ep93xx_gpio_read_portx(ctx->mask_input | ctx->mask_output) &
+					ctx->mask_input_trigger) {
+				ctx->col_trigger = i;
+				//printk("=>key col=%d, row=%d |%x\n", i, ctx->row_trigger, ctx->rsc->keycodes[ctx->row_trigger][i]);
+				input_report_key(ctx->input, ctx->rsc->keycodes[ctx->row_trigger][ctx->col_trigger], 1);
+				input_sync(ctx->input);
+			}
+		}
+
+	} else { // key released
+		input_report_key(ctx->input, ctx->rsc->keycodes[ctx->row_trigger][ctx->col_trigger], 0);
+		input_sync(ctx->input);
+	}
+
+	/* Restore all outputs to 0 */
+	ep93xx_gpio_write_portx(save, ctx->mask_input | ctx->mask_output);
+
+	/* Wait a little before enabling IRQ again */
+	mod_timer(&ctx->timer, jiffies + msecs_to_jiffies(SCAN_INTERVAL));
+}
+
+/* Interrupt handler */
+static irqreturn_t ep93xx_gpio_portx_key_int(int irq, void *dev_id)
+{
+	struct ep93xx_gpio_portx_keypad *ctx = dev_id;
+	int i;
+
+	for (i = 0; i < ctx->rows; i++) {
+		if (ctx->irqs[i] == irq)
+			disable_irq_nosync(ctx->irqs[i]);
+		else
+			disable_irq(ctx->irqs[i]);
+	}
+
+	ctx->mask_input_trigger = 0;
+	for (i = 0; i < ctx->rows; i++) {
+		if (gpio_to_irq(EP93XX_GPIO_LINE_X(ctx->rsc->gpio_rows[i])) == irq) {
+			ctx->row_trigger = i;
+			ctx->mask_input_trigger = (1 << ctx->rsc->gpio_rows[i]);
+			break;
+		}
+	}
+
+	// deferred-execution method
+	tasklet_schedule(&kp_tasklet);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit ep93xx_keypad_probe(struct platform_device *pdev)
+{
+	struct ep93xx_gpio_portx_keypad *ctx;
+	struct input_dev *input_dev;
+	int i, j, ret, irq_idx;
+	struct ep93xx_gpio_portx_keypad_platform_data *pdata =  pdev->dev.platform_data;
+
+	const char *irq_names[EP93XX_PORTX_MAXROW] = {
+		"kp-row0", "kp-row1", "kp-row2", "kp-row3" };
+
+	if (pdata == NULL) {
+		return -EINVAL;
+	}
+
+	if (!pdata->nr_rows || !pdata->nr_cols ||
+			(pdata->nr_rows > EP93XX_PORTX_MAXROW) ||
+			(pdata->nr_cols > EP93XX_PORTX_MAXCOL)) {
+		dev_err(&pdev->dev, "No rows, cols from pdata\n");
+		return -EINVAL;
+	}
+
+	ctx = kzalloc(sizeof(struct ep93xx_gpio_portx_keypad), GFP_KERNEL);
+	if (!ctx) {
+		return -ENOMEM;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		kfree(ctx);
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, ctx);
+
+	ctx->input = input_dev;
+	ctx->rsc   = pdata;
+	ctx->rows  = pdata->nr_rows;
+	ctx->cols  = pdata->nr_cols;
+
+	input_dev->evbit[0] = BIT(EV_KEY); // | BIT(EV_REP);
+
+	for (i = 0; i < pdata->nr_rows; i++) {
+		for (j = 0; j < pdata->nr_cols; j++) {
+			int code = pdata->keycodes[i][j];
+			if (code > 0)
+				set_bit(code, input_dev->keybit);
+		}
+	}
+	__clear_bit(KEY_RESERVED, input_dev->keybit);
+
+	input_dev->name = "GPIO keypad";
+	input_dev->phys = "ep93xx-keypad/input0";
+	input_dev->dev.parent = &pdev->dev;
+
+	input_dev->id.bustype = BUS_HOST;
+	input_dev->id.vendor  = 0x0001;
+	input_dev->id.product = 0x0001;
+	input_dev->id.version = 0x0100;
+
+	ret = input_register_device(ctx->input);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Unable to register input device\n");
+		goto err1;
+	}
+
+	ctx->mask_output = 0;
+	for (i = 0; i < pdata->nr_cols; i++) {
+		ctx->mask_output |= (1 << pdata->gpio_cols[i]);
+		ret = gpio_request(EP93XX_GPIO_LINE_X(pdata->gpio_cols[i]), dev_name(&pdev->dev));
+		gpio_direction_output(EP93XX_GPIO_LINE_X(pdata->gpio_cols[i]), 0); // low
+	}
+
+	ctx->mask_input = 0;
+	for (i = 0; i < pdata->nr_rows; i++) {
+		ctx->mask_input |= (1 << pdata->gpio_rows[i]);
+		ret = gpio_request(EP93XX_GPIO_LINE_X(pdata->gpio_rows[i]), dev_name(&pdev->dev));
+		gpio_direction_input(EP93XX_GPIO_LINE_X(pdata->gpio_rows[i]));
+	}
+
+	for (i = 0; i < pdata->nr_rows; i++) {
+		ctx->irqs[i] = gpio_to_irq(EP93XX_GPIO_LINE_X(pdata->gpio_rows[i]));
+		set_irq_type(ctx->irqs[i], IRQ_TYPE_EDGE_FALLING);
+		ep93xx_gpio_int_debounce(ctx->irqs[i], 1);
+
+		ret = request_irq(ctx->irqs[i], ep93xx_gpio_portx_key_int, 0, irq_names[i], ctx);
+		if (ret < 0) {
+			irq_idx = i;
+			dev_err(&pdev->dev, "request_irq (%d)\n", ctx->irqs[i]);
+			goto err2;
+		}
+	}
+
+	tasklet_enable(&kp_tasklet);
+	kp_tasklet.data = (unsigned long)ctx;
+
+	setup_timer(&ctx->timer, ep93xx_gpio_portx_timer, (unsigned long)ctx);
+
+	return 0;
+
+err2:
+	for (i = 0; i <= irq_idx; i++)
+		free_irq(ctx->irqs[i], ctx);
+	for (i = 0; i < ctx->cols; i++)
+		gpio_free(EP93XX_GPIO_LINE_X(ctx->rsc->gpio_cols[i]));
+	for (i = 0; i < ctx->rows; i++)
+		gpio_free(EP93XX_GPIO_LINE_X(ctx->rsc->gpio_rows[i]));
+
+	input_unregister_device(input_dev);
+	input_dev = NULL;
+err1:
+	kfree(ctx);
+	input_free_device(input_dev);
+
+	return -EINVAL;
+}
+
+static int __devexit ep93xx_keypad_remove(struct platform_device *pdev)
+{
+	struct ep93xx_gpio_portx_keypad *ctx = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < ctx->rows; i++) {
+		disable_irq(ctx->irqs[i]);
+		free_irq(ctx->irqs[i], ctx);
+	}
+
+	del_timer_sync(&ctx->timer);
+
+	tasklet_disable(&kp_tasklet);
+	tasklet_kill(&kp_tasklet);
+
+	for (i = 0; i < ctx->cols; i++)
+		gpio_free(EP93XX_GPIO_LINE_X(ctx->rsc->gpio_cols[i]));
+	for (i = 0; i < ctx->rows; i++)
+		gpio_free(EP93XX_GPIO_LINE_X(ctx->rsc->gpio_rows[i]));
+
+	input_unregister_device(ctx->input);
+	kfree(ctx);
+
+	return 0;
+}
+
+
+#define ep93xx_keypad_suspend NULL
+#define ep93xx_keypad_resume  NULL
+
+static struct platform_driver ep93xx_keypad_driver = {
+	.driver   = {
+		.name = "ep93xx-gpio-keypad",
+		.owner  = THIS_MODULE,
+	},
+	.probe    = ep93xx_keypad_probe,
+	.remove   = __devexit_p(ep93xx_keypad_remove),
+	.suspend  = ep93xx_keypad_suspend,
+	.resume   = ep93xx_keypad_resume,
+};
+
+static int __init ep93xx_keypad_init(void)
+{
+	printk(KERN_INFO DRV_NAME_PREFIX "platform driver v" DRV_VERSION "\n");
+	return platform_driver_register(&ep93xx_keypad_driver);
+}
+
+static void __exit ep93xx_keypad_exit(void)
+{
+	platform_driver_unregister(&ep93xx_keypad_driver);
+}
+
+module_init(ep93xx_keypad_init);
+module_exit(ep93xx_keypad_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("EP93xx GPIO port B keypad driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
diff --git a/drivers/mtd/maps/Kconfig b/drivers/mtd/maps/Kconfig
index 14be075..bc20ac9 100644
--- a/drivers/mtd/maps/Kconfig
+++ b/drivers/mtd/maps/Kconfig
@@ -445,6 +445,14 @@ config MTD_OMAP_NOR
 	  These boards include the Innovator, H2, H3, OSK, Perseus2, and
 	  more.  If you have such a board, say 'Y'.
 
+config MTD_TS7200_NOR
+	tristate "Technologic Systems TS-7200 flash 8Mb"
+	depends on MTD_CFI && ARCH_EP93XX
+	help
+	  This provides a map driver for the on-board flash of the Technologic
+	  System's TS-7200 board. The 8MB flash is splitted into 3 partitions
+	  which are accessed as separate MTD devices.
+
 # This needs CFI or JEDEC, depending on the cards found.
 config MTD_PCI
 	tristate "PCI MTD driver"
diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile
index ae2f6db..fb04757 100644
--- a/drivers/mtd/maps/Makefile
+++ b/drivers/mtd/maps/Makefile
@@ -58,6 +58,7 @@ obj-$(CONFIG_MTD_PLATRAM)	+= plat-ram.o
 obj-$(CONFIG_MTD_OMAP_NOR)	+= omap_nor.o
 obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_vr_nor.o
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
+obj-$(CONFIG_MTD_TS7200_NOR)	+= ts7200_flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
diff --git a/drivers/mtd/maps/ts7200_flash.c b/drivers/mtd/maps/ts7200_flash.c
new file mode 100644
index 0000000..efc5f00
--- /dev/null
+++ b/drivers/mtd/maps/ts7200_flash.c
@@ -0,0 +1,106 @@
+/*
+ * ts7200_flash.c - mapping for TS-7200 SBCs (8mb NOR flash)
+ * No platform_device resource is used here. All is hardcoded.
+ *
+ * (c) Copyright 2006  Matthieu Crapet <mcrapet@gmail.com>
+ * Based on ts5500_flash.c by Sean Young <sean@mess.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/io.h>
+#include <asm/sizes.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#define WINDOW_ADDR          0x60000000
+#define WINDOW_SIZE          SZ_8M
+#define WINDOW_READABLE_SIZE (WINDOW_SIZE/SZ_1M)
+
+
+static struct mtd_info *mymtd;
+
+static struct map_info ts7200nor_map = {
+  .name = "Full TS-7200 NOR flash",
+  .size = WINDOW_SIZE,
+  .bankwidth = 2,
+  .phys = WINDOW_ADDR,
+};
+
+/*
+ * MTD partitioning stuff
+ */
+#ifdef CONFIG_MTD_PARTITIONS
+static struct mtd_partition static_partitions[] =
+{
+  {
+    .name   = "TS-BOOTROM",
+    .offset = 0,
+    .size   = 0x20000,
+    .mask_flags = MTD_WRITEABLE,  /* force read-only */
+  },
+  {
+    .name   = "RootFS",
+    .offset = 0x20000,
+    .size   = 0x600000,
+  },
+  {
+    .name   = "Redboot",
+    .offset = 0x620000,
+    .size   = MTDPART_SIZ_FULL,   /* up to the end */
+  },
+};
+#endif
+
+int __init init_ts7200nor(void)
+{
+  printk(KERN_NOTICE "TS-7200 flash mapping: %dmo at 0x%x\n", WINDOW_READABLE_SIZE, WINDOW_ADDR);
+
+  ts7200nor_map.virt = ioremap(WINDOW_ADDR, WINDOW_SIZE);
+  if (!ts7200nor_map.virt) {
+    printk("ts7200_flash: failed to ioremap\n");
+    return -EIO;
+  }
+
+  simple_map_init(&ts7200nor_map);
+  mymtd = do_map_probe("cfi_probe", &ts7200nor_map);
+  if (mymtd) {
+    mymtd->owner = THIS_MODULE;
+    add_mtd_device(mymtd);
+#ifdef CONFIG_MTD_PARTITIONS
+    return add_mtd_partitions(mymtd, static_partitions, ARRAY_SIZE(static_partitions));
+#else
+    return 0;
+#endif
+  }
+
+  iounmap((void *)ts7200nor_map.virt);
+  return -ENXIO;
+}
+
+static void __exit cleanup_ts7200nor(void)
+{
+  if (mymtd) {
+    del_mtd_device(mymtd);
+    map_destroy(mymtd);
+  }
+  if (ts7200nor_map.virt) {
+    iounmap((void *)ts7200nor_map.virt);
+    ts7200nor_map.virt = 0;
+  }
+}
+
+module_init(init_ts7200nor);
+module_exit(cleanup_ts7200nor);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("MTD map driver for TS-7200 board (" __MODULE_STRING(WINDOW_READABLE_SIZE) "MB flash version)");
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index b2f71f7..485d22a 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -236,6 +236,16 @@ config AX88796_93CX6
 	help
 	  Select this if your platform comes with an external 93CX6 eeprom.
 
+config AX88796_TS_ETH100
+	tristate "Support for TS-ETH100 (TS-72XX SBC)"
+	depends on AX88796 && MACH_TS72XX
+	help
+	  Say Y here if you have a TS-ETH100 PC/104 peripheral.
+	  IRQ numbers and I/O address will be configurated automatically.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called ax88796_ts_eth100.
+
 config MACE
 	tristate "MACE (Power Mac ethernet) support"
 	depends on PPC_PMAC && PPC32
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 246323d..ef10c5e 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -140,6 +140,7 @@ obj-$(CONFIG_B44) += b44.o
 obj-$(CONFIG_FORCEDETH) += forcedeth.o
 obj-$(CONFIG_NE_H8300) += ne-h8300.o 8390.o
 obj-$(CONFIG_AX88796) += ax88796.o
+obj-$(CONFIG_AX88796_TS_ETH100) += ax88796_ts_eth100.o
 obj-$(CONFIG_BCM63XX_ENET) += bcm63xx_enet.o
 
 obj-$(CONFIG_TSI108_ETH) += tsi108_eth.o
diff --git a/drivers/net/arm/Kconfig b/drivers/net/arm/Kconfig
index c37ee9e..a5f2a98 100644
--- a/drivers/net/arm/Kconfig
+++ b/drivers/net/arm/Kconfig
@@ -52,6 +52,7 @@ config EP93XX_ETH
 	tristate "EP93xx Ethernet support"
 	depends on ARM && ARCH_EP93XX
 	select MII
+	select PHYLIB
 	help
 	  This is a driver for the ethernet hardware included in EP93xx CPUs.
 	  Say Y if you are building a kernel for EP93xx based devices.
diff --git a/drivers/net/arm/ep93xx_eth.c b/drivers/net/arm/ep93xx_eth.c
index b25467a..923a21b 100644
--- a/drivers/net/arm/ep93xx_eth.c
+++ b/drivers/net/arm/ep93xx_eth.c
@@ -2,6 +2,7 @@
  * EP93xx ethernet network device driver
  * Copyright (C) 2006 Lennert Buytenhek <buytenh@wantstofly.org>
  * Dedicated to Marija Kulikova.
+ * Copyright (C) 2007 Herbert Valerio Riedel <hvr@gnu.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,6 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/netdevice.h>
 #include <linux/mii.h>
+#include <linux/phy.h>
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
 #include <linux/init.h>
@@ -25,7 +27,7 @@
 #include <asm/io.h>
 
 #define DRV_MODULE_NAME		"ep93xx-eth"
-#define DRV_MODULE_VERSION	"0.1"
+#define DRV_MODULE_VERSION	"0.12"
 
 #define RX_QUEUE_ENTRIES	64
 #define TX_QUEUE_ENTRIES	8
@@ -37,6 +39,8 @@
 #define  REG_RXCTL_DEFAULT	0x00073800
 #define REG_TXCTL		0x0004
 #define  REG_TXCTL_ENABLE	0x00000001
+#define REG_TESTCTL		0x0008
+#define  REG_TESTCTL_MFDX	0x00000040
 #define REG_MIICMD		0x0010
 #define  REG_MIICMD_READ	0x00008000
 #define  REG_MIICMD_WRITE	0x00004000
@@ -45,6 +49,9 @@
 #define  REG_MIISTS_BUSY	0x00000001
 #define REG_SELFCTL		0x0020
 #define  REG_SELFCTL_RESET	0x00000001
+#define  REG_SELFCTL_MDCDIV_MSK	0x00007e00
+#define  REG_SELFCTL_MDCDIV_OFS	9
+#define  REG_SELFCTL_PSPRS	0x00000100
 #define REG_INTEN		0x0024
 #define  REG_INTEN_TX		0x00000008
 #define  REG_INTEN_RX		0x00000007
@@ -174,8 +181,14 @@ struct ep93xx_priv
 
 	struct net_device_stats	stats;
 
-	struct mii_if_info	mii;
 	u8			mdc_divisor;
+	int     phy_supports_mfps:1;
+
+	struct mii_bus    mii_bus;
+	struct phy_device *phy_dev;
+	int     speed;
+	int     duplex;
+	int     link;
 };
 
 #define rdb(ep, off)		__raw_readb((ep)->base_addr + (off))
@@ -185,8 +198,6 @@ struct ep93xx_priv
 #define wrw(ep, off, val)	__raw_writew((val), (ep)->base_addr + (off))
 #define wrl(ep, off, val)	__raw_writel((val), (ep)->base_addr + (off))
 
-static int ep93xx_mdio_read(struct net_device *dev, int phy_id, int reg);
-
 static struct net_device_stats *ep93xx_get_stats(struct net_device *dev)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
@@ -522,6 +533,22 @@ err:
 	return 1;
 }
 
+static int ep93xx_mdio_reset(struct mii_bus *bus)
+{
+  struct ep93xx_priv *ep = bus->priv;
+
+  u32 selfctl = rdl(ep, REG_SELFCTL);
+
+  selfctl &= ~(REG_SELFCTL_MDCDIV_MSK | REG_SELFCTL_PSPRS);
+
+  selfctl |= (ep->mdc_divisor - 1) << REG_SELFCTL_MDCDIV_OFS;
+  selfctl |= REG_SELFCTL_PSPRS;
+
+  wrl(ep, REG_SELFCTL, selfctl);
+
+  return 0;
+}
+
 static int ep93xx_start_hw(struct net_device *dev)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
@@ -540,11 +567,8 @@ static int ep93xx_start_hw(struct net_device *dev)
 		return 1;
 	}
 
-	wrl(ep, REG_SELFCTL, ((ep->mdc_divisor - 1) << 9));
-
-	/* Does the PHY support preamble suppress?  */
-	if ((ep93xx_mdio_read(dev, ep->mii.phy_id, MII_BMSR) & 0x0040) != 0)
-		wrl(ep, REG_SELFCTL, ((ep->mdc_divisor - 1) << 9) | (1 << 8));
+	/* The reset cleared REG_SELFCTL, so set the MDC divisor again */
+	ep93xx_mdio_reset(&ep->mii_bus);
 
 	/* Receive descriptor ring.  */
 	addr = ep->descs_dma_addr + offsetof(struct ep93xx_descs, rdesc);
@@ -653,6 +677,8 @@ static int ep93xx_open(struct net_device *dev)
 
 	wrl(ep, REG_GIINTMSK, REG_GIINTMSK_ENABLE);
 
+	phy_start(ep->phy_dev);
+
 	netif_start_queue(dev);
 
 	return 0;
@@ -665,6 +691,9 @@ static int ep93xx_close(struct net_device *dev)
 	napi_disable(&ep->napi);
 	netif_stop_queue(dev);
 
+	if (ep->phy_dev)
+		phy_stop(ep->phy_dev);
+
 	wrl(ep, REG_GIINTMSK, 0);
 	free_irq(ep->irq, dev);
 	ep93xx_stop_hw(dev);
@@ -676,51 +705,83 @@ static int ep93xx_close(struct net_device *dev)
 static int ep93xx_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
-	struct mii_ioctl_data *data = if_mii(ifr);
 
-	return generic_mii_ioctl(&ep->mii, data, cmd, NULL);
+	return phy_mii_ioctl(ep->phy_dev, if_mii(ifr), cmd);
 }
 
-static int ep93xx_mdio_read(struct net_device *dev, int phy_id, int reg)
+/* common MII transactions should take < 100 iterations */
+#define EP93XX_PHY_TIMEOUT 2000
+
+static int ep93xx_mdio_wait(struct mii_bus *bus)
 {
-	struct ep93xx_priv *ep = netdev_priv(dev);
-	int data;
-	int i;
+	struct ep93xx_priv *ep = bus->priv;
+	unsigned int timeout = EP93XX_PHY_TIMEOUT;
 
-	wrl(ep, REG_MIICMD, REG_MIICMD_READ | (phy_id << 5) | reg);
+	while ((rdl(ep, REG_MIISTS) & REG_MIISTS_BUSY)
+			&& timeout--)
+		cpu_relax();
 
-	for (i = 0; i < 10; i++) {
-		if ((rdl(ep, REG_MIISTS) & REG_MIISTS_BUSY) == 0)
-			break;
-		msleep(1);
+	if (timeout <= 0) {
+		dev_err(&bus->dev, "MII operation timed out\n");
+		return -ETIMEDOUT;
 	}
 
-	if (i == 10) {
-		printk(KERN_INFO DRV_MODULE_NAME ": mdio read timed out\n");
-		data = 0xffff;
-	} else {
-		data = rdl(ep, REG_MIIDATA);
-	}
+	return 0;
+}
+
+static int ep93xx_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
+{
+	struct ep93xx_priv *ep = bus->priv;
+	u32 selfctl;
+	u32 data;
+
+	if (ep93xx_mdio_wait(bus) < 0)
+		return -ETIMEDOUT;
+
+	selfctl = rdl(ep, REG_SELFCTL);
+
+	if (ep->phy_supports_mfps)
+		wrl(ep, REG_SELFCTL, selfctl | REG_SELFCTL_PSPRS);
+	else
+		wrl(ep, REG_SELFCTL, selfctl & ~REG_SELFCTL_PSPRS);
+
+	wrl(ep, REG_MIICMD, REG_MIICMD_READ | (mii_id << 5) | regnum);
+
+	if (ep93xx_mdio_wait(bus) < 0)
+		return -ETIMEDOUT;
+
+	data =  rdl(ep, REG_MIIDATA);
+
+	wrl(ep, REG_SELFCTL, selfctl);
 
 	return data;
 }
 
-static void ep93xx_mdio_write(struct net_device *dev, int phy_id, int reg, int data)
+static int ep93xx_mdio_write(struct mii_bus *bus, int mii_id, int regnum,
+          u16 value)
 {
-	struct ep93xx_priv *ep = netdev_priv(dev);
-	int i;
+	struct ep93xx_priv *ep = bus->priv;
+	u32 selfctl;
 
-	wrl(ep, REG_MIIDATA, data);
-	wrl(ep, REG_MIICMD, REG_MIICMD_WRITE | (phy_id << 5) | reg);
+	if (ep93xx_mdio_wait(bus) < 0)
+		return -ETIMEDOUT;
 
-	for (i = 0; i < 10; i++) {
-		if ((rdl(ep, REG_MIISTS) & REG_MIISTS_BUSY) == 0)
-			break;
-		msleep(1);
-	}
+	selfctl = rdl(ep, REG_SELFCTL);
 
-	if (i == 10)
-		printk(KERN_INFO DRV_MODULE_NAME ": mdio write timed out\n");
+	if (ep->phy_supports_mfps)
+		wrl(ep, REG_SELFCTL, selfctl | REG_SELFCTL_PSPRS);
+	else
+		wrl(ep, REG_SELFCTL, selfctl & ~REG_SELFCTL_PSPRS);
+
+	wrl(ep, REG_MIIDATA, value);
+	wrl(ep, REG_MIICMD, REG_MIICMD_WRITE | (mii_id << 5) | regnum);
+
+	if (ep93xx_mdio_wait(bus) < 0)
+		return -ETIMEDOUT;
+
+	wrl(ep, REG_SELFCTL, selfctl);
+
+	return 0;
 }
 
 static void ep93xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
@@ -732,33 +793,30 @@ static void ep93xx_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *i
 static int ep93xx_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
-	return mii_ethtool_gset(&ep->mii, cmd);
+	struct phy_device *phydev = ep->phy_dev;
+
+	if (!phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
 }
 
 static int ep93xx_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	struct ep93xx_priv *ep = netdev_priv(dev);
-	return mii_ethtool_sset(&ep->mii, cmd);
-}
+	struct phy_device *phydev = ep->phy_dev;
 
-static int ep93xx_nway_reset(struct net_device *dev)
-{
-	struct ep93xx_priv *ep = netdev_priv(dev);
-	return mii_nway_restart(&ep->mii);
-}
+	if (!phydev)
+		return -ENODEV;
 
-static u32 ep93xx_get_link(struct net_device *dev)
-{
-	struct ep93xx_priv *ep = netdev_priv(dev);
-	return mii_link_ok(&ep->mii);
+	return phy_ethtool_sset(phydev, cmd);
 }
 
 static const struct ethtool_ops ep93xx_ethtool_ops = {
 	.get_drvinfo		= ep93xx_get_drvinfo,
 	.get_settings		= ep93xx_get_settings,
 	.set_settings		= ep93xx_set_settings,
-	.nway_reset		= ep93xx_nway_reset,
-	.get_link		= ep93xx_get_link,
+	.get_link		= ethtool_op_get_link,
 };
 
 static const struct net_device_ops ep93xx_netdev_ops = {
@@ -820,12 +878,122 @@ static int ep93xx_eth_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static void ep93xx_adjust_link(struct net_device *dev)
+{
+  struct ep93xx_priv *ep = netdev_priv(dev);
+  struct phy_device *phydev = ep->phy_dev;
+
+  int status_change = 0;
+
+  if (phydev->link) {
+    if ((ep->speed != phydev->speed) ||
+        (ep->duplex != phydev->duplex)) {
+      /* speed and/or duplex state changed */
+      u32 testctl = rdl(ep, REG_TESTCTL);
+
+      if (DUPLEX_FULL == phydev->duplex)
+        testctl |= REG_TESTCTL_MFDX;
+      else
+        testctl &= ~(REG_TESTCTL_MFDX);
+
+      wrl(ep, REG_TESTCTL, testctl);
+
+      ep->speed = phydev->speed;
+      ep->duplex = phydev->duplex;
+      status_change = 1;
+    }
+  }
+
+  /* test for online/offline link transition */
+  if (phydev->link != ep->link) {
+    if (phydev->link) /* link went online */
+      netif_tx_schedule_all(dev);
+    else { /* link went offline */
+      ep->speed = 0;
+      ep->duplex = -1;
+    }
+    ep->link = phydev->link;
+
+    status_change = 1;
+  }
+
+  if (status_change)
+    phy_print_status(phydev);
+}
+
+static int ep93xx_mii_probe(struct net_device *dev, int phy_addr)
+{
+  struct ep93xx_priv *ep = netdev_priv(dev);
+  struct phy_device *phydev = NULL;
+  int val;
+
+  if (phy_addr >= 0 && phy_addr < PHY_MAX_ADDR)
+    phydev = ep->mii_bus.phy_map[phy_addr];
+
+  if (!phydev) {
+    dev_info(&dev->dev,
+       "PHY not found at specified address,"
+       " trying autodetection\n");
+
+    /* find the first phy */
+    for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+      if (ep->mii_bus.phy_map[phy_addr]) {
+        phydev = ep->mii_bus.phy_map[phy_addr];
+        break;
+      }
+    }
+  }
+
+  if (!phydev) {
+    dev_err(&dev->dev, "no PHY found\n");
+    return -ENODEV;
+  }
+
+  phydev = phy_connect(dev, dev_name(&phydev->dev),
+           ep93xx_adjust_link, 0, PHY_INTERFACE_MODE_MII);
+
+  if (IS_ERR(phydev)) {
+    dev_err(&dev->dev, "Could not attach to PHY\n");
+    return PTR_ERR(phydev);
+  }
+
+  ep->phy_supports_mfps = 0;
+
+  val = phy_read(phydev, MII_BMSR);
+  if (val < 0) {
+    dev_err(&phydev->dev, "failed to read MII register\n");
+    return val;
+  }
+
+  if (val & 0x0040) {
+    dev_info(&phydev->dev,
+       "PHY supports MII frame preamble suppression\n");
+    ep->phy_supports_mfps = 1;
+  }
+
+  phydev->supported &= PHY_BASIC_FEATURES;
+
+  phydev->advertising = phydev->supported;
+
+  ep->link = 0;
+  ep->speed = 0;
+  ep->duplex = -1;
+  ep->phy_dev = phydev;
+
+  dev_info(&dev->dev, "attached PHY driver [%s] "
+     "(mii_bus:phy_addr=%s, irq=%d)\n",
+     phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
+
+  return 0;
+}
+
 static int ep93xx_eth_probe(struct platform_device *pdev)
 {
 	struct ep93xx_eth_data *data;
 	struct net_device *dev;
 	struct ep93xx_priv *ep;
-	int err;
+	DECLARE_MAC_BUF(mac_buf);
+	int err, i;
 
 	if (pdev == NULL)
 		return -ENODEV;
@@ -848,7 +1016,7 @@ static int ep93xx_eth_probe(struct platform_device *pdev)
 	if (ep->res == NULL) {
 		dev_err(&pdev->dev, "Could not reserve memory region\n");
 		err = -ENOMEM;
-		goto err_out;
+		goto err_out_request_mem_region;
 	}
 
 	ep->base_addr = ioremap(pdev->resource[0].start,
@@ -856,17 +1024,36 @@ static int ep93xx_eth_probe(struct platform_device *pdev)
 	if (ep->base_addr == NULL) {
 		dev_err(&pdev->dev, "Failed to ioremap ethernet registers\n");
 		err = -EIO;
-		goto err_out;
+		goto err_out_ioremap;
 	}
 	ep->irq = pdev->resource[1].start;
 
-	ep->mii.phy_id = data->phy_id;
-	ep->mii.phy_id_mask = 0x1f;
-	ep->mii.reg_num_mask = 0x1f;
-	ep->mii.dev = dev;
-	ep->mii.mdio_read = ep93xx_mdio_read;
-	ep->mii.mdio_write = ep93xx_mdio_write;
+	/* mdio/mii bus */
+	ep->mii_bus.state = MDIOBUS_ALLOCATED; /* see mdiobus_alloc */
+	ep->mii_bus.name = "ep93xx_mii_bus";
+	snprintf(ep->mii_bus.id, MII_BUS_ID_SIZE, "0");
+
+	ep->mii_bus.read = ep93xx_mdio_read;
+	ep->mii_bus.write = ep93xx_mdio_write;
+	ep->mii_bus.reset = ep93xx_mdio_reset;
+
+	ep->mii_bus.phy_mask = 0;
+
+	ep->mii_bus.priv = ep;
+	ep->mii_bus.dev = dev->dev;
+
+	ep->mii_bus.irq = kmalloc(sizeof(int)*PHY_MAX_ADDR, GFP_KERNEL);
+	if (NULL == ep->mii_bus.irq) {
+		dev_err(&pdev->dev, "Could not allocate memory\n");
+		err = -ENOMEM;
+		goto err_out_mii_bus_irq_kmalloc;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		ep->mii_bus.irq[i] = PHY_POLL;
+
 	ep->mdc_divisor = 40;	/* Max HCLK 100 MHz, min MDIO clk 2.5 MHz.  */
+	ep->phy_supports_mfps = 0; /* probe without preamble suppression */
 
 	if (is_zero_ether_addr(dev->dev_addr))
 		random_ether_addr(dev->dev_addr);
@@ -874,7 +1061,7 @@ static int ep93xx_eth_probe(struct platform_device *pdev)
 	err = register_netdev(dev);
 	if (err) {
 		dev_err(&pdev->dev, "Failed to register netdev\n");
-		goto err_out;
+		goto err_out_register_netdev;
 	}
 
 	printk(KERN_INFO "%s: ep93xx on-chip ethernet, IRQ %d, "
@@ -883,8 +1070,36 @@ static int ep93xx_eth_probe(struct platform_device *pdev)
 			data->dev_addr[2], data->dev_addr[3],
 			data->dev_addr[4], data->dev_addr[5]);
 
+	err = mdiobus_register(&ep->mii_bus);
+	if (err) {
+		dev_err(&dev->dev, "Could not register MII bus\n");
+		goto err_out_mdiobus_register;
+	}
+
+	err = ep93xx_mii_probe(dev, data->phy_id);
+	if (err) {
+		dev_err(&dev->dev, "failed to probe MII bus\n");
+		goto err_out_mii_probe;
+	}
+
+	dev_info(&dev->dev, "ep93xx on-chip ethernet, IRQ %d, %s\n",
+			ep->irq, print_mac(mac_buf, dev->dev_addr));
+
 	return 0;
 
+err_out_mii_probe:
+	mdiobus_unregister(&ep->mii_bus);
+err_out_mdiobus_register:
+	unregister_netdev(dev);
+err_out_register_netdev:
+	kfree(ep->mii_bus.irq);
+err_out_mii_bus_irq_kmalloc:
+	iounmap(ep->base_addr);
+err_out_ioremap:
+	release_resource(ep->res);
+	kfree(ep->res);
+err_out_request_mem_region:
+	free_netdev(dev);
 err_out:
 	ep93xx_eth_remove(pdev);
 	return err;
diff --git a/drivers/net/ax88796.c b/drivers/net/ax88796.c
index 62d9c9c..5cf29f5 100644
--- a/drivers/net/ax88796.c
+++ b/drivers/net/ax88796.c
@@ -934,7 +934,11 @@ static int ax_probe(struct platform_device *pdev)
 			goto exit_mem2;
 		}
 
+    #ifdef CONFIG_AX88796_TS_ETH100
+    ei_status.reg_offset[0x10] = ax->map2 - ei_status.mem + 0x10;
+    #else
 		ei_status.reg_offset[0x1f] = ax->map2 - ei_status.mem;
+    #endif
 	}
 
 	/* got resources, now initialise and register device */
diff --git a/drivers/net/ax88796_ts_eth100.c b/drivers/net/ax88796_ts_eth100.c
new file mode 100644
index 0000000..e8eb5e7
--- /dev/null
+++ b/drivers/net/ax88796_ts_eth100.c
@@ -0,0 +1,185 @@
+/*
+ *  linux/drivers/net/ax88796_ts_eth100.c
+ *  Technologic Systems TS-ETH100 support.
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <net/ax88796.h>
+#include <mach/ts72xx.h>
+#include <mach/gpio.h>
+
+#define TS72XX_ETH100_IO8_PHYS_BASE  (TS72XX_PC104_8BIT_IO_PHYS_BASE)
+#define TS72XX_ETH100_IO8_SIZE       (TS72XX_PC104_8BIT_IO_SIZE)
+#define TS72XX_ETH100_IO16_PHYS_BASE (TS72XX_PC104_16BIT_IO_PHYS_BASE)
+#define TS72XX_ETH100_IO16_SIZE      (TS72XX_PC104_16BIT_IO_SIZE)
+
+/* Technologic systems I/O space */
+#define TS_ETH100_PLD_0 0x100
+#define TS_ETH100_PLD_1 0x110
+#define TS_ETH100_PLD_2 0x120
+#define TS_ETH100_PLD_3 0x130
+
+/* NE2000 I/O space */
+#define TS_ETH100_MAC_0 0x200
+#define TS_ETH100_MAC_1 0x240
+#define TS_ETH100_MAC_2 0x300
+#define TS_ETH100_MAC_3 0x340
+
+/* Board identifier must be 5 ; PLD revision should be 1 */
+#define is_eth100_present(__iomem, __offset) \
+  (((__raw_readb(__iomem + __offset) & 0xF) == 0x5) && \
+   ((__raw_readb(__iomem + __offset + 4) & 0xF) == 0x1))
+
+/* Jumpers status (SRAM control register) */
+#define read_irq(__iomem, __offset) \
+  (__raw_readb(__iomem + __offset + 8) & 0xE)
+
+
+static u32 offsets[0x20] = {
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+  0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F
+};
+
+static struct ax_plat_data ts72xx_eth100_asix_data = {
+  .flags = AXFLG_HAS_93CX6,
+  .wordlength = 2,
+  .dcr_val  = 0x48,
+  .rcr_val  = 0x40,
+  .reg_offsets = offsets,
+};
+
+static struct resource ts72xx_eth100_resource[] = {
+  [0] = {
+    .start = TS72XX_ETH100_IO8_PHYS_BASE,
+    .end   = TS72XX_ETH100_IO8_PHYS_BASE + 0x3ff, //0x20 -1,
+    .flags = IORESOURCE_MEM
+  },
+  [1] = { /* 0x10 is NE_DATAPORT is 16-bit access */
+    .start = TS72XX_ETH100_IO16_PHYS_BASE,
+    .end   = TS72XX_ETH100_IO16_PHYS_BASE + 0x3ff, //0x20 -1,
+    .flags = IORESOURCE_MEM
+  },
+  [2] = {
+    .start = IRQ_EP93XX_EXT1,
+    .end   = IRQ_EP93XX_EXT1,
+    .flags = IORESOURCE_IRQ
+  }
+};
+
+
+static void ts72xx_eth100_release(struct device *dev)
+{
+  // nothing to do (no kfree) because we have static struct
+}
+
+
+static struct platform_device ts72xx_eth100_device_asix = {
+  .name   = "ax88796",
+  .id   = 0,
+  .num_resources  = ARRAY_SIZE(ts72xx_eth100_resource),
+  .resource = ts72xx_eth100_resource,
+  .dev    = {
+    .platform_data = &ts72xx_eth100_asix_data,
+    .release = ts72xx_eth100_release,
+  }
+};
+
+
+static int __init ts_eth100_init(void)
+{
+  void __iomem *iomem;
+  static struct platform_device *ethX = NULL;
+
+  iomem = ioremap(TS72XX_ETH100_IO8_PHYS_BASE, TS72XX_ETH100_IO8_SIZE);
+  if (iomem != NULL) {
+    int irq = 0;
+
+    ethX = &ts72xx_eth100_device_asix;
+
+    if (is_eth100_present(iomem, TS_ETH100_PLD_0)) {
+      ethX->resource[0].start += TS_ETH100_MAC_0;
+      ethX->resource[0].end   += TS_ETH100_MAC_0;
+      ethX->resource[1].start += TS_ETH100_MAC_0;
+      ethX->resource[1].end   += TS_ETH100_MAC_0;
+      irq = read_irq(iomem, TS_ETH100_PLD_0);
+    } else if(is_eth100_present(iomem, TS_ETH100_PLD_1)) {
+      ethX->resource[0].start += TS_ETH100_MAC_1;
+      ethX->resource[0].end   += TS_ETH100_MAC_1;
+      ethX->resource[1].start += TS_ETH100_MAC_1;
+      ethX->resource[1].end   += TS_ETH100_MAC_1;
+      irq = read_irq(iomem, TS_ETH100_PLD_1);
+    } else if(is_eth100_present(iomem, TS_ETH100_PLD_2)) {
+      ethX->resource[0].start += TS_ETH100_MAC_2;
+      ethX->resource[0].end   += TS_ETH100_MAC_2;
+      ethX->resource[1].start += TS_ETH100_MAC_2;
+      ethX->resource[1].end   += TS_ETH100_MAC_2;
+      irq = read_irq(iomem, TS_ETH100_PLD_2);
+    } else if(is_eth100_present(iomem, TS_ETH100_PLD_3)) {
+      ethX->resource[0].start += TS_ETH100_MAC_3;
+      ethX->resource[0].end   += TS_ETH100_MAC_3;
+      ethX->resource[1].start += TS_ETH100_MAC_3;
+      ethX->resource[1].end   += TS_ETH100_MAC_3;
+      irq = read_irq(iomem, TS_ETH100_PLD_3);
+    } else {
+      ethX = NULL;
+    }
+
+    /* Translate IRQ number */
+    if (ethX != NULL) {
+      switch (irq) {
+        case 0x2: /* IRQ5 */
+          ethX->resource[2].start = gpio_to_irq(EP93XX_GPIO_LINE_F(3)); // 83
+          ethX->resource[2].end   = gpio_to_irq(EP93XX_GPIO_LINE_F(3));
+          gpio_direction_input(EP93XX_GPIO_LINE_F(3));
+          set_irq_type(ethX->resource[2].start, IRQ_TYPE_EDGE_RISING);
+          break;
+        case 0x4: /* IRQ6 */
+          ethX->resource[2].start = IRQ_EP93XX_EXT1;
+          ethX->resource[2].end   = IRQ_EP93XX_EXT1;
+          break;
+        case 0x8: /* IRQ7 */
+        default:
+          ethX->resource[2].start = IRQ_EP93XX_EXT3;
+          ethX->resource[2].end   = IRQ_EP93XX_EXT3;
+          break;
+      }
+    }
+
+    iounmap(iomem);
+  }
+
+  return ((ethX == NULL) ? -ENODEV :
+      platform_device_register(&ts72xx_eth100_device_asix));
+}
+
+
+static void __exit ts_eth100_exit(void)
+{
+  platform_device_unregister(&ts72xx_eth100_device_asix);
+}
+
+module_init(ts_eth100_init);
+module_exit(ts_eth100_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("Asix 88796 ethernet probe module for TS-ETH100 (TS-72xx)");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.2");
diff --git a/drivers/serial/8250_ts_ser1.c b/drivers/serial/8250_ts_ser1.c
new file mode 100644
index 0000000..a3c95d4
--- /dev/null
+++ b/drivers/serial/8250_ts_ser1.c
@@ -0,0 +1,150 @@
+/*
+ *  linux/drivers/serial/8250_ts_ser1.c
+ *  Technologic Systems TS-SER1 support.
+ *
+ * (c) Copyright 2006-2008  Matthieu Crapet <mcrapet@gmail.com>
+ * Data taken from include/asm-i386/serial.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Pin Number:
+ * 1 DCD
+ * 2 Receive data
+ * 3 Trasmit data
+ * 4 DTR
+ * 5 Signal Ground
+ * 6 DSR
+ * 7 RTS
+ * 8 CTS
+ * 9 RI
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/ts72xx.h>
+#include <mach/gpio.h>
+
+
+#define TS72XX_SER1_IO_PHYS_BASE  (TS72XX_PC104_8BIT_IO_PHYS_BASE)
+#define TS72XX_SER1_IO_SIZE       (TS72XX_PC104_8BIT_IO_SIZE)
+
+#define TS_SER1_PORT_COM3 0x3E8
+#define TS_SER1_PORT_COM4 0x2E8
+#define TS_SER1_PORT_COM5 0x3A8
+
+/* Value to write in 16550A scratch register */
+#define MARKER_BYTE 0xAA /* or 0x55 */
+
+#define PORT(_base,_irq)           \
+  {                                \
+    .iobase   = _base,             \
+    .membase  = (void __iomem *)0, \
+    .irq      = _irq,              \
+    .uartclk  = 1843200,           \
+    .iotype   = UPIO_PORT,         \
+    .flags    = UPF_BOOT_AUTOCONF, \
+  }
+// Note: IRQ can be shared (see CONFIG_SERIAL_8250_SHARE_IRQ)
+
+
+static struct plat_serial8250_port ts72xx_ser1_data_com3[] = {
+  PORT(TS_SER1_PORT_COM3, 0),
+  { },
+};
+
+static struct plat_serial8250_port ts72xx_ser1_data_com4[] = {
+  PORT(TS_SER1_PORT_COM4, 0),
+  { },
+};
+
+static struct plat_serial8250_port ts72xx_ser1_data_com5[] = {
+  PORT(TS_SER1_PORT_COM5, 0),
+  { },
+};
+
+static struct platform_device ts72xx_ser1_device = {
+  .name     = "serial8250",
+  .id       =  0,
+  .dev      = {
+    .platform_data  = ts72xx_ser1_data_com3,
+  },
+};
+
+static void __iomem *iomem;
+
+
+static int __init ts_ser1_init(void)
+{
+  static struct plat_serial8250_port *comX = NULL;
+  int n = 0; // COM number as printed on TS-SER1 pcb
+
+  iomem = ioremap(TS72XX_SER1_IO_PHYS_BASE, TS72XX_SER1_IO_SIZE);
+
+  if (iomem != NULL) {
+    __raw_writeb(MARKER_BYTE, iomem + TS_SER1_PORT_COM3 + 7);
+    if (__raw_readb(iomem + TS_SER1_PORT_COM3 + 7) == MARKER_BYTE) {
+      comX = ts72xx_ser1_data_com3;
+      n = 3;
+    } else {
+      __raw_writeb(MARKER_BYTE, iomem + TS_SER1_PORT_COM4 + 7);
+      if (__raw_readb(iomem + TS_SER1_PORT_COM4 + 7) == MARKER_BYTE) {
+        comX = ts72xx_ser1_data_com4;
+        n = 4;
+      } else {
+        __raw_writeb(MARKER_BYTE, iomem + TS_SER1_PORT_COM5 + 7);
+        if (__raw_readb(iomem + TS_SER1_PORT_COM5 + 7) == MARKER_BYTE) {
+          comX = ts72xx_ser1_data_com5;
+          n = 5;
+        }
+      }
+    }
+
+    if (comX) {
+      #if CONFIG_SERIAL_8250_TS_SER1_IRQ == 5
+      gpio_direction_input(EP93XX_GPIO_LINE_F(3));
+      comX->irq = gpio_to_irq(EP93XX_GPIO_LINE_F(3)); // 83
+      set_irq_type(comX->irq, IRQ_TYPE_EDGE_RISING);
+      #elif CONFIG_SERIAL_8250_TS_SER1_IRQ == 6
+      comX->irq = IRQ_EP93XX_EXT1;
+      #elif CONFIG_SERIAL_8250_TS_SER1_IRQ == 7
+      comX->irq = IRQ_EP93XX_EXT3;
+      #else
+      comX->irq = IRQ_EP93XX_EXT3;
+      #endif
+
+      comX->iobase += (unsigned long)iomem; // virtual address
+    }
+
+    ts72xx_ser1_device.id = n;
+    ts72xx_ser1_device.dev.platform_data = comX;
+  }
+
+  return ((comX == NULL) ? -ENODEV :
+      platform_device_register(&ts72xx_ser1_device));
+}
+
+static void __exit ts_ser1_exit(void)
+{
+  iounmap(iomem);
+  platform_device_unregister(&ts72xx_ser1_device);
+}
+
+module_init(ts_ser1_init);
+module_exit(ts_ser1_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("8250 serial probe module for TS-SER1 (TS-72xx)");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.3");
diff --git a/drivers/serial/Kconfig b/drivers/serial/Kconfig
index e522572..ff24f69 100644
--- a/drivers/serial/Kconfig
+++ b/drivers/serial/Kconfig
@@ -275,6 +275,23 @@ config SERIAL_8250_RM9K
 	  port hardware found on MIPS RM9122 and similar processors.
 	  If unsure, say N.
 
+config SERIAL_8250_TS_SER1
+	tristate "Support TS-SER1 (for TS-72XX SBC)"
+	depends on SERIAL_8250 != n && MACH_TS72XX
+	help
+	  Say Y here if you have a TS-SER1 PC/104 peripheral.
+	  COM number will be configured automaticaly.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called 8250_ts_ser1.
+
+config SERIAL_8250_TS_SER1_IRQ
+	int "Selected IRQ (5, 6 or 7)"
+	depends on SERIAL_8250_TS_SER1
+	default "5"
+	help
+	  Enter jumper IRQ configuration
+
 comment "Non-8250 serial port support"
 
 config SERIAL_AMBA_PL010
@@ -304,6 +321,14 @@ config SERIAL_AMBA_PL010_CONSOLE
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_AMBA_PL010_TS72XX
+	bool "Support for RS-485 on AMBA serial port (for TS-72XX SBC)"
+	depends on SERIAL_AMBA_PL010 != n && MACH_TS72XX
+	help
+	  This add support for RS-485 on some Technologic System SBC.
+
+	  If unsure, say N.
+
 config SERIAL_AMBA_PL011
 	tristate "ARM AMBA PL011 serial port support"
 	depends on ARM_AMBA
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index d21d5dd..f8fdb4f 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_SERIAL_8250_BOCA) += 8250_boca.o
 obj-$(CONFIG_SERIAL_8250_EXAR_ST16C554) += 8250_exar_st16c554.o
 obj-$(CONFIG_SERIAL_8250_HUB6) += 8250_hub6.o
 obj-$(CONFIG_SERIAL_8250_MCA) += 8250_mca.o
+obj-$(CONFIG_SERIAL_8250_TS_SER1) += 8250_ts_ser1.o
 obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
diff --git a/drivers/serial/amba-pl010.c b/drivers/serial/amba-pl010.c
index 429a8ae..aff4d9c 100644
--- a/drivers/serial/amba-pl010.c
+++ b/drivers/serial/amba-pl010.c
@@ -50,6 +50,10 @@
 
 #include <asm/io.h>
 
+#if defined(CONFIG_SERIAL_AMBA_PL010_TS72XX)
+#include <mach/ts72xx.h>
+#endif
+
 #define UART_NR		8
 
 #define SERIAL_AMBA_MAJOR	204
@@ -64,6 +68,12 @@
 #define UART_DUMMY_RSR_RX	256
 #define UART_PORT_SIZE		64
 
+#if defined(CONFIG_SERIAL_AMBA_PL010_TS72XX)
+static void __iomem *ts_rs485_data9_register;
+static void __iomem *ts_rs485_control_register;
+#endif
+
+
 /*
  * We wrap our port structure around the generic uart_port.
  */
@@ -385,7 +395,7 @@ pl010_set_termios(struct uart_port *port, struct ktermios *termios,
 	/*
 	 * Ask the core to calculate the divisor for us.
 	 */
-	baud = uart_get_baud_rate(port, termios, old, 0, uap->port.uartclk/16); 
+	baud = uart_get_baud_rate(port, termios, old, 0, uap->port.uartclk/16);
 	quot = uart_get_divisor(port, baud);
 
 	switch (termios->c_cflag & CSIZE) {
@@ -519,6 +529,107 @@ static int pl010_verify_port(struct uart_port *port, struct serial_struct *ser)
 	return ret;
 }
 
+
+#if defined(CONFIG_SERIAL_AMBA_PL010_TS72XX)
+static int ts72xx_rs485_init(void)
+{
+	ts_rs485_data9_register = ioremap(TS72XX_RS485_MODE_PHYS_BASE, 4096);
+	if (ts_rs485_data9_register == NULL) {
+		return -1;
+	}
+
+	ts_rs485_control_register = ioremap(TS72XX_RS485_CONTROL_PHYS_BASE, 4096);
+	if (ts_rs485_control_register == NULL) {
+		iounmap(ts_rs485_data9_register);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int ts72xx_auto485(struct uart_port *port, unsigned int cmd, unsigned long *arg)
+{
+	int baud, cflag, mode;
+	int datalength;
+
+	mode = (int)*arg;
+	if (!is_rs485_installed()) {
+		printk("amba-pl010.c: this board does not support RS485 auto mode\n");
+		return -EINVAL;
+	}
+
+	if (port->line != 1) {
+		printk("amba-pl010.c: auto RS485 mode is only supported on second port (/dev/ttyAM1)\n");
+		return -EINVAL;
+	}
+
+	datalength = 8;
+	cflag = port->state->port.tty->termios->c_cflag;
+	if (cflag & PARENB)
+		datalength++;
+
+	if (cflag & CSTOPB)
+		datalength++;
+
+	baud = tty_get_baud_rate(port->state->port.tty);
+
+	switch (cmd) {
+		case TIOC_SBCC485:
+			if ((mode & TS72XX_RS485_AUTO485FD) || (mode & TS72XX_RS485_AUTO485HD)) {
+				printk("amba-pl010.c: unsetting auto RS485 mode\n");
+				__raw_writew(TS72XX_RS485_MODE_RS232, ts_rs485_control_register);
+				__raw_writew(TS72XX_RS485_MODE_RS232, ts_rs485_data9_register);
+			}
+			break;
+		case TIOC_SBCS485:
+			if (mode & TS72XX_RS485_AUTO485FD) {
+				printk ("amba-pl010.c: setting FULL duplex auto RS485 mode\n");
+				__raw_writew(TS72XX_RS485_MODE_FD, ts_rs485_control_register);
+				if (datalength > 8)
+					__raw_writew(TS72XX_RS485_MODE_FD, ts_rs485_data9_register);
+			} else if (mode & TS72XX_RS485_AUTO485HD) {
+				printk("amba-pl010.c: setting HALF DUPLEX auto RS485 mode\n");
+				switch (baud) {
+					case 9600:
+						__raw_writew(TS72XX_RS485_MODE_9600_HD, ts_rs485_control_register);
+						break;
+					case 19200:
+						__raw_writew(TS72XX_RS485_MODE_19200_HD, ts_rs485_control_register);
+						break;
+					case 57600:
+						__raw_writew(TS72XX_RS485_MODE_57600_HD, ts_rs485_control_register);
+						break;
+					case 115200:
+						__raw_writew(TS72XX_RS485_MODE_115200_HD, ts_rs485_control_register);
+						break;
+					default:
+						printk("amba-pl010.c: %d baud rate is not supported for auto RS485 mode\n", baud);
+						return -1;
+				}
+				if (datalength > 8)
+					__raw_writew(TS72XX_RS485_MODE_FD, ts_rs485_data9_register);
+			}
+			break;
+	}
+
+	return 0;
+}
+
+static int pl010_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg)
+{
+	switch (cmd) {
+		case TIOC_SBCC485:
+		case TIOC_SBCS485:
+			return ts72xx_auto485(port, cmd, (unsigned long *)arg);
+		default:
+			return -ENOIOCTLCMD;
+	}
+
+	return -ENOIOCTLCMD;
+}
+#endif /* CONFIG_SERIAL_AMBA_PL010_TS72XX */
+
+
 static struct uart_ops amba_pl010_pops = {
 	.tx_empty	= pl010_tx_empty,
 	.set_mctrl	= pl010_set_mctrl,
@@ -536,6 +647,9 @@ static struct uart_ops amba_pl010_pops = {
 	.request_port	= pl010_request_port,
 	.config_port	= pl010_config_port,
 	.verify_port	= pl010_verify_port,
+#if defined(CONFIG_SERIAL_AMBA_PL010_TS72XX)
+	.ioctl	= pl010_ioctl,
+#endif
 };
 
 static struct uart_amba_port *amba_ports[UART_NR];
@@ -792,11 +906,22 @@ static int __init pl010_init(void)
 	printk(KERN_INFO "Serial: AMBA driver\n");
 
 	ret = uart_register_driver(&amba_reg);
-	if (ret == 0) {
-		ret = amba_driver_register(&pl010_driver);
-		if (ret)
-			uart_unregister_driver(&amba_reg);
-	}
+  if (ret == 0) {
+    ret = amba_driver_register(&pl010_driver);
+
+    #if defined(CONFIG_SERIAL_AMBA_PL010_TS72XX)
+    if (!ret && is_rs485_installed()) {
+      ret = ts72xx_rs485_init();
+      if (ret)
+        printk("amba-pl010.c: ts72xx_rs485_init() failed\n");
+      else
+        printk("amba-pl010.c: auto RS485 mode initialized\n");
+    }
+    #endif
+
+    if (ret)
+      uart_unregister_driver(&amba_reg);
+  }
 	return ret;
 }
 
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 4b6f7cb..e71e2ea 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -244,6 +244,12 @@ config SPI_XILINX
 	  See the "OPB Serial Peripheral Interface (SPI) (v1.00e)"
 	  Product Specification document (DS464) for hardware details.
 
+config SPI_EP93XX
+	tristate "EP93XX SPI controller"
+	depends on SPI_MASTER
+	help
+	  Simple SPI driver for EP93xx.
+
 #
 # Add new SPI master controllers in alphabetical order above this line
 #
@@ -272,6 +278,13 @@ config SPI_TLE62X0
 	  sysfs interface, with each line presented as a kind of GPIO
 	  exposing both switch control and diagnostic feedback.
 
+config SPI_TMP124
+	tristate "Texas Instruments TMP1224, TMP124"
+	depends on SPI_MASTER && SYSFS
+	help
+	  SPI driver for TMP12X temperature sensor chips.
+	  This provides a sysfs entry for temperature reading (2C accurate).
+
 #
 # Add new SPI protocol masters in alphabetical order above this line
 #
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 21a1182..ccc9075 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
+obj-$(CONFIG_SPI_EP93XX)		+= spi_ep93xx.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
 obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 # 	... add above this line ...
@@ -38,6 +39,7 @@ obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 # SPI protocol drivers (device/link on bus)
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
+obj-$(CONFIG_SPI_TMP124)	+= tmp124.o
 # 	... add above this line ...
 
 # SPI slave controller drivers (upstream link)
diff --git a/drivers/spi/spi_ep93xx.c b/drivers/spi/spi_ep93xx.c
new file mode 100644
index 0000000..0e86b38
--- /dev/null
+++ b/drivers/spi/spi_ep93xx.c
@@ -0,0 +1,500 @@
+/*
+ *  EP93xx SPI driver
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ * Based on pxa2xx_spi.c by Stephen Street / StreetFire Sound Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Notes:
+ *  - Uses SSP IP of processor
+ *  - Restricted to SPI master mode
+ *  - No DMA transfer
+ *  - No power management support
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <mach/hardware.h>
+#include <mach/spi.h>
+
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+
+#include "spi_ep93xx.h"
+
+
+struct ep93xx_spi {
+  struct spi_master *master;    /* SPI framework hookup */
+  void __iomem *ioaddr;         /* Virtual base address to SSP registers */
+  u32 freq_max;
+  u32 freq_min;
+  struct clk *clk;
+
+  struct workqueue_struct *workqueue;
+  struct work_struct work;
+  spinlock_t lock;
+  struct list_head queue;
+
+  struct ep93xx_spi_chip *cs_chip; /* Chip Select function */
+};
+
+static inline u16 read_reg(void __iomem *base, off_t offset)
+{
+	return __raw_readw(base + offset);
+}
+
+static inline void write_reg(u16 v, void __iomem *base, off_t offset)
+{
+	__raw_writew(v, base + offset);
+}
+
+/*
+ *  compute SCR and CPSDVR bits to setup spi clock based on main input clock rate
+ *  that was specified in platform data structure
+ *  according to datasheet:
+ *    tempclk = sspclk / cpsdvr
+ *    spiclk = tempclk / (scr + 1)
+ *    SCR valid range is 0..255
+ *    CPSDVR valid range is 2..254
+ */
+static int spi_speed_set(struct ep93xx_spi *drv_data, unsigned speed_hz)
+{
+	unsigned long mainclk_hz = clk_get_rate(drv_data->clk);
+	u32 cpsdvr, scr;
+	u16 ssp_cr0;
+
+	for (cpsdvr = 2; cpsdvr <= 254; cpsdvr+=2) {
+		scr = DIV_ROUND_UP(mainclk_hz / speed_hz, cpsdvr);
+		/* now we have SCR+1 in scr, so count with that */
+		if (scr == 0) { 	/* speed_hz too big */
+			return -EINVAL;
+		}
+		if (scr <= (255 + 1))
+			break;		/* we have valid scr and cpsdvr */
+	}
+	if (cpsdvr > 254) {
+		/* speed_hz is too small, set to minimum speed */
+		scr = 256;
+		cpsdvr = 254;
+	}
+	scr--;
+	write_reg(cpsdvr, drv_data->ioaddr, SSPCPSR);
+	ssp_cr0 = read_reg(drv_data->ioaddr, SSPCR0);
+	ssp_cr0 &= ~(SSP_CONTROL_SCR(0xff));
+	write_reg((ssp_cr0 | SSP_CONTROL_SCR(scr)), drv_data->ioaddr, SSPCR0);
+
+	return 0;
+}
+
+static irqreturn_t ssp_int(int irq, void *dev_id)
+{
+	struct ep93xx_spi *drv_data = dev_id;
+	write_reg(SSP_SSPIxx_RORIS, drv_data->ioaddr, SSPIxR); /* clear it */
+
+	printk(KERN_WARNING "SSP overrun\n");
+	return IRQ_HANDLED;
+}
+
+static int transfer_one_work(struct ep93xx_spi *drv_data, struct spi_message *msg)
+{
+	struct spi_device *spi = msg->spi;
+	struct spi_transfer *xfer;
+	int i;
+	u8 *p;
+
+	drv_data->cs_chip->cs_control(SPI_CS_ASSERT);
+
+	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+		if (!(xfer->tx_buf || xfer->rx_buf)) {
+			dev_dbg(&spi->dev, "missing rx or tx buf\n");
+			drv_data->cs_chip->cs_control(SPI_CS_DEASSERT);
+			return -EINVAL;
+		}
+
+		if (xfer->bits_per_word) {
+			u16 v = read_reg(drv_data->ioaddr, SSPCR0);
+			v = v & SSP_CONTROL_DSS_MASK;
+			v = v | ((xfer->bits_per_word - 1) & SSP_CONTROL_DSS_MASK);
+			write_reg(v, drv_data->ioaddr, SSPCR0);
+		}
+
+		if (xfer->speed_hz) {
+			if (spi_speed_set(drv_data,xfer->speed_hz) != 0){
+				dev_err(&spi->dev, "xfer speed hz invalid\n");
+				return -EINVAL;
+			}
+		}
+
+		if (xfer->tx_buf) {
+			p = (u8 *)xfer->tx_buf;
+
+			if ((spi->bits_per_word == 16 && xfer->bits_per_word == 0) ||
+			    (xfer->bits_per_word == 16)) {
+				for (i = 0; i < xfer->len; i+=2)
+					write_reg((p[i] << 8) + p[i+1], drv_data->ioaddr, SSPDR);
+			} else {
+				for (i = 0; i < xfer->len; i++)
+					write_reg(p[i], drv_data->ioaddr, SSPDR);
+			}
+		}
+
+		if (xfer->rx_buf) {
+			u16 v;
+			p = xfer->rx_buf;
+
+			if ((spi->bits_per_word == 16 && xfer->bits_per_word == 0) ||
+			    (xfer->bits_per_word == 16)) {
+					for (i = 0; i < xfer->len; i+=2) {
+						  v = read_reg(drv_data->ioaddr, SSPDR);
+						  p[i] = v >> 8;
+						  p[i+1] = v & 0xFF;
+					}
+			} else {
+					for (i = 0; i < xfer->len; i++)
+						  p[i] = read_reg(drv_data->ioaddr, SSPDR);
+			}
+		}
+
+		/* restore device bits_per_word */
+		if (xfer->bits_per_word) {
+			u16 v = read_reg(drv_data->ioaddr, SSPCR0);
+			v = v & SSP_CONTROL_DSS_MASK;
+			v |= spi->bits_per_word - 1;
+			write_reg(v, drv_data->ioaddr, SSPCR0);
+		}
+
+		/* restore device speed_hz */
+		if (xfer->speed_hz) {
+			if (spi_speed_set(drv_data,spi->max_speed_hz) != 0)
+				return -EINVAL;
+		}
+
+		dev_dbg(&spi->dev, "transfer: len=%u, tx_buf=%p, rx_buf=%p\n", xfer->len, xfer->tx_buf, xfer->rx_buf);
+	}
+
+	if (xfer->delay_usecs)
+		udelay(xfer->delay_usecs);
+	drv_data->cs_chip->cs_control(SPI_CS_DEASSERT);
+
+	msg->actual_length = 0;
+	msg->status = 0;
+
+	if (msg->complete)
+		msg->complete(msg->context);
+
+	return 0;
+}
+
+
+static void ssp_work(struct work_struct *work)
+{
+	struct ep93xx_spi *drv_data = container_of(work, struct ep93xx_spi, work);
+	unsigned long flags;
+
+	spin_lock_irqsave(&drv_data->lock, flags);
+	while (!list_empty(&drv_data->queue)) {
+		struct spi_message *m;
+
+		m = container_of(drv_data->queue.next, struct spi_message, queue);
+		list_del_init(&m->queue);
+		spin_unlock_irqrestore(&drv_data->lock, flags);
+
+		transfer_one_work(drv_data, m);
+
+		spin_lock_irqsave(&drv_data->lock, flags);
+	}
+	spin_unlock_irqrestore(&drv_data->lock, flags);
+}
+
+
+static int ssp_transfer(struct spi_device *spi, struct spi_message *m)
+{
+	struct spi_master *master = spi->master;
+	struct ep93xx_spi *drv_data = spi_master_get_devdata(master);
+	struct spi_transfer *t;
+	unsigned long flags;
+
+	m->actual_length = 0;
+
+	/* check each transfer's parameters */
+	list_for_each_entry (t, &m->transfers, transfer_list) {
+		u32 speed_hz = t->speed_hz ? t->speed_hz : spi->max_speed_hz;
+		u8 bits_per_word = t->bits_per_word ? t->bits_per_word : spi->bits_per_word;
+
+		if (!t->tx_buf && !t->rx_buf && t->len)
+			return -EINVAL;
+		if (bits_per_word < 4 || bits_per_word > 16)
+			return -EINVAL;
+		/*if (t->len & ((bits_per_word >> 3) - 1))
+			return -EINVAL;*/
+		if (speed_hz < drv_data->freq_min || speed_hz > drv_data->freq_max)
+			return -EINVAL;
+	}
+
+	spin_lock_irqsave(&drv_data->lock, flags);
+	list_add_tail(&m->queue, &drv_data->queue);
+	queue_work(drv_data->workqueue, &drv_data->work);
+	spin_unlock_irqrestore(&drv_data->lock, flags);
+
+	return 0;
+
+}
+
+/* the spi->mode bits understood by this driver: */
+#define MODEBITS (SPI_CPOL | SPI_CPHA)
+
+static int ssp_setup(struct spi_device *spi)
+{
+	struct ep93xx_spi *drv_data = spi_master_get_devdata(spi->master);
+	struct ep93xx_spi_chip *chip_info;
+	u16 v;
+
+	/* Get controller data */
+	chip_info = spi->controller_data;
+	if (!chip_info) {
+		dev_err(&spi->dev, "setup: controller data required\n");
+		return -EINVAL;
+	}
+	drv_data->cs_chip = chip_info;
+	drv_data->cs_chip->cs_control(SPI_CS_INIT);
+
+	if (!spi->bits_per_word) {
+		spi->bits_per_word = 8;
+	}
+
+	if (spi->bits_per_word < 4 || spi->bits_per_word > 16) {
+		  dev_dbg(&spi->dev, "setup: unsupported %d bit words\n",
+		  spi->bits_per_word);
+		  return -EINVAL;
+	}
+
+	if (spi->chip_select > spi->master->num_chipselect) {
+		  dev_dbg(&spi->dev, "setup: invalid chipselect %u (%u defined)\n",
+		  spi->chip_select,  spi->master->num_chipselect);
+		  return -EINVAL;
+	}
+
+	if (spi->mode & ~MODEBITS) {
+		 dev_dbg(&spi->dev, "setup: unsupported mode bits %x\n",
+		 spi->mode & ~MODEBITS);
+		 return -EINVAL;
+	}
+
+	v = read_reg(drv_data->ioaddr, SSPCR0);
+
+	if (spi->mode & SPI_CPOL)
+		v |= SSP_CONTROL_SPO;
+	else
+		v &= ~SSP_CONTROL_SPO;
+
+	if (spi->mode & SPI_CPHA)
+		v |= SSP_CONTROL_SPH;
+	else
+		v &= ~SSP_CONTROL_SPH;
+
+	v = v & SSP_CONTROL_DSS_MASK;
+	v |= spi->bits_per_word - 1;
+
+	write_reg(v, drv_data->ioaddr, SSPCR0);
+
+	if (!spi->max_speed_hz) {
+		spi->max_speed_hz = drv_data->freq_min;
+	} else if (spi->max_speed_hz > drv_data->freq_max ||
+			spi->max_speed_hz < drv_data->freq_min){
+		return -EINVAL;
+	}
+
+	if (spi_speed_set(drv_data,spi->max_speed_hz) != 0){
+		dev_dbg(&spi->dev, "setup: unsupported speed %u\n", spi->max_speed_hz);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static void ssp_cleanup(struct spi_device *spi)
+{
+	struct ep93xx_spi *drv_data = spi_master_get_devdata(spi->master);
+	drv_data->cs_chip = NULL;
+}
+
+
+static int __init spi_ep93xx_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct spi_master *master;
+	struct ep93xx_spi_data *spi_data = pdev->dev.platform_data;
+	struct ep93xx_spi *drv_data = NULL;
+	struct resource *memory_resource;
+	int irq, status = 0, min_div = 2, max_div = 254*(255+1);
+
+	/* Check I2SonSSP bit (ssp pins and i2s pins are multiplexed)
+	   We could force with ep93xx_devcfg_clear_bits */
+	if (readl(EP93XX_SYSCON_DEVCFG) & EP93XX_SYSCON_DEVCFG_I2SONSSP)
+		return -ENODEV;
+
+	/* Allocate master with space for drv_data */
+	master = spi_alloc_master(dev, sizeof(struct ep93xx_spi));
+	if (!master) {
+		dev_err(&pdev->dev, "can not alloc spi_master\n");
+		return -ENOMEM;
+	}
+
+	/* Setup register addresses */
+	memory_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!memory_resource) {
+		dev_err(&pdev->dev, "memory resources not defined\n");
+		status = -ENODEV;
+		goto out_error_master_alloc;
+	}
+
+	drv_data = spi_master_get_devdata(master);
+	drv_data->master = master;
+	drv_data->ioaddr = ioremap(memory_resource->start, memory_resource->end - memory_resource->start + 1);
+	drv_data->clk = clk_get(&pdev->dev, "sspclk");
+	drv_data->freq_max = clk_get_rate(drv_data->clk) / min_div;
+	drv_data->freq_min = clk_get_rate(drv_data->clk) / max_div + 1;
+
+	INIT_WORK(&drv_data->work, ssp_work);
+	spin_lock_init(&drv_data->lock);
+	INIT_LIST_HEAD(&drv_data->queue);
+
+	drv_data->workqueue = create_singlethread_workqueue(dev_name(master->dev.parent));
+	if (!drv_data->workqueue) {
+		status = -EBUSY;
+		goto out_error_master_alloc;
+	}
+
+	master->bus_num = pdev->id;
+	master->num_chipselect = spi_data->chip_select_num;
+	master->cleanup = ssp_cleanup;
+	master->setup = ssp_setup;
+	master->transfer = ssp_transfer;
+
+	/* Attach to IRQ */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "irq resource not defined\n");
+		status = -ENODEV;
+		goto out_error_master_alloc;
+	}
+
+	status = request_irq(irq, ssp_int, 0, dev_name(dev), drv_data);
+	if (status < 0) {
+		dev_err(&pdev->dev, "can not get IRQ\n");
+		goto out_error_master_alloc;
+	}
+
+	/* Load default SSP configuration */
+	write_reg(SSP_CONTROL_SSE, drv_data->ioaddr, SSPCR1);
+	write_reg(SPI_DEFAULT0, drv_data->ioaddr, SSPCR0);
+	write_reg(SPI_DEFAULT_DIVISOR, drv_data->ioaddr, SSPCPSR);
+	write_reg(0x00, drv_data->ioaddr, SSPCR1);
+
+	/* Register with the SPI framework */
+	platform_set_drvdata(pdev, drv_data);
+	status = spi_register_master(master);
+	if (status != 0) {
+		dev_err(&pdev->dev, "problem registering spi master\n");
+		goto out_error_irq_alloc;
+	}
+
+	write_reg(SPI_DEFAULT1, drv_data->ioaddr, SSPCR1);
+	return status;
+
+out_error_irq_alloc:
+	free_irq(irq, drv_data);
+
+out_error_master_alloc:
+	spi_master_put(master);
+	return status;
+}
+
+static int spi_ep93xx_remove(struct platform_device *pdev)
+{
+	struct ep93xx_spi *drv_data = platform_get_drvdata(pdev);
+	int irq;
+
+	if (!drv_data)
+		return 0;
+
+	/* Disable SSP (clear SSE bit) */
+	write_reg(0x00, drv_data->ioaddr, SSPCR1);
+
+	/* Release IRQ */
+	irq = platform_get_irq(pdev, 0);
+
+	if (irq >= 0)
+		free_irq(irq, drv_data);
+
+	/* Disconnect from the SPI framework */
+	spi_unregister_master(drv_data->master);
+
+	/* Remove the workqueue */
+	destroy_workqueue(drv_data->workqueue);
+
+	iounmap(drv_data->ioaddr);
+
+	/* Prevent double remove */
+	platform_set_drvdata(pdev, NULL);
+
+	clk_put(drv_data->clk);
+	spi_master_put(drv_data->master);
+
+	return 0;
+}
+
+static void spi_ep93xx_shutdown(struct platform_device *pdev)
+{
+	int status = 0;
+
+	if ((status = spi_ep93xx_remove(pdev)) != 0)
+		dev_err(&pdev->dev, "shutdown failed with %d\n", status);
+}
+
+static struct platform_driver ep93xx_spi_platform_driver = {
+	.driver = {
+		.name = "ep93xx-spi",
+		.bus = &platform_bus_type,
+		.owner = THIS_MODULE,
+	},
+	.remove = __exit_p(spi_ep93xx_remove),
+	.shutdown = spi_ep93xx_shutdown,
+};
+
+static int __init spi_ep93xx_init(void)
+{
+	return platform_driver_probe(&ep93xx_spi_platform_driver, spi_ep93xx_probe);
+}
+
+static void __exit spi_ep93xx_exit(void)
+{
+	platform_driver_unregister(&ep93xx_spi_platform_driver);
+}
+
+module_init(spi_ep93xx_init);
+module_exit(spi_ep93xx_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("EP93xx SPI Controller Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.25");
diff --git a/drivers/spi/spi_ep93xx.h b/drivers/spi/spi_ep93xx.h
new file mode 100644
index 0000000..6fad735
--- /dev/null
+++ b/drivers/spi/spi_ep93xx.h
@@ -0,0 +1,61 @@
+/*
+ *  EP93xx SPI (simple) include
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ * Based on pxa2xx_spi.c by Stephen Street / StreetFire Sound Labs
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/* SSP Registers */
+#define SSPCR0   0x00 /* Control register 0 */
+#define SSPCR1   0x04 /* Control register 1 */
+#define SSPDR    0x08 /* Receice FIFO data register (16-bit read) */
+                      /* Transmit FIFO data register (16-bit write) */
+#define SSPSR    0x0C /* Status register */
+#define SSPCPSR  0x10 /* Clock prescale register (from 2 to 254, even number) */
+#define SSPIxR   0x14 /* Interrupt identification register (read) */
+                      /* Interrupt clear register (write) */
+
+/* SSP control registers bit fields & masks */
+#define SSP_CONTROL_SCR(x)         (((x) & 0xFF) << 8) /* Serial clock rate = SCLKOUT / CPSDVR / (1+SCR) */
+#define SSP_CONTROL_SPH            (1 << 7)            /* SCLKOUT phase (for SPI only) */
+#define SSP_CONTROL_SPO            (1 << 6)            /* SCLKOUT polarity (for SPI only) */
+#define SSP_CONTROL_FRF(x)         (((x) & 3) << 4)    /* Frame format (0=SPI) */
+#define SSP_CONTROL_DSS_4BIT_DATA   3
+#define SSP_CONTROL_DSS_8BIT_DATA   7
+#define SSP_CONTROL_DSS_15BIT_DATA 14
+#define SSP_CONTROL_DSS_16BIT_DATA 15
+#define SSP_CONTROL_DSS_MASK        0xF
+#define SSP_CONTROL_MS              (1 << 5)           /* 0=master, 1=slave (can be modified when SSE=0) */
+#define SSP_CONTROL_SSE             (1 << 4)           /* SSP operation enable (=1), disable (=0) */
+#define SSP_CONTROL_LBM             (1 << 3)           /* Loop back mode */
+#define SSP_CONTROL_RORIE           (1 << 2)           /* Interrupt enable : overrun condition */
+#define SSP_CONTROL_TIE             (1 << 1)           /* Interrupt enable : transmit fifo */
+#define SSP_CONTROL_RIE             (1 << 0)           /* Interrupt enable : receive fifo */
+
+/* SSP status register (read only) */
+#define SSP_STATUS_BUSY             (1 << 4)           /* Busy flag (0: SSP is idle) */
+#define SSP_STATUS_RFF              (1 << 3)           /* Receive fifo full ? (1=full) */
+#define SSP_STATUS_RNE              (1 << 2)           /* Receive fifo not empty ? (0=empty) */
+#define SSP_STATUS_TNF              (1 << 1)           /* Transmit fifo not full ? (0=full) */
+#define SSP_STATUS_TFE              (1 << 0)           /* Transmit fifo empty ? (1=empty) */
+
+/* SSP SSPIIR/SSPICR register (write 1 to clear interrupt) */
+#define SSP_SSPIxx_RORIS            (1 << 2)           /* Receive fifo overrun interrupt status */
+#define SSP_SSPIxx_TIS              (1 << 1)           /* Transmit fifo service request interrupt status */
+#define SSP_SSPIxx_RIS              (1 << 0)           /* Receive fifo service request interrupt status */
+
+/* Default configuration values */
+#define SPI_DEFAULT0 (SSP_CONTROL_DSS_16BIT_DATA | SSP_CONTROL_FRF(0) | SSP_CONTROL_SCR(0))
+#define SPI_DEFAULT1 (SSP_CONTROL_SSE | SSP_CONTROL_RORIE)
+#define SPI_DEFAULT_DIVISOR 254
diff --git a/drivers/spi/tmp124.c b/drivers/spi/tmp124.c
new file mode 100644
index 0000000..d3600f7
--- /dev/null
+++ b/drivers/spi/tmp124.c
@@ -0,0 +1,158 @@
+/*
+ *  TMP124 SPI protocol driver
+ *
+ * (c) Copyright 2008  Matthieu Crapet <mcrapet@gmail.com>
+ * Based on tle62x0.c by Ben Dooks, <ben@simtec.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Note: The chip uses a '3-wire SPI' (miso and mosi are the same pin).
+ */
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+
+struct tmp124_state {
+  struct spi_device *bus;
+  u8 tx_buff[2];
+  u8 rx_buff[2];
+};
+
+
+static inline int tmp124_write_then_read(struct tmp124_state *st)
+{
+  struct spi_message msg;
+  struct spi_transfer xfer[2] = {
+    {
+      .tx_buf      = st->tx_buff,
+      .rx_buf      = NULL,
+      .len         = 2,
+      .delay_usecs = 1000,
+    }, {
+      .tx_buf = NULL,
+      .rx_buf = st->rx_buff,
+      .len    = 2,
+    }
+  };
+
+  spi_message_init(&msg);
+  spi_message_add_tail(&xfer[0], &msg);
+  spi_message_add_tail(&xfer[1], &msg);
+
+  return spi_sync(st->bus, &msg);
+}
+
+
+static ssize_t tmp124_temperature_show(struct device *dev,
+    struct device_attribute *attr, char *buf)
+{
+  struct tmp124_state *st = dev_get_drvdata(dev);
+  int ret;
+
+  st->tx_buff[0] = 0x80;
+  st->tx_buff[1] = 0x00;
+
+  ret = tmp124_write_then_read(st);
+  if (ret < 0) {
+    dev_err(&st->bus->dev, "tmp124_write_then_read\n");
+    ret = 0;
+  } else {
+    signed short v = (st->rx_buff[0] << 8) + st->rx_buff[1];
+    signed long val;
+
+    val = v >> 3;
+
+    /* 2 digit precision (0.0625*100) */
+    val = (val * 50) / 8;
+    ret = snprintf(buf, PAGE_SIZE, "%ld.%02ld\n", val/100, abs(val%100));
+  }
+  return ret;
+}
+
+
+static DEVICE_ATTR(temperature, S_IRUGO, tmp124_temperature_show, NULL);
+
+
+static int __devinit tmp124_probe(struct spi_device *spi)
+{
+  struct tmp124_state *st;
+  int ret;
+
+  st = kzalloc(sizeof(struct tmp124_state), GFP_KERNEL);
+  if (st == NULL) {
+    dev_err(&spi->dev, "no memory for device state\n");
+    return -ENOMEM;
+  }
+
+  /* required config */
+  spi->bits_per_word = 16;
+
+  st->bus = spi;
+
+  ret = spi_setup(spi);
+  if (ret) {
+    dev_err(&spi->dev, "setup device\n");
+    goto err;
+  }
+
+  ret = device_create_file(&spi->dev, &dev_attr_temperature);
+  if (ret) {
+    dev_err(&spi->dev, "cannot create temperature attribute\n");
+    goto err;
+  }
+
+  spi_set_drvdata(spi, st);
+  return 0;
+
+err:
+  kfree(st);
+  return ret;
+}
+
+
+static int __devexit tmp124_remove(struct spi_device *spi)
+{
+  struct tmp124_state *st = spi_get_drvdata(spi);
+
+  device_remove_file(&spi->dev, &dev_attr_temperature);
+  kfree(st);
+
+  return 0;
+}
+
+
+static struct spi_driver tmp124_driver = {
+  .driver = {
+    .name = "tmp124",
+    .owner  = THIS_MODULE,
+  },
+  .probe    = tmp124_probe,
+  .remove   = __devexit_p(tmp124_remove),
+};
+
+static __init int tmp124_init(void)
+{
+  return spi_register_driver(&tmp124_driver);
+}
+
+static __exit void tmp124_exit(void)
+{
+  spi_unregister_driver(&tmp124_driver);
+}
+
+module_init(tmp124_init);
+module_exit(tmp124_exit);
+
+MODULE_AUTHOR("Matthieu Crapet <mcrapet@gmail.com>");
+MODULE_DESCRIPTION("TMP124 SPI Protocol Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("0.1");
